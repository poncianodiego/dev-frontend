{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched = exports.isBatchedProvider = void 0;\n\nconst address_1 = require(\"@ethersproject/address\");\n\nconst contracts_1 = require(\"@ethersproject/contracts\");\n\nconst properties_1 = require(\"@ethersproject/properties\");\n\nconst WebSocketAugmentedProvider_1 = require(\"./WebSocketAugmentedProvider\");\n\nconst multicallAddress = {\n  1: \"0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441\",\n  3: \"0x53C43764255c17BD724F74c4eF150724AC50a3ed\",\n  4: \"0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821\",\n  5: \"0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e\",\n  42: \"0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A\"\n};\n\nconst hasMulticall = chainId => chainId in multicallAddress;\n\nconst multicallAbi = [{\n  type: \"function\",\n  name: \"aggregate\",\n  stateMutability: \"nonpayable\",\n  constant: false,\n  payable: false,\n  inputs: [{\n    components: [{\n      name: \"target\",\n      type: \"address\"\n    }, {\n      name: \"callData\",\n      type: \"bytes\"\n    }],\n    name: \"calls\",\n    type: \"tuple[]\"\n  }],\n  outputs: [{\n    name: \"blockNumber\",\n    type: \"uint256\"\n  }, {\n    name: \"returnData\",\n    type: \"bytes[]\"\n  }]\n}, {\n  type: \"function\",\n  name: \"getEthBalance\",\n  stateMutability: \"view\",\n  constant: true,\n  payable: false,\n  inputs: [{\n    name: \"addr\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"balance\",\n    type: \"uint256\"\n  }]\n}];\n\nconst emptyBatch = () => ({\n  calls: [],\n  callbacks: []\n}); // TODO\n//\n// Technically, requests that have a `from` address shouldn't be batched, because `msg.sender` will\n// be replaced with the Multicall contract's address when the batched calls are being executed.\n//\n// Currently, `@liquity/lib-ethers` makes many of its read calls through Signers, which populates\n// `from`. Instead these calls should be made through a Provider, and `from` should be omitted\n// (since none of the read calls in Liquity care about `msg.sender`).\n//\n// Then we'll be able to properly exclude calls that have `from` addresses from batching.\n\n\nconst batchableCall = request => request.gasLimit === undefined && request.gasPrice === undefined && request.value === undefined;\n\nconst batchedCall = (request, multicallAddress) => request.to === multicallAddress && typeof request.data === \"string\" && request.data.startsWith(\"0x252dba42\"); // signature of `aggregate((address,bytes)[])`\n\n\nconst batchedProviders = [];\n\nconst isBatchedProvider = provider => batchedProviders.some(batchedProvider => provider instanceof batchedProvider);\n\nexports.isBatchedProvider = isBatchedProvider;\n\nconst Batched = Base => {\n  const batchedProvider = class extends Base {\n    constructor() {\n      super(...arguments);\n      this.batchingDelayMs = 10;\n      this._chainId = 0;\n      this._batched = emptyBatch();\n      this._numberOfBatchedCalls = 0;\n      this._numberOfActualCalls = 0;\n    }\n\n    get chainId() {\n      return this._chainId;\n    }\n\n    set chainId(chainId) {\n      if (this._multicall) {\n        throw new Error(\"can only set chainId once\");\n      }\n\n      if (hasMulticall(chainId)) {\n        this._multicall = new contracts_1.Contract(multicallAddress[chainId], multicallAbi, this);\n      }\n\n      this._chainId = chainId;\n    }\n\n    async _dispatchCalls() {\n      const {\n        calls,\n        callbacks,\n        blockTag\n      } = this._batched;\n      this._batched = emptyBatch();\n\n      try {\n        const results = calls.length > 1 ? await this._multicall.callStatic.aggregate(calls, {\n          blockTag\n        }).then(x => x.returnData) : [await super.call({\n          to: calls[0].target,\n          data: calls[0].callData\n        }, blockTag)];\n        callbacks.forEach(([resolve], i) => resolve(results[i]));\n      } catch (error) {\n        callbacks.forEach(([, reject]) => reject(error));\n      }\n    }\n\n    _enqueueCall(call) {\n      if (this._timeoutId !== undefined) {\n        clearTimeout(this._timeoutId);\n      }\n\n      this._batched.calls.push(call);\n\n      this._timeoutId = setTimeout(() => this._dispatchCalls(), this.batchingDelayMs);\n      return new Promise((resolve, reject) => this._batched.callbacks.push([resolve, reject]));\n    }\n\n    _alreadyBatchedCallsConflictWith(blockTag) {\n      var _a;\n\n      return this._batched.calls.length !== 0 && (blockTag !== null && blockTag !== void 0 ? blockTag : \"latest\") !== ((_a = this._batched.blockTag) !== null && _a !== void 0 ? _a : \"latest\");\n    }\n\n    async call(request, blockTag) {\n      if (!this._multicall) {\n        return super.call(request, blockTag);\n      } else {\n        const now = new Date().getTime();\n\n        if (this._timeOfLastRatioCheck === undefined) {\n          this._timeOfLastRatioCheck = now;\n        } else {\n          const timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;\n\n          if (timeSinceLastRatioCheck >= 10000 && this._numberOfActualCalls) {\n            // console.log(\n            //   `Call batching ratio: ${\n            //     Math.round((10 * this._numberOfBatchedCalls) / this._numberOfActualCalls) / 10\n            //   }X`\n            // );\n            this._numberOfBatchedCalls = 0;\n            this._numberOfActualCalls = 0;\n            this._timeOfLastRatioCheck = now;\n          }\n        }\n      }\n\n      const [resolvedRequest, resolvedBlockTag] = await Promise.all([properties_1.resolveProperties(request), blockTag]);\n\n      if (batchedCall(resolvedRequest, this._multicall.address) || !batchableCall(resolvedRequest) || this._alreadyBatchedCallsConflictWith(resolvedBlockTag)) {\n        this._numberOfActualCalls++;\n        return super.call(resolvedRequest, resolvedBlockTag);\n      } else {\n        this._numberOfBatchedCalls++;\n\n        if (this._batched.calls.length === 0) {\n          this._batched.blockTag = resolvedBlockTag;\n        }\n\n        return this._enqueueCall({\n          target: resolvedRequest.to,\n          callData: resolvedRequest.data\n        });\n      }\n    }\n\n    async getBalance(addressOrName, blockTag) {\n      const [resolvedAddressOrName, resolvedBlockTag] = await Promise.all([addressOrName, blockTag]);\n\n      if (!address_1.isAddress(resolvedAddressOrName) || !this._multicall) {\n        return super.getBalance(resolvedAddressOrName, blockTag);\n      }\n\n      const [balance] = await this._multicall.functions.getEthBalance(resolvedAddressOrName, {\n        blockTag: resolvedBlockTag\n      });\n      return balance;\n    }\n\n  };\n  batchedProviders.push(batchedProvider);\n  return batchedProvider;\n};\n\nexports.Batched = Batched;\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched(WebSocketAugmentedProvider_1.WebSocketAugmentedWeb3Provider);","map":{"version":3,"sources":["../../src/BatchedProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched = exports.isBatchedProvider = void 0;\nconst address_1 = require(\"@ethersproject/address\");\nconst contracts_1 = require(\"@ethersproject/contracts\");\nconst properties_1 = require(\"@ethersproject/properties\");\nconst WebSocketAugmentedProvider_1 = require(\"./WebSocketAugmentedProvider\");\nconst multicallAddress = {\n    1: \"0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441\",\n    3: \"0x53C43764255c17BD724F74c4eF150724AC50a3ed\",\n    4: \"0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821\",\n    5: \"0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e\",\n    42: \"0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A\"\n};\nconst hasMulticall = (chainId) => chainId in multicallAddress;\nconst multicallAbi = [\n    {\n        type: \"function\",\n        name: \"aggregate\",\n        stateMutability: \"nonpayable\",\n        constant: false,\n        payable: false,\n        inputs: [\n            {\n                components: [\n                    {\n                        name: \"target\",\n                        type: \"address\"\n                    },\n                    {\n                        name: \"callData\",\n                        type: \"bytes\"\n                    }\n                ],\n                name: \"calls\",\n                type: \"tuple[]\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"blockNumber\",\n                type: \"uint256\"\n            },\n            {\n                name: \"returnData\",\n                type: \"bytes[]\"\n            }\n        ]\n    },\n    {\n        type: \"function\",\n        name: \"getEthBalance\",\n        stateMutability: \"view\",\n        constant: true,\n        payable: false,\n        inputs: [\n            {\n                name: \"addr\",\n                type: \"address\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"balance\",\n                type: \"uint256\"\n            }\n        ]\n    }\n];\nconst emptyBatch = () => ({ calls: [], callbacks: [] });\n// TODO\n//\n// Technically, requests that have a `from` address shouldn't be batched, because `msg.sender` will\n// be replaced with the Multicall contract's address when the batched calls are being executed.\n//\n// Currently, `@liquity/lib-ethers` makes many of its read calls through Signers, which populates\n// `from`. Instead these calls should be made through a Provider, and `from` should be omitted\n// (since none of the read calls in Liquity care about `msg.sender`).\n//\n// Then we'll be able to properly exclude calls that have `from` addresses from batching.\nconst batchableCall = (request) => request.gasLimit === undefined && request.gasPrice === undefined && request.value === undefined;\nconst batchedCall = (request, multicallAddress) => request.to === multicallAddress &&\n    typeof request.data === \"string\" &&\n    request.data.startsWith(\"0x252dba42\"); // signature of `aggregate((address,bytes)[])`\nconst batchedProviders = [];\nconst isBatchedProvider = (provider) => batchedProviders.some(batchedProvider => provider instanceof batchedProvider);\nexports.isBatchedProvider = isBatchedProvider;\nconst Batched = (Base) => {\n    const batchedProvider = class extends Base {\n        constructor() {\n            super(...arguments);\n            this.batchingDelayMs = 10;\n            this._chainId = 0;\n            this._batched = emptyBatch();\n            this._numberOfBatchedCalls = 0;\n            this._numberOfActualCalls = 0;\n        }\n        get chainId() {\n            return this._chainId;\n        }\n        set chainId(chainId) {\n            if (this._multicall) {\n                throw new Error(\"can only set chainId once\");\n            }\n            if (hasMulticall(chainId)) {\n                this._multicall = new contracts_1.Contract(multicallAddress[chainId], multicallAbi, this);\n            }\n            this._chainId = chainId;\n        }\n        async _dispatchCalls() {\n            const { calls, callbacks, blockTag } = this._batched;\n            this._batched = emptyBatch();\n            try {\n                const results = calls.length > 1\n                    ? await this._multicall.callStatic.aggregate(calls, { blockTag }).then(x => x.returnData)\n                    : [await super.call({ to: calls[0].target, data: calls[0].callData }, blockTag)];\n                callbacks.forEach(([resolve], i) => resolve(results[i]));\n            }\n            catch (error) {\n                callbacks.forEach(([, reject]) => reject(error));\n            }\n        }\n        _enqueueCall(call) {\n            if (this._timeoutId !== undefined) {\n                clearTimeout(this._timeoutId);\n            }\n            this._batched.calls.push(call);\n            this._timeoutId = setTimeout(() => this._dispatchCalls(), this.batchingDelayMs);\n            return new Promise((resolve, reject) => this._batched.callbacks.push([resolve, reject]));\n        }\n        _alreadyBatchedCallsConflictWith(blockTag) {\n            var _a;\n            return (this._batched.calls.length !== 0 &&\n                (blockTag !== null && blockTag !== void 0 ? blockTag : \"latest\") !== ((_a = this._batched.blockTag) !== null && _a !== void 0 ? _a : \"latest\"));\n        }\n        async call(request, blockTag) {\n            if (!this._multicall) {\n                return super.call(request, blockTag);\n            }\n            else {\n                const now = new Date().getTime();\n                if (this._timeOfLastRatioCheck === undefined) {\n                    this._timeOfLastRatioCheck = now;\n                }\n                else {\n                    const timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;\n                    if (timeSinceLastRatioCheck >= 10000 && this._numberOfActualCalls) {\n                        // console.log(\n                        //   `Call batching ratio: ${\n                        //     Math.round((10 * this._numberOfBatchedCalls) / this._numberOfActualCalls) / 10\n                        //   }X`\n                        // );\n                        this._numberOfBatchedCalls = 0;\n                        this._numberOfActualCalls = 0;\n                        this._timeOfLastRatioCheck = now;\n                    }\n                }\n            }\n            const [resolvedRequest, resolvedBlockTag] = await Promise.all([\n                properties_1.resolveProperties(request),\n                blockTag\n            ]);\n            if (batchedCall(resolvedRequest, this._multicall.address) ||\n                !batchableCall(resolvedRequest) ||\n                this._alreadyBatchedCallsConflictWith(resolvedBlockTag)) {\n                this._numberOfActualCalls++;\n                return super.call(resolvedRequest, resolvedBlockTag);\n            }\n            else {\n                this._numberOfBatchedCalls++;\n                if (this._batched.calls.length === 0) {\n                    this._batched.blockTag = resolvedBlockTag;\n                }\n                return this._enqueueCall({ target: resolvedRequest.to, callData: resolvedRequest.data });\n            }\n        }\n        async getBalance(addressOrName, blockTag) {\n            const [resolvedAddressOrName, resolvedBlockTag] = await Promise.all([addressOrName, blockTag]);\n            if (!address_1.isAddress(resolvedAddressOrName) || !this._multicall) {\n                return super.getBalance(resolvedAddressOrName, blockTag);\n            }\n            const [balance] = await this._multicall.functions.getEthBalance(resolvedAddressOrName, {\n                blockTag: resolvedBlockTag\n            });\n            return balance;\n        }\n    };\n    batchedProviders.push(batchedProvider);\n    return batchedProvider;\n};\nexports.Batched = Batched;\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched(WebSocketAugmentedProvider_1.WebSocketAugmentedWeb3Provider);\n//# sourceMappingURL=BatchedProvider.js.map"]},"metadata":{},"sourceType":"script"}