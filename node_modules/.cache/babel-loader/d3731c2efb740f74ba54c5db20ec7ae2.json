{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PopulatableEthersLiquity = exports.PopulatedEthersRedemption = exports.PopulatedEthersLiquityTransaction = exports.SentEthersLiquityTransaction = exports._redeemMaxIterations = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst constants_1 = require(\"@ethersproject/constants\");\n\nconst lib_base_1 = require(\"@liquity/lib-base\");\n\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nconst contracts_1 = require(\"./contracts\");\n\nconst parseLogs_1 = require(\"./parseLogs\");\n\nconst decimalify = bigNumber => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString()); // With 70 iterations redemption costs about ~10M gas, and each iteration accounts for ~138k more\n\n/** @internal */\n\n\nexports._redeemMaxIterations = 70;\nconst defaultBorrowingRateSlippageTolerance = lib_base_1.Decimal.from(0.005); // 0.5%\n\nconst defaultRedemptionRateSlippageTolerance = lib_base_1.Decimal.from(0.001); // 0.1%\n\nconst noDetails = () => undefined;\n\nconst compose = (f, g) => _ => f(g(_));\n\nconst id = t => t; // Takes ~6-7K to update lastFeeOperationTime. Let's be on the safe side.\n\n\nconst addGasForPotentialLastFeeOperationTimeUpdate = gas => gas.add(10000); // First traversal in ascending direction takes ~50K, then ~13.5K per extra step.\n// 80K should be enough for 3 steps, plus some extra to be safe.\n\n\nconst addGasForPotentialListTraversal = gas => gas.add(80000);\n\nconst addGasForLQTYIssuance = gas => gas.add(50000);\n\nconst addGasForUnipoolRewardUpdate = gas => gas.add(20000); // To get the best entropy available, we'd do something like:\n//\n// const bigRandomNumber = () =>\n//   BigNumber.from(\n//     `0x${Array.from(crypto.getRandomValues(new Uint32Array(8)))\n//       .map(u32 => u32.toString(16).padStart(8, \"0\"))\n//       .join(\"\")}`\n//   );\n//\n// However, Window.crypto is browser-specific. Since we only use this for randomly picking Troves\n// during the search for hints, Math.random() will do fine, too.\n//\n// This returns a random integer between 0 and Number.MAX_SAFE_INTEGER\n\n\nconst randomInteger = () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER); // Maximum number of trials to perform in a single getApproxHint() call. If the number of trials\n// required to get a statistically \"good\" hint is larger than this, the search for the hint will\n// be broken up into multiple getApproxHint() calls.\n//\n// This should be low enough to work with popular public Ethereum providers like Infura without\n// triggering any fair use limits.\n\n\nconst maxNumberOfTrialsAtOnce = 2500;\n\nfunction* generateTrials(totalNumberOfTrials) {\n  assert_1.default(Number.isInteger(totalNumberOfTrials) && totalNumberOfTrials > 0);\n\n  while (totalNumberOfTrials) {\n    const numberOfTrials = Math.min(totalNumberOfTrials, maxNumberOfTrialsAtOnce);\n    yield numberOfTrials;\n    totalNumberOfTrials -= numberOfTrials;\n  }\n}\n/**\n * A transaction that has already been sent.\n *\n * @remarks\n * Returned by {@link SendableEthersLiquity} functions.\n *\n * @public\n */\n\n\nclass SentEthersLiquityTransaction {\n  /** @internal */\n  constructor(rawSentTransaction, connection, parse) {\n    this.rawSentTransaction = rawSentTransaction;\n    this._connection = connection;\n    this._parse = parse;\n  }\n\n  _receiptFrom(rawReceipt) {\n    return rawReceipt ? rawReceipt.status ? lib_base_1._successfulReceipt(rawReceipt, this._parse(rawReceipt), () => parseLogs_1.logsToString(rawReceipt, EthersLiquityConnection_1._getContracts(this._connection))) : lib_base_1._failedReceipt(rawReceipt) : lib_base_1._pendingReceipt;\n  }\n  /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.getReceipt} */\n\n\n  async getReceipt() {\n    return this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).getTransactionReceipt(this.rawSentTransaction.hash));\n  }\n  /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.waitForReceipt} */\n\n\n  async waitForReceipt() {\n    const receipt = this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).waitForTransaction(this.rawSentTransaction.hash));\n\n    assert_1.default(receipt.status !== \"pending\");\n    return receipt;\n  }\n\n}\n\nexports.SentEthersLiquityTransaction = SentEthersLiquityTransaction;\n/**\n * A transaction that has been prepared for sending.\n *\n * @remarks\n * Returned by {@link PopulatableEthersLiquity} functions.\n *\n * @public\n */\n\nclass PopulatedEthersLiquityTransaction {\n  /** @internal */\n  constructor(rawPopulatedTransaction, connection, parse) {\n    this.rawPopulatedTransaction = rawPopulatedTransaction;\n    this._connection = connection;\n    this._parse = parse;\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatedLiquityTransaction.send} */\n\n\n  async send() {\n    return new SentEthersLiquityTransaction(await EthersLiquityConnection_1._requireSigner(this._connection).sendTransaction(this.rawPopulatedTransaction), this._connection, this._parse);\n  }\n\n}\n\nexports.PopulatedEthersLiquityTransaction = PopulatedEthersLiquityTransaction;\n/**\n * {@inheritDoc @liquity/lib-base#PopulatedRedemption}\n *\n * @public\n */\n\nclass PopulatedEthersRedemption extends PopulatedEthersLiquityTransaction {\n  /** @internal */\n  constructor(rawPopulatedTransaction, connection, attemptedLUSDAmount, redeemableLUSDAmount, increaseAmountByMinimumNetDebt) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(connection);\n\n    super(rawPopulatedTransaction, connection, ({\n      logs\n    }) => troveManager.extractEvents(logs, \"Redemption\").map(({\n      args: {\n        _ETHSent,\n        _ETHFee,\n        _actualLUSDAmount,\n        _attemptedLUSDAmount\n      }\n    }) => ({\n      attemptedLUSDAmount: decimalify(_attemptedLUSDAmount),\n      actualLUSDAmount: decimalify(_actualLUSDAmount),\n      collateralTaken: decimalify(_ETHSent),\n      fee: decimalify(_ETHFee)\n    }))[0]);\n    this.attemptedLUSDAmount = attemptedLUSDAmount;\n    this.redeemableLUSDAmount = redeemableLUSDAmount;\n    this.isTruncated = redeemableLUSDAmount.lt(attemptedLUSDAmount);\n    this._increaseAmountByMinimumNetDebt = increaseAmountByMinimumNetDebt;\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatedRedemption.increaseAmountByMinimumNetDebt} */\n\n\n  increaseAmountByMinimumNetDebt(maxRedemptionRate) {\n    if (!this._increaseAmountByMinimumNetDebt) {\n      throw new Error(\"PopulatedEthersRedemption: increaseAmountByMinimumNetDebt() can \" + \"only be called when amount is truncated\");\n    }\n\n    return this._increaseAmountByMinimumNetDebt(maxRedemptionRate);\n  }\n\n}\n\nexports.PopulatedEthersRedemption = PopulatedEthersRedemption;\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#PopulatableLiquity}.\n *\n * @public\n */\n\nclass PopulatableEthersLiquity {\n  constructor(readable) {\n    this._readable = readable;\n  }\n\n  _wrapSimpleTransaction(rawPopulatedTransaction) {\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, noDetails);\n  }\n\n  _wrapTroveChangeWithFees(params, rawPopulatedTransaction) {\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs\n    }) => {\n      const [newTrove] = borrowerOperations.extractEvents(logs, \"TroveUpdated\").map(({\n        args: {\n          _coll,\n          _debt\n        }\n      }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n      const [fee] = borrowerOperations.extractEvents(logs, \"LUSDBorrowingFeePaid\").map(({\n        args: {\n          _LUSDFee\n        }\n      }) => decimalify(_LUSDFee));\n      return {\n        params,\n        newTrove,\n        fee\n      };\n    });\n  }\n\n  async _wrapTroveClosure(rawPopulatedTransaction) {\n    const {\n      activePool,\n      lusdToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs,\n      from: userAddress\n    }) => {\n      const [repayLUSD] = lusdToken.extractEvents(logs, \"Transfer\").filter(({\n        args: {\n          from,\n          to\n        }\n      }) => from === userAddress && to === constants_1.AddressZero).map(({\n        args: {\n          value\n        }\n      }) => decimalify(value));\n      const [withdrawCollateral] = activePool.extractEvents(logs, \"EtherSent\").filter(({\n        args: {\n          _to\n        }\n      }) => _to === userAddress).map(({\n        args: {\n          _amount\n        }\n      }) => decimalify(_amount));\n      return {\n        params: repayLUSD.nonZero ? {\n          withdrawCollateral,\n          repayLUSD\n        } : {\n          withdrawCollateral\n        }\n      };\n    });\n  }\n\n  _wrapLiquidation(rawPopulatedTransaction) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs\n    }) => {\n      const liquidatedAddresses = troveManager.extractEvents(logs, \"TroveLiquidated\").map(({\n        args: {\n          _borrower\n        }\n      }) => _borrower);\n      const [totals] = troveManager.extractEvents(logs, \"Liquidation\").map(({\n        args: {\n          _LUSDGasCompensation,\n          _collGasCompensation,\n          _liquidatedColl,\n          _liquidatedDebt\n        }\n      }) => ({\n        collateralGasCompensation: decimalify(_collGasCompensation),\n        lusdGasCompensation: decimalify(_LUSDGasCompensation),\n        totalLiquidated: new lib_base_1.Trove(decimalify(_liquidatedColl), decimalify(_liquidatedDebt))\n      }));\n      return {\n        liquidatedAddresses,\n        ...totals\n      };\n    });\n  }\n\n  _extractStabilityPoolGainsWithdrawalDetails(logs) {\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const [newLUSDDeposit] = stabilityPool.extractEvents(logs, \"UserDepositChanged\").map(({\n      args: {\n        _newDeposit\n      }\n    }) => decimalify(_newDeposit));\n    const [[collateralGain, lusdLoss]] = stabilityPool.extractEvents(logs, \"ETHGainWithdrawn\").map(({\n      args: {\n        _ETH,\n        _LUSDLoss\n      }\n    }) => [decimalify(_ETH), decimalify(_LUSDLoss)]);\n    const [lqtyReward] = stabilityPool.extractEvents(logs, \"LQTYPaidToDepositor\").map(({\n      args: {\n        _LQTY\n      }\n    }) => decimalify(_LQTY));\n    return {\n      lusdLoss,\n      newLUSDDeposit,\n      collateralGain,\n      lqtyReward\n    };\n  }\n\n  _wrapStabilityPoolGainsWithdrawal(rawPopulatedTransaction) {\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs\n    }) => this._extractStabilityPoolGainsWithdrawalDetails(logs));\n  }\n\n  _wrapStabilityDepositTopup(change, rawPopulatedTransaction) {\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs\n    }) => ({ ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n      change\n    }));\n  }\n\n  async _wrapStabilityDepositWithdrawal(rawPopulatedTransaction) {\n    const {\n      stabilityPool,\n      lusdToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs,\n      from: userAddress\n    }) => {\n      const gainsWithdrawalDetails = this._extractStabilityPoolGainsWithdrawalDetails(logs);\n\n      const [withdrawLUSD] = lusdToken.extractEvents(logs, \"Transfer\").filter(({\n        args: {\n          from,\n          to\n        }\n      }) => from === stabilityPool.address && to === userAddress).map(({\n        args: {\n          value\n        }\n      }) => decimalify(value));\n      return { ...gainsWithdrawalDetails,\n        change: {\n          withdrawLUSD,\n          withdrawAllLUSD: gainsWithdrawalDetails.newLUSDDeposit.isZero\n        }\n      };\n    });\n  }\n\n  _wrapCollateralGainTransfer(rawPopulatedTransaction) {\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({\n      logs\n    }) => {\n      const [newTrove] = borrowerOperations.extractEvents(logs, \"TroveUpdated\").map(({\n        args: {\n          _coll,\n          _debt\n        }\n      }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n      return { ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n        newTrove\n      };\n    });\n  }\n\n  async _findHintsForNominalCollateralRatio(nominalCollateralRatio) {\n    const {\n      sortedTroves,\n      hintHelpers\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const numberOfTroves = await this._readable.getNumberOfTroves();\n\n    if (!numberOfTroves) {\n      return [constants_1.AddressZero, constants_1.AddressZero];\n    }\n\n    if (nominalCollateralRatio.infinite) {\n      return [constants_1.AddressZero, await sortedTroves.getFirst()];\n    }\n\n    const totalNumberOfTrials = Math.ceil(10 * Math.sqrt(numberOfTroves));\n    const [firstTrials, ...restOfTrials] = generateTrials(totalNumberOfTrials);\n\n    const collectApproxHint = ({\n      latestRandomSeed,\n      results\n    }, numberOfTrials) => hintHelpers.getApproxHint(nominalCollateralRatio.hex, numberOfTrials, latestRandomSeed).then(({\n      latestRandomSeed,\n      ...result\n    }) => ({\n      latestRandomSeed,\n      results: [...results, result]\n    }));\n\n    const {\n      results\n    } = await restOfTrials.reduce((p, numberOfTrials) => p.then(state => collectApproxHint(state, numberOfTrials)), collectApproxHint({\n      latestRandomSeed: randomInteger(),\n      results: []\n    }, firstTrials));\n    const {\n      hintAddress\n    } = results.reduce((a, b) => a.diff.lt(b.diff) ? a : b);\n    return sortedTroves.findInsertPosition(nominalCollateralRatio.hex, hintAddress, hintAddress);\n  }\n\n  async _findHints(trove) {\n    if (trove instanceof lib_base_1.TroveWithPendingRedistribution) {\n      throw new Error(\"Rewards must be applied to this Trove\");\n    }\n\n    return this._findHintsForNominalCollateralRatio(trove._nominalCollateralRatio);\n  }\n\n  async _findRedemptionHints(amount) {\n    const {\n      hintHelpers\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const price = await this._readable.getPrice();\n    const {\n      firstRedemptionHint,\n      partialRedemptionHintNICR,\n      truncatedLUSDamount\n    } = await hintHelpers.getRedemptionHints(amount.hex, price.hex, exports._redeemMaxIterations);\n    const [partialRedemptionUpperHint, partialRedemptionLowerHint] = partialRedemptionHintNICR.isZero() ? [constants_1.AddressZero, constants_1.AddressZero] : await this._findHintsForNominalCollateralRatio(decimalify(partialRedemptionHintNICR));\n    return [decimalify(truncatedLUSDamount), firstRedemptionHint, partialRedemptionUpperHint, partialRedemptionLowerHint, partialRedemptionHintNICR];\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.openTrove} */\n\n\n  async openTrove(params, maxBorrowingRate, overrides) {\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const normalized = lib_base_1._normalizeTroveCreation(params);\n\n    const {\n      depositCollateral,\n      borrowLUSD\n    } = normalized;\n    const fees = await this._readable.getFees();\n    const borrowingRate = fees.borrowingRate();\n    const newTrove = lib_base_1.Trove.create(normalized, borrowingRate);\n    maxBorrowingRate = maxBorrowingRate !== undefined ? lib_base_1.Decimal.from(maxBorrowingRate) : borrowingRate.add(defaultBorrowingRateSlippageTolerance);\n    return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.openTrove({\n      value: depositCollateral.hex,\n      ...overrides\n    }, compose(addGasForPotentialLastFeeOperationTimeUpdate, addGasForPotentialListTraversal), maxBorrowingRate.hex, borrowLUSD.hex, ...(await this._findHints(newTrove))));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.closeTrove} */\n\n\n  async closeTrove(overrides) {\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapTroveClosure(await borrowerOperations.estimateAndPopulate.closeTrove({ ...overrides\n    }, id));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositCollateral} */\n\n\n  depositCollateral(amount, overrides) {\n    return this.adjustTrove({\n      depositCollateral: amount\n    }, undefined, overrides);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawCollateral} */\n\n\n  withdrawCollateral(amount, overrides) {\n    return this.adjustTrove({\n      withdrawCollateral: amount\n    }, undefined, overrides);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.borrowLUSD} */\n\n\n  borrowLUSD(amount, maxBorrowingRate, overrides) {\n    return this.adjustTrove({\n      borrowLUSD: amount\n    }, maxBorrowingRate, overrides);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.repayLUSD} */\n\n\n  repayLUSD(amount, overrides) {\n    return this.adjustTrove({\n      repayLUSD: amount\n    }, undefined, overrides);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.adjustTrove} */\n\n\n  async adjustTrove(params, maxBorrowingRate, overrides) {\n    var _a, _b;\n\n    const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const normalized = lib_base_1._normalizeTroveAdjustment(params);\n\n    const {\n      depositCollateral,\n      withdrawCollateral,\n      borrowLUSD,\n      repayLUSD\n    } = normalized;\n    const [trove, fees] = await Promise.all([this._readable.getTrove(address), borrowLUSD && this._readable.getFees()]);\n    const borrowingRate = fees === null || fees === void 0 ? void 0 : fees.borrowingRate();\n    const finalTrove = trove.adjust(normalized, borrowingRate);\n    maxBorrowingRate = maxBorrowingRate !== undefined ? lib_base_1.Decimal.from(maxBorrowingRate) : (_a = borrowingRate === null || borrowingRate === void 0 ? void 0 : borrowingRate.add(defaultBorrowingRateSlippageTolerance)) !== null && _a !== void 0 ? _a : lib_base_1.Decimal.ZERO;\n    return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.adjustTrove({\n      value: depositCollateral === null || depositCollateral === void 0 ? void 0 : depositCollateral.hex,\n      ...overrides\n    }, compose(borrowLUSD ? addGasForPotentialLastFeeOperationTimeUpdate : id, addGasForPotentialListTraversal), maxBorrowingRate.hex, (withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : lib_base_1.Decimal.ZERO).hex, ((_b = borrowLUSD !== null && borrowLUSD !== void 0 ? borrowLUSD : repayLUSD) !== null && _b !== void 0 ? _b : lib_base_1.Decimal.ZERO).hex, !!borrowLUSD, ...(await this._findHints(finalTrove))));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.claimCollateralSurplus} */\n\n\n  async claimCollateralSurplus(overrides) {\n    const {\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await borrowerOperations.estimateAndPopulate.claimCollateral({ ...overrides\n    }, id));\n  }\n  /** @internal */\n\n\n  async setPrice(price, overrides) {\n    const {\n      priceFeed\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    if (!contracts_1._priceFeedIsTestnet(priceFeed)) {\n      throw new Error(\"setPrice() unavailable on this deployment of Liquity\");\n    }\n\n    return this._wrapSimpleTransaction(await priceFeed.estimateAndPopulate.setPrice({ ...overrides\n    }, id, lib_base_1.Decimal.from(price).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidate} */\n\n\n  async liquidate(address, overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    if (Array.isArray(address)) {\n      return this._wrapLiquidation(await troveManager.estimateAndPopulate.batchLiquidateTroves({ ...overrides\n      }, addGasForLQTYIssuance, address));\n    } else {\n      return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidate({ ...overrides\n      }, addGasForLQTYIssuance, address));\n    }\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidateUpTo} */\n\n\n  async liquidateUpTo(maximumNumberOfTrovesToLiquidate, overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidateTroves({ ...overrides\n    }, addGasForLQTYIssuance, maximumNumberOfTrovesToLiquidate));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositLUSDInStabilityPool} */\n\n\n  async depositLUSDInStabilityPool(amount, frontendTag, overrides) {\n    var _a;\n\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const depositLUSD = lib_base_1.Decimal.from(amount);\n    return this._wrapStabilityDepositTopup({\n      depositLUSD\n    }, await stabilityPool.estimateAndPopulate.provideToSP({ ...overrides\n    }, addGasForLQTYIssuance, depositLUSD.hex, (_a = frontendTag !== null && frontendTag !== void 0 ? frontendTag : this._readable.connection.frontendTag) !== null && _a !== void 0 ? _a : constants_1.AddressZero));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLUSDFromStabilityPool} */\n\n\n  async withdrawLUSDFromStabilityPool(amount, overrides) {\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapStabilityDepositWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides\n    }, addGasForLQTYIssuance, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStabilityPool} */\n\n\n  async withdrawGainsFromStabilityPool(overrides) {\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapStabilityPoolGainsWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides\n    }, addGasForLQTYIssuance, lib_base_1.Decimal.ZERO.hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.transferCollateralGainToTrove} */\n\n\n  async transferCollateralGainToTrove(overrides) {\n    const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const [initialTrove, stabilityDeposit] = await Promise.all([this._readable.getTrove(address), this._readable.getStabilityDeposit(address)]);\n    const finalTrove = initialTrove.addCollateral(stabilityDeposit.collateralGain);\n    return this._wrapCollateralGainTransfer(await stabilityPool.estimateAndPopulate.withdrawETHGainToTrove({ ...overrides\n    }, compose(addGasForPotentialListTraversal, addGasForLQTYIssuance), ...(await this._findHints(finalTrove))));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLUSD} */\n\n\n  async sendLUSD(toAddress, amount, overrides) {\n    const {\n      lusdToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await lusdToken.estimateAndPopulate.transfer({ ...overrides\n    }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLQTY} */\n\n\n  async sendLQTY(toAddress, amount, overrides) {\n    const {\n      lqtyToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await lqtyToken.estimateAndPopulate.transfer({ ...overrides\n    }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.redeemLUSD} */\n\n\n  async redeemLUSD(amount, maxRedemptionRate, overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const attemptedLUSDAmount = lib_base_1.Decimal.from(amount);\n    const [fees, total, [truncatedAmount, firstRedemptionHint, ...partialHints]] = await Promise.all([this._readable.getFees(), this._readable.getTotal(), this._findRedemptionHints(attemptedLUSDAmount)]);\n\n    if (truncatedAmount.isZero) {\n      throw new Error(`redeemLUSD: amount too low to redeem (try at least ${lib_base_1.LUSD_MINIMUM_NET_DEBT})`);\n    }\n\n    const defaultMaxRedemptionRate = amount => lib_base_1.Decimal.min(fees.redemptionRate(amount.div(total.debt)).add(defaultRedemptionRateSlippageTolerance), lib_base_1.Decimal.ONE);\n\n    const populateRedemption = async (attemptedLUSDAmount, maxRedemptionRate, truncatedAmount = attemptedLUSDAmount, partialHints = [constants_1.AddressZero, constants_1.AddressZero, 0]) => {\n      const maxRedemptionRateOrDefault = maxRedemptionRate !== undefined ? lib_base_1.Decimal.from(maxRedemptionRate) : defaultMaxRedemptionRate(truncatedAmount);\n      return new PopulatedEthersRedemption(await troveManager.estimateAndPopulate.redeemCollateral({ ...overrides\n      }, addGasForPotentialLastFeeOperationTimeUpdate, truncatedAmount.hex, firstRedemptionHint, ...partialHints, exports._redeemMaxIterations, maxRedemptionRateOrDefault.hex), this._readable.connection, attemptedLUSDAmount, truncatedAmount, truncatedAmount.lt(attemptedLUSDAmount) ? newMaxRedemptionRate => populateRedemption(truncatedAmount.add(lib_base_1.LUSD_MINIMUM_NET_DEBT), newMaxRedemptionRate !== null && newMaxRedemptionRate !== void 0 ? newMaxRedemptionRate : maxRedemptionRate) : undefined);\n    };\n\n    return populateRedemption(attemptedLUSDAmount, maxRedemptionRate, truncatedAmount, partialHints);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeLQTY} */\n\n\n  async stakeLQTY(amount, overrides) {\n    const {\n      lqtyStaking\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.stake({ ...overrides\n    }, id, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeLQTY} */\n\n\n  async unstakeLQTY(amount, overrides) {\n    const {\n      lqtyStaking\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.unstake({ ...overrides\n    }, id, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStaking} */\n\n\n  withdrawGainsFromStaking(overrides) {\n    return this.unstakeLQTY(lib_base_1.Decimal.ZERO, overrides);\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.registerFrontend} */\n\n\n  async registerFrontend(kickbackRate, overrides) {\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await stabilityPool.estimateAndPopulate.registerFrontEnd({ ...overrides\n    }, id, lib_base_1.Decimal.from(kickbackRate).hex));\n  }\n  /** @internal */\n\n\n  async _mintUniToken(amount, address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n\n    const {\n      uniToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    if (!contracts_1._uniTokenIsMock(uniToken)) {\n      throw new Error(\"_mintUniToken() unavailable on this deployment of Liquity\");\n    }\n\n    return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.mint({ ...overrides\n    }, id, address, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.approveUniTokens} */\n\n\n  async approveUniTokens(allowance, overrides) {\n    const {\n      uniToken,\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.approve({ ...overrides\n    }, id, unipool.address, lib_base_1.Decimal.from(allowance !== null && allowance !== void 0 ? allowance : lib_base_1.Decimal.INFINITY).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeUniTokens} */\n\n\n  async stakeUniTokens(amount, overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.stake({ ...overrides\n    }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeUniTokens} */\n\n\n  async unstakeUniTokens(amount, overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdraw({ ...overrides\n    }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLQTYRewardFromLiquidityMining} */\n\n\n  async withdrawLQTYRewardFromLiquidityMining(overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.claimReward({ ...overrides\n    }, addGasForUnipoolRewardUpdate));\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.exitLiquidityMining} */\n\n\n  async exitLiquidityMining(overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdrawAndClaim({ ...overrides\n    }, addGasForUnipoolRewardUpdate));\n  }\n\n}\n\nexports.PopulatableEthersLiquity = PopulatableEthersLiquity;","map":{"version":3,"sources":["../../src/PopulatableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopulatableEthersLiquity = exports.PopulatedEthersRedemption = exports.PopulatedEthersLiquityTransaction = exports.SentEthersLiquityTransaction = exports._redeemMaxIterations = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst constants_1 = require(\"@ethersproject/constants\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst contracts_1 = require(\"./contracts\");\nconst parseLogs_1 = require(\"./parseLogs\");\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n// With 70 iterations redemption costs about ~10M gas, and each iteration accounts for ~138k more\n/** @internal */\nexports._redeemMaxIterations = 70;\nconst defaultBorrowingRateSlippageTolerance = lib_base_1.Decimal.from(0.005); // 0.5%\nconst defaultRedemptionRateSlippageTolerance = lib_base_1.Decimal.from(0.001); // 0.1%\nconst noDetails = () => undefined;\nconst compose = (f, g) => (_) => f(g(_));\nconst id = (t) => t;\n// Takes ~6-7K to update lastFeeOperationTime. Let's be on the safe side.\nconst addGasForPotentialLastFeeOperationTimeUpdate = (gas) => gas.add(10000);\n// First traversal in ascending direction takes ~50K, then ~13.5K per extra step.\n// 80K should be enough for 3 steps, plus some extra to be safe.\nconst addGasForPotentialListTraversal = (gas) => gas.add(80000);\nconst addGasForLQTYIssuance = (gas) => gas.add(50000);\nconst addGasForUnipoolRewardUpdate = (gas) => gas.add(20000);\n// To get the best entropy available, we'd do something like:\n//\n// const bigRandomNumber = () =>\n//   BigNumber.from(\n//     `0x${Array.from(crypto.getRandomValues(new Uint32Array(8)))\n//       .map(u32 => u32.toString(16).padStart(8, \"0\"))\n//       .join(\"\")}`\n//   );\n//\n// However, Window.crypto is browser-specific. Since we only use this for randomly picking Troves\n// during the search for hints, Math.random() will do fine, too.\n//\n// This returns a random integer between 0 and Number.MAX_SAFE_INTEGER\nconst randomInteger = () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n// Maximum number of trials to perform in a single getApproxHint() call. If the number of trials\n// required to get a statistically \"good\" hint is larger than this, the search for the hint will\n// be broken up into multiple getApproxHint() calls.\n//\n// This should be low enough to work with popular public Ethereum providers like Infura without\n// triggering any fair use limits.\nconst maxNumberOfTrialsAtOnce = 2500;\nfunction* generateTrials(totalNumberOfTrials) {\n    assert_1.default(Number.isInteger(totalNumberOfTrials) && totalNumberOfTrials > 0);\n    while (totalNumberOfTrials) {\n        const numberOfTrials = Math.min(totalNumberOfTrials, maxNumberOfTrialsAtOnce);\n        yield numberOfTrials;\n        totalNumberOfTrials -= numberOfTrials;\n    }\n}\n/**\n * A transaction that has already been sent.\n *\n * @remarks\n * Returned by {@link SendableEthersLiquity} functions.\n *\n * @public\n */\nclass SentEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawSentTransaction, connection, parse) {\n        this.rawSentTransaction = rawSentTransaction;\n        this._connection = connection;\n        this._parse = parse;\n    }\n    _receiptFrom(rawReceipt) {\n        return rawReceipt\n            ? rawReceipt.status\n                ? lib_base_1._successfulReceipt(rawReceipt, this._parse(rawReceipt), () => parseLogs_1.logsToString(rawReceipt, EthersLiquityConnection_1._getContracts(this._connection)))\n                : lib_base_1._failedReceipt(rawReceipt)\n            : lib_base_1._pendingReceipt;\n    }\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.getReceipt} */\n    async getReceipt() {\n        return this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).getTransactionReceipt(this.rawSentTransaction.hash));\n    }\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.waitForReceipt} */\n    async waitForReceipt() {\n        const receipt = this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).waitForTransaction(this.rawSentTransaction.hash));\n        assert_1.default(receipt.status !== \"pending\");\n        return receipt;\n    }\n}\nexports.SentEthersLiquityTransaction = SentEthersLiquityTransaction;\n/**\n * A transaction that has been prepared for sending.\n *\n * @remarks\n * Returned by {@link PopulatableEthersLiquity} functions.\n *\n * @public\n */\nclass PopulatedEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawPopulatedTransaction, connection, parse) {\n        this.rawPopulatedTransaction = rawPopulatedTransaction;\n        this._connection = connection;\n        this._parse = parse;\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatedLiquityTransaction.send} */\n    async send() {\n        return new SentEthersLiquityTransaction(await EthersLiquityConnection_1._requireSigner(this._connection).sendTransaction(this.rawPopulatedTransaction), this._connection, this._parse);\n    }\n}\nexports.PopulatedEthersLiquityTransaction = PopulatedEthersLiquityTransaction;\n/**\n * {@inheritDoc @liquity/lib-base#PopulatedRedemption}\n *\n * @public\n */\nclass PopulatedEthersRedemption extends PopulatedEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawPopulatedTransaction, connection, attemptedLUSDAmount, redeemableLUSDAmount, increaseAmountByMinimumNetDebt) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(connection);\n        super(rawPopulatedTransaction, connection, ({ logs }) => troveManager\n            .extractEvents(logs, \"Redemption\")\n            .map(({ args: { _ETHSent, _ETHFee, _actualLUSDAmount, _attemptedLUSDAmount } }) => ({\n            attemptedLUSDAmount: decimalify(_attemptedLUSDAmount),\n            actualLUSDAmount: decimalify(_actualLUSDAmount),\n            collateralTaken: decimalify(_ETHSent),\n            fee: decimalify(_ETHFee)\n        }))[0]);\n        this.attemptedLUSDAmount = attemptedLUSDAmount;\n        this.redeemableLUSDAmount = redeemableLUSDAmount;\n        this.isTruncated = redeemableLUSDAmount.lt(attemptedLUSDAmount);\n        this._increaseAmountByMinimumNetDebt = increaseAmountByMinimumNetDebt;\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatedRedemption.increaseAmountByMinimumNetDebt} */\n    increaseAmountByMinimumNetDebt(maxRedemptionRate) {\n        if (!this._increaseAmountByMinimumNetDebt) {\n            throw new Error(\"PopulatedEthersRedemption: increaseAmountByMinimumNetDebt() can \" +\n                \"only be called when amount is truncated\");\n        }\n        return this._increaseAmountByMinimumNetDebt(maxRedemptionRate);\n    }\n}\nexports.PopulatedEthersRedemption = PopulatedEthersRedemption;\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#PopulatableLiquity}.\n *\n * @public\n */\nclass PopulatableEthersLiquity {\n    constructor(readable) {\n        this._readable = readable;\n    }\n    _wrapSimpleTransaction(rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, noDetails);\n    }\n    _wrapTroveChangeWithFees(params, rawPopulatedTransaction) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const [newTrove] = borrowerOperations\n                .extractEvents(logs, \"TroveUpdated\")\n                .map(({ args: { _coll, _debt } }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n            const [fee] = borrowerOperations\n                .extractEvents(logs, \"LUSDBorrowingFeePaid\")\n                .map(({ args: { _LUSDFee } }) => decimalify(_LUSDFee));\n            return {\n                params,\n                newTrove,\n                fee\n            };\n        });\n    }\n    async _wrapTroveClosure(rawPopulatedTransaction) {\n        const { activePool, lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs, from: userAddress }) => {\n            const [repayLUSD] = lusdToken\n                .extractEvents(logs, \"Transfer\")\n                .filter(({ args: { from, to } }) => from === userAddress && to === constants_1.AddressZero)\n                .map(({ args: { value } }) => decimalify(value));\n            const [withdrawCollateral] = activePool\n                .extractEvents(logs, \"EtherSent\")\n                .filter(({ args: { _to } }) => _to === userAddress)\n                .map(({ args: { _amount } }) => decimalify(_amount));\n            return {\n                params: repayLUSD.nonZero ? { withdrawCollateral, repayLUSD } : { withdrawCollateral }\n            };\n        });\n    }\n    _wrapLiquidation(rawPopulatedTransaction) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const liquidatedAddresses = troveManager\n                .extractEvents(logs, \"TroveLiquidated\")\n                .map(({ args: { _borrower } }) => _borrower);\n            const [totals] = troveManager\n                .extractEvents(logs, \"Liquidation\")\n                .map(({ args: { _LUSDGasCompensation, _collGasCompensation, _liquidatedColl, _liquidatedDebt } }) => ({\n                collateralGasCompensation: decimalify(_collGasCompensation),\n                lusdGasCompensation: decimalify(_LUSDGasCompensation),\n                totalLiquidated: new lib_base_1.Trove(decimalify(_liquidatedColl), decimalify(_liquidatedDebt))\n            }));\n            return {\n                liquidatedAddresses,\n                ...totals\n            };\n        });\n    }\n    _extractStabilityPoolGainsWithdrawalDetails(logs) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const [newLUSDDeposit] = stabilityPool\n            .extractEvents(logs, \"UserDepositChanged\")\n            .map(({ args: { _newDeposit } }) => decimalify(_newDeposit));\n        const [[collateralGain, lusdLoss]] = stabilityPool\n            .extractEvents(logs, \"ETHGainWithdrawn\")\n            .map(({ args: { _ETH, _LUSDLoss } }) => [decimalify(_ETH), decimalify(_LUSDLoss)]);\n        const [lqtyReward] = stabilityPool\n            .extractEvents(logs, \"LQTYPaidToDepositor\")\n            .map(({ args: { _LQTY } }) => decimalify(_LQTY));\n        return {\n            lusdLoss,\n            newLUSDDeposit,\n            collateralGain,\n            lqtyReward\n        };\n    }\n    _wrapStabilityPoolGainsWithdrawal(rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => this._extractStabilityPoolGainsWithdrawalDetails(logs));\n    }\n    _wrapStabilityDepositTopup(change, rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => ({\n            ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n            change\n        }));\n    }\n    async _wrapStabilityDepositWithdrawal(rawPopulatedTransaction) {\n        const { stabilityPool, lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs, from: userAddress }) => {\n            const gainsWithdrawalDetails = this._extractStabilityPoolGainsWithdrawalDetails(logs);\n            const [withdrawLUSD] = lusdToken\n                .extractEvents(logs, \"Transfer\")\n                .filter(({ args: { from, to } }) => from === stabilityPool.address && to === userAddress)\n                .map(({ args: { value } }) => decimalify(value));\n            return {\n                ...gainsWithdrawalDetails,\n                change: { withdrawLUSD, withdrawAllLUSD: gainsWithdrawalDetails.newLUSDDeposit.isZero }\n            };\n        });\n    }\n    _wrapCollateralGainTransfer(rawPopulatedTransaction) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const [newTrove] = borrowerOperations\n                .extractEvents(logs, \"TroveUpdated\")\n                .map(({ args: { _coll, _debt } }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n            return {\n                ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n                newTrove\n            };\n        });\n    }\n    async _findHintsForNominalCollateralRatio(nominalCollateralRatio) {\n        const { sortedTroves, hintHelpers } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const numberOfTroves = await this._readable.getNumberOfTroves();\n        if (!numberOfTroves) {\n            return [constants_1.AddressZero, constants_1.AddressZero];\n        }\n        if (nominalCollateralRatio.infinite) {\n            return [constants_1.AddressZero, await sortedTroves.getFirst()];\n        }\n        const totalNumberOfTrials = Math.ceil(10 * Math.sqrt(numberOfTroves));\n        const [firstTrials, ...restOfTrials] = generateTrials(totalNumberOfTrials);\n        const collectApproxHint = ({ latestRandomSeed, results }, numberOfTrials) => hintHelpers\n            .getApproxHint(nominalCollateralRatio.hex, numberOfTrials, latestRandomSeed)\n            .then(({ latestRandomSeed, ...result }) => ({\n            latestRandomSeed,\n            results: [...results, result]\n        }));\n        const { results } = await restOfTrials.reduce((p, numberOfTrials) => p.then(state => collectApproxHint(state, numberOfTrials)), collectApproxHint({ latestRandomSeed: randomInteger(), results: [] }, firstTrials));\n        const { hintAddress } = results.reduce((a, b) => (a.diff.lt(b.diff) ? a : b));\n        return sortedTroves.findInsertPosition(nominalCollateralRatio.hex, hintAddress, hintAddress);\n    }\n    async _findHints(trove) {\n        if (trove instanceof lib_base_1.TroveWithPendingRedistribution) {\n            throw new Error(\"Rewards must be applied to this Trove\");\n        }\n        return this._findHintsForNominalCollateralRatio(trove._nominalCollateralRatio);\n    }\n    async _findRedemptionHints(amount) {\n        const { hintHelpers } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const price = await this._readable.getPrice();\n        const { firstRedemptionHint, partialRedemptionHintNICR, truncatedLUSDamount } = await hintHelpers.getRedemptionHints(amount.hex, price.hex, exports._redeemMaxIterations);\n        const [partialRedemptionUpperHint, partialRedemptionLowerHint] = partialRedemptionHintNICR.isZero()\n            ? [constants_1.AddressZero, constants_1.AddressZero]\n            : await this._findHintsForNominalCollateralRatio(decimalify(partialRedemptionHintNICR));\n        return [\n            decimalify(truncatedLUSDamount),\n            firstRedemptionHint,\n            partialRedemptionUpperHint,\n            partialRedemptionLowerHint,\n            partialRedemptionHintNICR\n        ];\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.openTrove} */\n    async openTrove(params, maxBorrowingRate, overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const normalized = lib_base_1._normalizeTroveCreation(params);\n        const { depositCollateral, borrowLUSD } = normalized;\n        const fees = await this._readable.getFees();\n        const borrowingRate = fees.borrowingRate();\n        const newTrove = lib_base_1.Trove.create(normalized, borrowingRate);\n        maxBorrowingRate =\n            maxBorrowingRate !== undefined\n                ? lib_base_1.Decimal.from(maxBorrowingRate)\n                : borrowingRate.add(defaultBorrowingRateSlippageTolerance);\n        return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.openTrove({ value: depositCollateral.hex, ...overrides }, compose(addGasForPotentialLastFeeOperationTimeUpdate, addGasForPotentialListTraversal), maxBorrowingRate.hex, borrowLUSD.hex, ...(await this._findHints(newTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.closeTrove} */\n    async closeTrove(overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapTroveClosure(await borrowerOperations.estimateAndPopulate.closeTrove({ ...overrides }, id));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositCollateral} */\n    depositCollateral(amount, overrides) {\n        return this.adjustTrove({ depositCollateral: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawCollateral} */\n    withdrawCollateral(amount, overrides) {\n        return this.adjustTrove({ withdrawCollateral: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.borrowLUSD} */\n    borrowLUSD(amount, maxBorrowingRate, overrides) {\n        return this.adjustTrove({ borrowLUSD: amount }, maxBorrowingRate, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.repayLUSD} */\n    repayLUSD(amount, overrides) {\n        return this.adjustTrove({ repayLUSD: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.adjustTrove} */\n    async adjustTrove(params, maxBorrowingRate, overrides) {\n        var _a, _b;\n        const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const normalized = lib_base_1._normalizeTroveAdjustment(params);\n        const { depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD } = normalized;\n        const [trove, fees] = await Promise.all([\n            this._readable.getTrove(address),\n            borrowLUSD && this._readable.getFees()\n        ]);\n        const borrowingRate = fees === null || fees === void 0 ? void 0 : fees.borrowingRate();\n        const finalTrove = trove.adjust(normalized, borrowingRate);\n        maxBorrowingRate =\n            maxBorrowingRate !== undefined\n                ? lib_base_1.Decimal.from(maxBorrowingRate)\n                : (_a = borrowingRate === null || borrowingRate === void 0 ? void 0 : borrowingRate.add(defaultBorrowingRateSlippageTolerance)) !== null && _a !== void 0 ? _a : lib_base_1.Decimal.ZERO;\n        return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.adjustTrove({ value: depositCollateral === null || depositCollateral === void 0 ? void 0 : depositCollateral.hex, ...overrides }, compose(borrowLUSD ? addGasForPotentialLastFeeOperationTimeUpdate : id, addGasForPotentialListTraversal), maxBorrowingRate.hex, (withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : lib_base_1.Decimal.ZERO).hex, ((_b = borrowLUSD !== null && borrowLUSD !== void 0 ? borrowLUSD : repayLUSD) !== null && _b !== void 0 ? _b : lib_base_1.Decimal.ZERO).hex, !!borrowLUSD, ...(await this._findHints(finalTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.claimCollateralSurplus} */\n    async claimCollateralSurplus(overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await borrowerOperations.estimateAndPopulate.claimCollateral({ ...overrides }, id));\n    }\n    /** @internal */\n    async setPrice(price, overrides) {\n        const { priceFeed } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (!contracts_1._priceFeedIsTestnet(priceFeed)) {\n            throw new Error(\"setPrice() unavailable on this deployment of Liquity\");\n        }\n        return this._wrapSimpleTransaction(await priceFeed.estimateAndPopulate.setPrice({ ...overrides }, id, lib_base_1.Decimal.from(price).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidate} */\n    async liquidate(address, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (Array.isArray(address)) {\n            return this._wrapLiquidation(await troveManager.estimateAndPopulate.batchLiquidateTroves({ ...overrides }, addGasForLQTYIssuance, address));\n        }\n        else {\n            return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidate({ ...overrides }, addGasForLQTYIssuance, address));\n        }\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidateUpTo} */\n    async liquidateUpTo(maximumNumberOfTrovesToLiquidate, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidateTroves({ ...overrides }, addGasForLQTYIssuance, maximumNumberOfTrovesToLiquidate));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositLUSDInStabilityPool} */\n    async depositLUSDInStabilityPool(amount, frontendTag, overrides) {\n        var _a;\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const depositLUSD = lib_base_1.Decimal.from(amount);\n        return this._wrapStabilityDepositTopup({ depositLUSD }, await stabilityPool.estimateAndPopulate.provideToSP({ ...overrides }, addGasForLQTYIssuance, depositLUSD.hex, (_a = frontendTag !== null && frontendTag !== void 0 ? frontendTag : this._readable.connection.frontendTag) !== null && _a !== void 0 ? _a : constants_1.AddressZero));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLUSDFromStabilityPool} */\n    async withdrawLUSDFromStabilityPool(amount, overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapStabilityDepositWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides }, addGasForLQTYIssuance, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStabilityPool} */\n    async withdrawGainsFromStabilityPool(overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapStabilityPoolGainsWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides }, addGasForLQTYIssuance, lib_base_1.Decimal.ZERO.hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.transferCollateralGainToTrove} */\n    async transferCollateralGainToTrove(overrides) {\n        const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const [initialTrove, stabilityDeposit] = await Promise.all([\n            this._readable.getTrove(address),\n            this._readable.getStabilityDeposit(address)\n        ]);\n        const finalTrove = initialTrove.addCollateral(stabilityDeposit.collateralGain);\n        return this._wrapCollateralGainTransfer(await stabilityPool.estimateAndPopulate.withdrawETHGainToTrove({ ...overrides }, compose(addGasForPotentialListTraversal, addGasForLQTYIssuance), ...(await this._findHints(finalTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLUSD} */\n    async sendLUSD(toAddress, amount, overrides) {\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lusdToken.estimateAndPopulate.transfer({ ...overrides }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLQTY} */\n    async sendLQTY(toAddress, amount, overrides) {\n        const { lqtyToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyToken.estimateAndPopulate.transfer({ ...overrides }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.redeemLUSD} */\n    async redeemLUSD(amount, maxRedemptionRate, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const attemptedLUSDAmount = lib_base_1.Decimal.from(amount);\n        const [fees, total, [truncatedAmount, firstRedemptionHint, ...partialHints]] = await Promise.all([\n            this._readable.getFees(),\n            this._readable.getTotal(),\n            this._findRedemptionHints(attemptedLUSDAmount)\n        ]);\n        if (truncatedAmount.isZero) {\n            throw new Error(`redeemLUSD: amount too low to redeem (try at least ${lib_base_1.LUSD_MINIMUM_NET_DEBT})`);\n        }\n        const defaultMaxRedemptionRate = (amount) => lib_base_1.Decimal.min(fees.redemptionRate(amount.div(total.debt)).add(defaultRedemptionRateSlippageTolerance), lib_base_1.Decimal.ONE);\n        const populateRedemption = async (attemptedLUSDAmount, maxRedemptionRate, truncatedAmount = attemptedLUSDAmount, partialHints = [constants_1.AddressZero, constants_1.AddressZero, 0]) => {\n            const maxRedemptionRateOrDefault = maxRedemptionRate !== undefined\n                ? lib_base_1.Decimal.from(maxRedemptionRate)\n                : defaultMaxRedemptionRate(truncatedAmount);\n            return new PopulatedEthersRedemption(await troveManager.estimateAndPopulate.redeemCollateral({ ...overrides }, addGasForPotentialLastFeeOperationTimeUpdate, truncatedAmount.hex, firstRedemptionHint, ...partialHints, exports._redeemMaxIterations, maxRedemptionRateOrDefault.hex), this._readable.connection, attemptedLUSDAmount, truncatedAmount, truncatedAmount.lt(attemptedLUSDAmount)\n                ? newMaxRedemptionRate => populateRedemption(truncatedAmount.add(lib_base_1.LUSD_MINIMUM_NET_DEBT), newMaxRedemptionRate !== null && newMaxRedemptionRate !== void 0 ? newMaxRedemptionRate : maxRedemptionRate)\n                : undefined);\n        };\n        return populateRedemption(attemptedLUSDAmount, maxRedemptionRate, truncatedAmount, partialHints);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeLQTY} */\n    async stakeLQTY(amount, overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.stake({ ...overrides }, id, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeLQTY} */\n    async unstakeLQTY(amount, overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.unstake({ ...overrides }, id, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStaking} */\n    withdrawGainsFromStaking(overrides) {\n        return this.unstakeLQTY(lib_base_1.Decimal.ZERO, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.registerFrontend} */\n    async registerFrontend(kickbackRate, overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await stabilityPool.estimateAndPopulate.registerFrontEnd({ ...overrides }, id, lib_base_1.Decimal.from(kickbackRate).hex));\n    }\n    /** @internal */\n    async _mintUniToken(amount, address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides));\n        const { uniToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (!contracts_1._uniTokenIsMock(uniToken)) {\n            throw new Error(\"_mintUniToken() unavailable on this deployment of Liquity\");\n        }\n        return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.mint({ ...overrides }, id, address, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.approveUniTokens} */\n    async approveUniTokens(allowance, overrides) {\n        const { uniToken, unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.approve({ ...overrides }, id, unipool.address, lib_base_1.Decimal.from(allowance !== null && allowance !== void 0 ? allowance : lib_base_1.Decimal.INFINITY).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeUniTokens} */\n    async stakeUniTokens(amount, overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.stake({ ...overrides }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeUniTokens} */\n    async unstakeUniTokens(amount, overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdraw({ ...overrides }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLQTYRewardFromLiquidityMining} */\n    async withdrawLQTYRewardFromLiquidityMining(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.claimReward({ ...overrides }, addGasForUnipoolRewardUpdate));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.exitLiquidityMining} */\n    async exitLiquidityMining(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdrawAndClaim({ ...overrides }, addGasForUnipoolRewardUpdate));\n    }\n}\nexports.PopulatableEthersLiquity = PopulatableEthersLiquity;\n//# sourceMappingURL=PopulatableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}