{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._connect = exports._connectByChainId = exports._connectToDeployment = exports.UnsupportedNetworkError = exports._usingStore = exports._requireFrontendAddress = exports._requireAddress = exports._getProvider = exports._requireSigner = exports._getBlockTimestamp = exports._getContracts = void 0;\n\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\n\nconst lib_base_1 = require(\"@liquity/lib-base\");\n\nconst dev_json_1 = __importDefault(require(\"../deployments/dev.json\"));\n\nconst goerli_json_1 = __importDefault(require(\"../deployments/goerli.json\"));\n\nconst kovan_json_1 = __importDefault(require(\"../deployments/kovan.json\"));\n\nconst rinkeby_json_1 = __importDefault(require(\"../deployments/rinkeby.json\"));\n\nconst ropsten_json_1 = __importDefault(require(\"../deployments/ropsten.json\"));\n\nconst mainnet_json_1 = __importDefault(require(\"../deployments/mainnet.json\"));\n\nconst contracts_1 = require(\"./contracts\");\n\nconst _Multicall_1 = require(\"./_Multicall\");\n\nconst dev = dev_json_1.default;\nconst deployments = {\n  [mainnet_json_1.default.chainId]: mainnet_json_1.default,\n  [ropsten_json_1.default.chainId]: ropsten_json_1.default,\n  [rinkeby_json_1.default.chainId]: rinkeby_json_1.default,\n  [goerli_json_1.default.chainId]: goerli_json_1.default,\n  [kovan_json_1.default.chainId]: kovan_json_1.default,\n  ...(dev !== null ? {\n    [dev.chainId]: dev\n  } : {})\n};\n\nconst branded = t => t;\n\nconst connectionFrom = (provider, signer, _contracts, _multicall, {\n  deploymentDate,\n  totalStabilityPoolLQTYReward,\n  liquidityMiningLQTYRewardRate,\n  ...deployment\n}, optionalParams) => {\n  if (optionalParams && optionalParams.useStore !== undefined && !validStoreOptions.includes(optionalParams.useStore)) {\n    throw new Error(`Invalid useStore value ${optionalParams.useStore}`);\n  }\n\n  return branded({\n    provider,\n    signer,\n    _contracts,\n    _multicall,\n    deploymentDate: new Date(deploymentDate),\n    totalStabilityPoolLQTYReward: lib_base_1.Decimal.from(totalStabilityPoolLQTYReward),\n    liquidityMiningLQTYRewardRate: lib_base_1.Decimal.from(liquidityMiningLQTYRewardRate),\n    ...deployment,\n    ...optionalParams\n  });\n};\n/** @internal */\n\n\nconst _getContracts = connection => connection._contracts;\n\nexports._getContracts = _getContracts;\n\nconst getMulticall = connection => connection._multicall;\n\nconst numberify = bigNumber => bigNumber.toNumber();\n\nconst getTimestampFromBlock = ({\n  timestamp\n}) => timestamp;\n/** @internal */\n\n\nconst _getBlockTimestamp = (connection, blockTag = \"latest\") => {\n  var _a, _b;\n\n  return (_b = (_a = // Get the timestamp via a contract call whenever possible, to make it batchable with other calls\n  getMulticall(connection)) === null || _a === void 0 ? void 0 : _a.getCurrentBlockTimestamp({\n    blockTag\n  }).then(numberify)) !== null && _b !== void 0 ? _b : exports._getProvider(connection).getBlock(blockTag).then(getTimestampFromBlock);\n};\n\nexports._getBlockTimestamp = _getBlockTimestamp;\n\nconst panic = e => {\n  throw e;\n};\n/** @internal */\n\n\nconst _requireSigner = connection => {\n  var _a;\n\n  return (_a = connection.signer) !== null && _a !== void 0 ? _a : panic(new Error(\"Must be connected through a Signer\"));\n};\n\nexports._requireSigner = _requireSigner;\n/** @internal */\n\nconst _getProvider = connection => connection.provider;\n\nexports._getProvider = _getProvider; // TODO parameterize error message?\n\n/** @internal */\n\nconst _requireAddress = (connection, overrides) => {\n  var _a, _b;\n\n  return (_b = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.from) !== null && _a !== void 0 ? _a : connection.userAddress) !== null && _b !== void 0 ? _b : panic(new Error(\"A user address is required\"));\n};\n\nexports._requireAddress = _requireAddress;\n/** @internal */\n\nconst _requireFrontendAddress = connection => {\n  var _a;\n\n  return (_a = connection.frontendTag) !== null && _a !== void 0 ? _a : panic(new Error(\"A frontend address is required\"));\n};\n\nexports._requireFrontendAddress = _requireFrontendAddress;\n/** @internal */\n\nconst _usingStore = connection => connection.useStore !== undefined;\n\nexports._usingStore = _usingStore;\n/**\n * Thrown when trying to connect to a network where Liquity is not deployed.\n *\n * @remarks\n * Thrown by {@link ReadableEthersLiquity.(connect:2)} and {@link EthersLiquity.(connect:2)}.\n *\n * @public\n */\n\nclass UnsupportedNetworkError extends Error {\n  /** @internal */\n  constructor(chainId) {\n    super(`Unsupported network (chainId = ${chainId})`);\n    this.name = \"UnsupportedNetworkError\";\n    this.chainId = chainId;\n  }\n\n}\n\nexports.UnsupportedNetworkError = UnsupportedNetworkError;\n\nconst getProviderAndSigner = signerOrProvider => {\n  var _a;\n\n  const provider = abstract_signer_1.Signer.isSigner(signerOrProvider) ? (_a = signerOrProvider.provider) !== null && _a !== void 0 ? _a : panic(new Error(\"Signer must have a Provider\")) : signerOrProvider;\n  const signer = abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider : undefined;\n  return [provider, signer];\n};\n/** @internal */\n\n\nconst _connectToDeployment = (deployment, signerOrProvider, optionalParams) => connectionFrom(...getProviderAndSigner(signerOrProvider), contracts_1._connectToContracts(signerOrProvider, deployment), undefined, deployment, optionalParams);\n\nexports._connectToDeployment = _connectToDeployment;\nconst validStoreOptions = [\"blockPolled\"];\n/** @internal */\n\nfunction _connectByChainId(provider, signer, chainId, optionalParams) {\n  var _a;\n\n  const deployment = (_a = deployments[chainId]) !== null && _a !== void 0 ? _a : panic(new UnsupportedNetworkError(chainId));\n  return connectionFrom(provider, signer, contracts_1._connectToContracts(signer !== null && signer !== void 0 ? signer : provider, deployment), _Multicall_1._connectToMulticall(signer !== null && signer !== void 0 ? signer : provider, chainId), deployment, optionalParams);\n}\n\nexports._connectByChainId = _connectByChainId;\n/** @internal */\n\nconst _connect = async (signerOrProvider, optionalParams) => {\n  const [provider, signer] = getProviderAndSigner(signerOrProvider);\n\n  if (signer) {\n    if ((optionalParams === null || optionalParams === void 0 ? void 0 : optionalParams.userAddress) !== undefined) {\n      throw new Error(\"Can't override userAddress when connecting through Signer\");\n    }\n\n    optionalParams = { ...optionalParams,\n      userAddress: await signer.getAddress()\n    };\n  }\n\n  return _connectByChainId(provider, signer, (await provider.getNetwork()).chainId, optionalParams);\n};\n\nexports._connect = _connect;","map":{"version":3,"sources":["../../src/EthersLiquityConnection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._connect = exports._connectByChainId = exports._connectToDeployment = exports.UnsupportedNetworkError = exports._usingStore = exports._requireFrontendAddress = exports._requireAddress = exports._getProvider = exports._requireSigner = exports._getBlockTimestamp = exports._getContracts = void 0;\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst dev_json_1 = __importDefault(require(\"../deployments/dev.json\"));\nconst goerli_json_1 = __importDefault(require(\"../deployments/goerli.json\"));\nconst kovan_json_1 = __importDefault(require(\"../deployments/kovan.json\"));\nconst rinkeby_json_1 = __importDefault(require(\"../deployments/rinkeby.json\"));\nconst ropsten_json_1 = __importDefault(require(\"../deployments/ropsten.json\"));\nconst mainnet_json_1 = __importDefault(require(\"../deployments/mainnet.json\"));\nconst contracts_1 = require(\"./contracts\");\nconst _Multicall_1 = require(\"./_Multicall\");\nconst dev = dev_json_1.default;\nconst deployments = {\n    [mainnet_json_1.default.chainId]: mainnet_json_1.default,\n    [ropsten_json_1.default.chainId]: ropsten_json_1.default,\n    [rinkeby_json_1.default.chainId]: rinkeby_json_1.default,\n    [goerli_json_1.default.chainId]: goerli_json_1.default,\n    [kovan_json_1.default.chainId]: kovan_json_1.default,\n    ...(dev !== null ? { [dev.chainId]: dev } : {})\n};\nconst branded = (t) => t;\nconst connectionFrom = (provider, signer, _contracts, _multicall, { deploymentDate, totalStabilityPoolLQTYReward, liquidityMiningLQTYRewardRate, ...deployment }, optionalParams) => {\n    if (optionalParams &&\n        optionalParams.useStore !== undefined &&\n        !validStoreOptions.includes(optionalParams.useStore)) {\n        throw new Error(`Invalid useStore value ${optionalParams.useStore}`);\n    }\n    return branded({\n        provider,\n        signer,\n        _contracts,\n        _multicall,\n        deploymentDate: new Date(deploymentDate),\n        totalStabilityPoolLQTYReward: lib_base_1.Decimal.from(totalStabilityPoolLQTYReward),\n        liquidityMiningLQTYRewardRate: lib_base_1.Decimal.from(liquidityMiningLQTYRewardRate),\n        ...deployment,\n        ...optionalParams\n    });\n};\n/** @internal */\nconst _getContracts = (connection) => connection._contracts;\nexports._getContracts = _getContracts;\nconst getMulticall = (connection) => connection._multicall;\nconst numberify = (bigNumber) => bigNumber.toNumber();\nconst getTimestampFromBlock = ({ timestamp }) => timestamp;\n/** @internal */\nconst _getBlockTimestamp = (connection, blockTag = \"latest\") => { var _a, _b; return (_b = (_a = \n// Get the timestamp via a contract call whenever possible, to make it batchable with other calls\ngetMulticall(connection)) === null || _a === void 0 ? void 0 : _a.getCurrentBlockTimestamp({ blockTag }).then(numberify)) !== null && _b !== void 0 ? _b : exports._getProvider(connection).getBlock(blockTag).then(getTimestampFromBlock); };\nexports._getBlockTimestamp = _getBlockTimestamp;\nconst panic = (e) => {\n    throw e;\n};\n/** @internal */\nconst _requireSigner = (connection) => { var _a; return (_a = connection.signer) !== null && _a !== void 0 ? _a : panic(new Error(\"Must be connected through a Signer\")); };\nexports._requireSigner = _requireSigner;\n/** @internal */\nconst _getProvider = (connection) => connection.provider;\nexports._getProvider = _getProvider;\n// TODO parameterize error message?\n/** @internal */\nconst _requireAddress = (connection, overrides) => { var _a, _b; return (_b = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.from) !== null && _a !== void 0 ? _a : connection.userAddress) !== null && _b !== void 0 ? _b : panic(new Error(\"A user address is required\")); };\nexports._requireAddress = _requireAddress;\n/** @internal */\nconst _requireFrontendAddress = (connection) => { var _a; return (_a = connection.frontendTag) !== null && _a !== void 0 ? _a : panic(new Error(\"A frontend address is required\")); };\nexports._requireFrontendAddress = _requireFrontendAddress;\n/** @internal */\nconst _usingStore = (connection) => connection.useStore !== undefined;\nexports._usingStore = _usingStore;\n/**\n * Thrown when trying to connect to a network where Liquity is not deployed.\n *\n * @remarks\n * Thrown by {@link ReadableEthersLiquity.(connect:2)} and {@link EthersLiquity.(connect:2)}.\n *\n * @public\n */\nclass UnsupportedNetworkError extends Error {\n    /** @internal */\n    constructor(chainId) {\n        super(`Unsupported network (chainId = ${chainId})`);\n        this.name = \"UnsupportedNetworkError\";\n        this.chainId = chainId;\n    }\n}\nexports.UnsupportedNetworkError = UnsupportedNetworkError;\nconst getProviderAndSigner = (signerOrProvider) => {\n    var _a;\n    const provider = abstract_signer_1.Signer.isSigner(signerOrProvider)\n        ? (_a = signerOrProvider.provider) !== null && _a !== void 0 ? _a : panic(new Error(\"Signer must have a Provider\")) : signerOrProvider;\n    const signer = abstract_signer_1.Signer.isSigner(signerOrProvider) ? signerOrProvider : undefined;\n    return [provider, signer];\n};\n/** @internal */\nconst _connectToDeployment = (deployment, signerOrProvider, optionalParams) => connectionFrom(...getProviderAndSigner(signerOrProvider), contracts_1._connectToContracts(signerOrProvider, deployment), undefined, deployment, optionalParams);\nexports._connectToDeployment = _connectToDeployment;\nconst validStoreOptions = [\"blockPolled\"];\n/** @internal */\nfunction _connectByChainId(provider, signer, chainId, optionalParams) {\n    var _a;\n    const deployment = (_a = deployments[chainId]) !== null && _a !== void 0 ? _a : panic(new UnsupportedNetworkError(chainId));\n    return connectionFrom(provider, signer, contracts_1._connectToContracts(signer !== null && signer !== void 0 ? signer : provider, deployment), _Multicall_1._connectToMulticall(signer !== null && signer !== void 0 ? signer : provider, chainId), deployment, optionalParams);\n}\nexports._connectByChainId = _connectByChainId;\n/** @internal */\nconst _connect = async (signerOrProvider, optionalParams) => {\n    const [provider, signer] = getProviderAndSigner(signerOrProvider);\n    if (signer) {\n        if ((optionalParams === null || optionalParams === void 0 ? void 0 : optionalParams.userAddress) !== undefined) {\n            throw new Error(\"Can't override userAddress when connecting through Signer\");\n        }\n        optionalParams = {\n            ...optionalParams,\n            userAddress: await signer.getAddress()\n        };\n    }\n    return _connectByChainId(provider, signer, (await provider.getNetwork()).chainId, optionalParams);\n};\nexports._connect = _connect;\n//# sourceMappingURL=EthersLiquityConnection.js.map"]},"metadata":{},"sourceType":"script"}