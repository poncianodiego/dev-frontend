{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched = exports.isBatchedProvider = void 0;\n\nvar address_1 = require(\"@ethersproject/address\");\n\nvar contracts_1 = require(\"@ethersproject/contracts\");\n\nvar properties_1 = require(\"@ethersproject/properties\");\n\nvar WebSocketAugmentedProvider_1 = require(\"./WebSocketAugmentedProvider\");\n\nvar multicallAddress = {\n  1: \"0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441\",\n  3: \"0x53C43764255c17BD724F74c4eF150724AC50a3ed\",\n  4: \"0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821\",\n  5: \"0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e\",\n  42: \"0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A\"\n};\n\nvar hasMulticall = function hasMulticall(chainId) {\n  return chainId in multicallAddress;\n};\n\nvar multicallAbi = [{\n  type: \"function\",\n  name: \"aggregate\",\n  stateMutability: \"nonpayable\",\n  constant: false,\n  payable: false,\n  inputs: [{\n    components: [{\n      name: \"target\",\n      type: \"address\"\n    }, {\n      name: \"callData\",\n      type: \"bytes\"\n    }],\n    name: \"calls\",\n    type: \"tuple[]\"\n  }],\n  outputs: [{\n    name: \"blockNumber\",\n    type: \"uint256\"\n  }, {\n    name: \"returnData\",\n    type: \"bytes[]\"\n  }]\n}, {\n  type: \"function\",\n  name: \"getEthBalance\",\n  stateMutability: \"view\",\n  constant: true,\n  payable: false,\n  inputs: [{\n    name: \"addr\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"balance\",\n    type: \"uint256\"\n  }]\n}];\n\nvar emptyBatch = function emptyBatch() {\n  return {\n    calls: [],\n    callbacks: []\n  };\n}; // TODO\n//\n// Technically, requests that have a `from` address shouldn't be batched, because `msg.sender` will\n// be replaced with the Multicall contract's address when the batched calls are being executed.\n//\n// Currently, `@liquity/lib-ethers` makes many of its read calls through Signers, which populates\n// `from`. Instead these calls should be made through a Provider, and `from` should be omitted\n// (since none of the read calls in Liquity care about `msg.sender`).\n//\n// Then we'll be able to properly exclude calls that have `from` addresses from batching.\n\n\nvar batchableCall = function batchableCall(request) {\n  return request.gasLimit === undefined && request.gasPrice === undefined && request.value === undefined;\n};\n\nvar batchedCall = function batchedCall(request, multicallAddress) {\n  return request.to === multicallAddress && typeof request.data === \"string\" && request.data.startsWith(\"0x252dba42\");\n}; // signature of `aggregate((address,bytes)[])`\n\n\nvar batchedProviders = [];\n\nvar isBatchedProvider = function isBatchedProvider(provider) {\n  return batchedProviders.some(function (batchedProvider) {\n    return provider instanceof batchedProvider;\n  });\n};\n\nexports.isBatchedProvider = isBatchedProvider;\n\nvar Batched = function Batched(Base) {\n  var batchedProvider = /*#__PURE__*/function (_Base) {\n    _inherits(batchedProvider, _Base);\n\n    var _super = _createSuper(batchedProvider);\n\n    function batchedProvider() {\n      var _this;\n\n      _classCallCheck(this, batchedProvider);\n\n      _this = _super.apply(this, arguments);\n      _this.batchingDelayMs = 10;\n      _this._chainId = 0;\n      _this._batched = emptyBatch();\n      _this._numberOfBatchedCalls = 0;\n      _this._numberOfActualCalls = 0;\n      return _this;\n    }\n\n    _createClass(batchedProvider, [{\n      key: \"chainId\",\n      get: function get() {\n        return this._chainId;\n      },\n      set: function set(chainId) {\n        if (this._multicall) {\n          throw new Error(\"can only set chainId once\");\n        }\n\n        if (hasMulticall(chainId)) {\n          this._multicall = new contracts_1.Contract(multicallAddress[chainId], multicallAbi, this);\n        }\n\n        this._chainId = chainId;\n      }\n    }, {\n      key: \"_dispatchCalls\",\n      value: function () {\n        var _dispatchCalls2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _this$_batched, calls, callbacks, blockTag, results;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _this$_batched = this._batched, calls = _this$_batched.calls, callbacks = _this$_batched.callbacks, blockTag = _this$_batched.blockTag;\n                  this._batched = emptyBatch();\n                  _context.prev = 2;\n\n                  if (!(calls.length > 1)) {\n                    _context.next = 9;\n                    break;\n                  }\n\n                  _context.next = 6;\n                  return this._multicall.callStatic.aggregate(calls, {\n                    blockTag: blockTag\n                  }).then(function (x) {\n                    return x.returnData;\n                  });\n\n                case 6:\n                  _context.t0 = _context.sent;\n                  _context.next = 13;\n                  break;\n\n                case 9:\n                  _context.next = 11;\n                  return _get(_getPrototypeOf(batchedProvider.prototype), \"call\", this).call(this, {\n                    to: calls[0].target,\n                    data: calls[0].callData\n                  }, blockTag);\n\n                case 11:\n                  _context.t1 = _context.sent;\n                  _context.t0 = [_context.t1];\n\n                case 13:\n                  results = _context.t0;\n                  callbacks.forEach(function (_ref, i) {\n                    var _ref2 = _slicedToArray(_ref, 1),\n                        resolve = _ref2[0];\n\n                    return resolve(results[i]);\n                  });\n                  _context.next = 20;\n                  break;\n\n                case 17:\n                  _context.prev = 17;\n                  _context.t2 = _context[\"catch\"](2);\n                  callbacks.forEach(function (_ref3) {\n                    var _ref4 = _slicedToArray(_ref3, 2),\n                        reject = _ref4[1];\n\n                    return reject(_context.t2);\n                  });\n\n                case 20:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[2, 17]]);\n        }));\n\n        function _dispatchCalls() {\n          return _dispatchCalls2.apply(this, arguments);\n        }\n\n        return _dispatchCalls;\n      }()\n    }, {\n      key: \"_enqueueCall\",\n      value: function _enqueueCall(call) {\n        var _this2 = this;\n\n        if (this._timeoutId !== undefined) {\n          clearTimeout(this._timeoutId);\n        }\n\n        this._batched.calls.push(call);\n\n        this._timeoutId = setTimeout(function () {\n          return _this2._dispatchCalls();\n        }, this.batchingDelayMs);\n        return new Promise(function (resolve, reject) {\n          return _this2._batched.callbacks.push([resolve, reject]);\n        });\n      }\n    }, {\n      key: \"_alreadyBatchedCallsConflictWith\",\n      value: function _alreadyBatchedCallsConflictWith(blockTag) {\n        var _a;\n\n        return this._batched.calls.length !== 0 && (blockTag !== null && blockTag !== void 0 ? blockTag : \"latest\") !== ((_a = this._batched.blockTag) !== null && _a !== void 0 ? _a : \"latest\");\n      }\n    }, {\n      key: \"call\",\n      value: function () {\n        var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request, blockTag) {\n          var now, timeSinceLastRatioCheck, _yield$Promise$all, _yield$Promise$all2, resolvedRequest, resolvedBlockTag;\n\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (this._multicall) {\n                    _context2.next = 4;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\", _get(_getPrototypeOf(batchedProvider.prototype), \"call\", this).call(this, request, blockTag));\n\n                case 4:\n                  now = new Date().getTime();\n\n                  if (this._timeOfLastRatioCheck === undefined) {\n                    this._timeOfLastRatioCheck = now;\n                  } else {\n                    timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;\n\n                    if (timeSinceLastRatioCheck >= 10000 && this._numberOfActualCalls) {\n                      // console.log(\n                      //   `Call batching ratio: ${\n                      //     Math.round((10 * this._numberOfBatchedCalls) / this._numberOfActualCalls) / 10\n                      //   }X`\n                      // );\n                      this._numberOfBatchedCalls = 0;\n                      this._numberOfActualCalls = 0;\n                      this._timeOfLastRatioCheck = now;\n                    }\n                  }\n\n                case 6:\n                  _context2.next = 8;\n                  return Promise.all([properties_1.resolveProperties(request), blockTag]);\n\n                case 8:\n                  _yield$Promise$all = _context2.sent;\n                  _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                  resolvedRequest = _yield$Promise$all2[0];\n                  resolvedBlockTag = _yield$Promise$all2[1];\n\n                  if (!(batchedCall(resolvedRequest, this._multicall.address) || !batchableCall(resolvedRequest) || this._alreadyBatchedCallsConflictWith(resolvedBlockTag))) {\n                    _context2.next = 17;\n                    break;\n                  }\n\n                  this._numberOfActualCalls++;\n                  return _context2.abrupt(\"return\", _get(_getPrototypeOf(batchedProvider.prototype), \"call\", this).call(this, resolvedRequest, resolvedBlockTag));\n\n                case 17:\n                  this._numberOfBatchedCalls++;\n\n                  if (this._batched.calls.length === 0) {\n                    this._batched.blockTag = resolvedBlockTag;\n                  }\n\n                  return _context2.abrupt(\"return\", this._enqueueCall({\n                    target: resolvedRequest.to,\n                    callData: resolvedRequest.data\n                  }));\n\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function call(_x, _x2) {\n          return _call.apply(this, arguments);\n        }\n\n        return call;\n      }()\n    }, {\n      key: \"getBalance\",\n      value: function () {\n        var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(addressOrName, blockTag) {\n          var _yield$Promise$all3, _yield$Promise$all4, resolvedAddressOrName, resolvedBlockTag, _yield$this$_multical, _yield$this$_multical2, balance;\n\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return Promise.all([addressOrName, blockTag]);\n\n                case 2:\n                  _yield$Promise$all3 = _context3.sent;\n                  _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                  resolvedAddressOrName = _yield$Promise$all4[0];\n                  resolvedBlockTag = _yield$Promise$all4[1];\n\n                  if (!(!address_1.isAddress(resolvedAddressOrName) || !this._multicall)) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", _get(_getPrototypeOf(batchedProvider.prototype), \"getBalance\", this).call(this, resolvedAddressOrName, blockTag));\n\n                case 8:\n                  _context3.next = 10;\n                  return this._multicall.functions.getEthBalance(resolvedAddressOrName, {\n                    blockTag: resolvedBlockTag\n                  });\n\n                case 10:\n                  _yield$this$_multical = _context3.sent;\n                  _yield$this$_multical2 = _slicedToArray(_yield$this$_multical, 1);\n                  balance = _yield$this$_multical2[0];\n                  return _context3.abrupt(\"return\", balance);\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function getBalance(_x3, _x4) {\n          return _getBalance.apply(this, arguments);\n        }\n\n        return getBalance;\n      }()\n    }]);\n\n    return batchedProvider;\n  }(Base);\n\n  batchedProviders.push(batchedProvider);\n  return batchedProvider;\n};\n\nexports.Batched = Batched;\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched(WebSocketAugmentedProvider_1.WebSocketAugmentedWeb3Provider);","map":{"version":3,"sources":["../../src/BatchedProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched = exports.isBatchedProvider = void 0;\nconst address_1 = require(\"@ethersproject/address\");\nconst contracts_1 = require(\"@ethersproject/contracts\");\nconst properties_1 = require(\"@ethersproject/properties\");\nconst WebSocketAugmentedProvider_1 = require(\"./WebSocketAugmentedProvider\");\nconst multicallAddress = {\n    1: \"0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441\",\n    3: \"0x53C43764255c17BD724F74c4eF150724AC50a3ed\",\n    4: \"0x42Ad527de7d4e9d9d011aC45B31D8551f8Fe9821\",\n    5: \"0x77dCa2C955b15e9dE4dbBCf1246B4B85b651e50e\",\n    42: \"0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A\"\n};\nconst hasMulticall = (chainId) => chainId in multicallAddress;\nconst multicallAbi = [\n    {\n        type: \"function\",\n        name: \"aggregate\",\n        stateMutability: \"nonpayable\",\n        constant: false,\n        payable: false,\n        inputs: [\n            {\n                components: [\n                    {\n                        name: \"target\",\n                        type: \"address\"\n                    },\n                    {\n                        name: \"callData\",\n                        type: \"bytes\"\n                    }\n                ],\n                name: \"calls\",\n                type: \"tuple[]\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"blockNumber\",\n                type: \"uint256\"\n            },\n            {\n                name: \"returnData\",\n                type: \"bytes[]\"\n            }\n        ]\n    },\n    {\n        type: \"function\",\n        name: \"getEthBalance\",\n        stateMutability: \"view\",\n        constant: true,\n        payable: false,\n        inputs: [\n            {\n                name: \"addr\",\n                type: \"address\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"balance\",\n                type: \"uint256\"\n            }\n        ]\n    }\n];\nconst emptyBatch = () => ({ calls: [], callbacks: [] });\n// TODO\n//\n// Technically, requests that have a `from` address shouldn't be batched, because `msg.sender` will\n// be replaced with the Multicall contract's address when the batched calls are being executed.\n//\n// Currently, `@liquity/lib-ethers` makes many of its read calls through Signers, which populates\n// `from`. Instead these calls should be made through a Provider, and `from` should be omitted\n// (since none of the read calls in Liquity care about `msg.sender`).\n//\n// Then we'll be able to properly exclude calls that have `from` addresses from batching.\nconst batchableCall = (request) => request.gasLimit === undefined && request.gasPrice === undefined && request.value === undefined;\nconst batchedCall = (request, multicallAddress) => request.to === multicallAddress &&\n    typeof request.data === \"string\" &&\n    request.data.startsWith(\"0x252dba42\"); // signature of `aggregate((address,bytes)[])`\nconst batchedProviders = [];\nconst isBatchedProvider = (provider) => batchedProviders.some(batchedProvider => provider instanceof batchedProvider);\nexports.isBatchedProvider = isBatchedProvider;\nconst Batched = (Base) => {\n    const batchedProvider = class extends Base {\n        constructor() {\n            super(...arguments);\n            this.batchingDelayMs = 10;\n            this._chainId = 0;\n            this._batched = emptyBatch();\n            this._numberOfBatchedCalls = 0;\n            this._numberOfActualCalls = 0;\n        }\n        get chainId() {\n            return this._chainId;\n        }\n        set chainId(chainId) {\n            if (this._multicall) {\n                throw new Error(\"can only set chainId once\");\n            }\n            if (hasMulticall(chainId)) {\n                this._multicall = new contracts_1.Contract(multicallAddress[chainId], multicallAbi, this);\n            }\n            this._chainId = chainId;\n        }\n        async _dispatchCalls() {\n            const { calls, callbacks, blockTag } = this._batched;\n            this._batched = emptyBatch();\n            try {\n                const results = calls.length > 1\n                    ? await this._multicall.callStatic.aggregate(calls, { blockTag }).then(x => x.returnData)\n                    : [await super.call({ to: calls[0].target, data: calls[0].callData }, blockTag)];\n                callbacks.forEach(([resolve], i) => resolve(results[i]));\n            }\n            catch (error) {\n                callbacks.forEach(([, reject]) => reject(error));\n            }\n        }\n        _enqueueCall(call) {\n            if (this._timeoutId !== undefined) {\n                clearTimeout(this._timeoutId);\n            }\n            this._batched.calls.push(call);\n            this._timeoutId = setTimeout(() => this._dispatchCalls(), this.batchingDelayMs);\n            return new Promise((resolve, reject) => this._batched.callbacks.push([resolve, reject]));\n        }\n        _alreadyBatchedCallsConflictWith(blockTag) {\n            var _a;\n            return (this._batched.calls.length !== 0 &&\n                (blockTag !== null && blockTag !== void 0 ? blockTag : \"latest\") !== ((_a = this._batched.blockTag) !== null && _a !== void 0 ? _a : \"latest\"));\n        }\n        async call(request, blockTag) {\n            if (!this._multicall) {\n                return super.call(request, blockTag);\n            }\n            else {\n                const now = new Date().getTime();\n                if (this._timeOfLastRatioCheck === undefined) {\n                    this._timeOfLastRatioCheck = now;\n                }\n                else {\n                    const timeSinceLastRatioCheck = now - this._timeOfLastRatioCheck;\n                    if (timeSinceLastRatioCheck >= 10000 && this._numberOfActualCalls) {\n                        // console.log(\n                        //   `Call batching ratio: ${\n                        //     Math.round((10 * this._numberOfBatchedCalls) / this._numberOfActualCalls) / 10\n                        //   }X`\n                        // );\n                        this._numberOfBatchedCalls = 0;\n                        this._numberOfActualCalls = 0;\n                        this._timeOfLastRatioCheck = now;\n                    }\n                }\n            }\n            const [resolvedRequest, resolvedBlockTag] = await Promise.all([\n                properties_1.resolveProperties(request),\n                blockTag\n            ]);\n            if (batchedCall(resolvedRequest, this._multicall.address) ||\n                !batchableCall(resolvedRequest) ||\n                this._alreadyBatchedCallsConflictWith(resolvedBlockTag)) {\n                this._numberOfActualCalls++;\n                return super.call(resolvedRequest, resolvedBlockTag);\n            }\n            else {\n                this._numberOfBatchedCalls++;\n                if (this._batched.calls.length === 0) {\n                    this._batched.blockTag = resolvedBlockTag;\n                }\n                return this._enqueueCall({ target: resolvedRequest.to, callData: resolvedRequest.data });\n            }\n        }\n        async getBalance(addressOrName, blockTag) {\n            const [resolvedAddressOrName, resolvedBlockTag] = await Promise.all([addressOrName, blockTag]);\n            if (!address_1.isAddress(resolvedAddressOrName) || !this._multicall) {\n                return super.getBalance(resolvedAddressOrName, blockTag);\n            }\n            const [balance] = await this._multicall.functions.getEthBalance(resolvedAddressOrName, {\n                blockTag: resolvedBlockTag\n            });\n            return balance;\n        }\n    };\n    batchedProviders.push(batchedProvider);\n    return batchedProvider;\n};\nexports.Batched = Batched;\nexports.BatchedWebSocketAugmentedWeb3Provider = exports.Batched(WebSocketAugmentedProvider_1.WebSocketAugmentedWeb3Provider);\n//# sourceMappingURL=BatchedProvider.js.map"]},"metadata":{},"sourceType":"script"}