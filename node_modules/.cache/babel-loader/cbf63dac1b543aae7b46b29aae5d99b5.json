{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fees = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst Decimal_1 = require(\"./Decimal\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Calculator for fees.\n *\n * @remarks\n * Returned by the {@link ReadableLiquity.getFees | getFees()} function.\n *\n * @public\n */\n\n\nclass Fees {\n  /** @internal */\n  constructor(baseRateWithoutDecay, minuteDecayFactor, beta, lastFeeOperation, timeOfLatestBlock, recoveryMode) {\n    this._baseRateWithoutDecay = Decimal_1.Decimal.from(baseRateWithoutDecay);\n    this._minuteDecayFactor = Decimal_1.Decimal.from(minuteDecayFactor);\n    this._beta = Decimal_1.Decimal.from(beta);\n    this._lastFeeOperation = lastFeeOperation;\n    this._timeOfLatestBlock = timeOfLatestBlock;\n    this._recoveryMode = recoveryMode;\n    assert_1.default(this._minuteDecayFactor.lt(1));\n  }\n  /** @internal */\n\n\n  _setRecoveryMode(recoveryMode) {\n    return new Fees(this._baseRateWithoutDecay, this._minuteDecayFactor, this._beta, this._lastFeeOperation, this._timeOfLatestBlock, recoveryMode);\n  }\n  /**\n   * Compare to another instance of `Fees`.\n   */\n\n\n  equals(that) {\n    return this._baseRateWithoutDecay.eq(that._baseRateWithoutDecay) && this._minuteDecayFactor.eq(that._minuteDecayFactor) && this._beta.eq(that._beta) && this._lastFeeOperation.getTime() === that._lastFeeOperation.getTime() && this._timeOfLatestBlock.getTime() === that._timeOfLatestBlock.getTime() && this._recoveryMode === that._recoveryMode;\n  }\n  /** @internal */\n\n\n  toString() {\n    return `{ baseRateWithoutDecay: ${this._baseRateWithoutDecay}` + `, lastFeeOperation: \"${this._lastFeeOperation.toLocaleString()}\"` + `, recoveryMode: ${this._recoveryMode} } `;\n  }\n  /** @internal */\n\n\n  baseRate(when = this._timeOfLatestBlock) {\n    const millisecondsSinceLastFeeOperation = Math.max(when.getTime() - this._lastFeeOperation.getTime(), 0 // Clamp negative elapsed time to 0, in case the client's time is in the past.\n    // We will calculate slightly higher than actual fees, which is fine.\n    );\n    const minutesSinceLastFeeOperation = Math.floor(millisecondsSinceLastFeeOperation / 60000);\n    return this._minuteDecayFactor.pow(minutesSinceLastFeeOperation).mul(this._baseRateWithoutDecay);\n  }\n  /**\n   * Calculate the current borrowing rate.\n   *\n   * @param when - Optional timestamp that can be used to calculate what the borrowing rate would\n   *               decay to at a point of time in the future.\n   *\n   * @remarks\n   * By default, the fee is calculated at the time of the latest block. This can be overridden using\n   * the `when` parameter.\n   *\n   * To calculate the borrowing fee in LUSD, multiply the borrowed LUSD amount by the borrowing rate.\n   *\n   * @example\n   * ```typescript\n   * const fees = await liquity.getFees();\n   *\n   * const borrowedLUSDAmount = 100;\n   * const borrowingRate = fees.borrowingRate();\n   * const borrowingFeeLUSD = borrowingRate.mul(borrowedLUSDAmount);\n   * ```\n   */\n\n\n  borrowingRate(when) {\n    return this._recoveryMode ? Decimal_1.Decimal.ZERO : Decimal_1.Decimal.min(constants_1.MINIMUM_BORROWING_RATE.add(this.baseRate(when)), constants_1.MAXIMUM_BORROWING_RATE);\n  }\n  /**\n   * Calculate the current redemption rate.\n   *\n   * @param redeemedFractionOfSupply - The amount of LUSD being redeemed divided by the total supply.\n   * @param when - Optional timestamp that can be used to calculate what the redemption rate would\n   *               decay to at a point of time in the future.\n   *\n   * @remarks\n   * By default, the fee is calculated at the time of the latest block. This can be overridden using\n   * the `when` parameter.\n      * Unlike the borrowing rate, the redemption rate depends on the amount being redeemed. To be more\n   * precise, it depends on the fraction of the redeemed amount compared to the total LUSD supply,\n   * which must be passed as a parameter.\n   *\n   * To calculate the redemption fee in LUSD, multiply the redeemed LUSD amount with the redemption\n   * rate.\n   *\n   * @example\n   * ```typescript\n   * const fees = await liquity.getFees();\n   * const total = await liquity.getTotal();\n   *\n   * const redeemedLUSDAmount = Decimal.from(100);\n   * const redeemedFractionOfSupply = redeemedLUSDAmount.div(total.debt);\n   * const redemptionRate = fees.redemptionRate(redeemedFractionOfSupply);\n   * const redemptionFeeLUSD = redemptionRate.mul(redeemedLUSDAmount);\n   * ```\n   */\n\n\n  redemptionRate(redeemedFractionOfSupply = Decimal_1.Decimal.ZERO, when) {\n    redeemedFractionOfSupply = Decimal_1.Decimal.from(redeemedFractionOfSupply);\n    let baseRate = this.baseRate(when);\n\n    if (redeemedFractionOfSupply.nonZero) {\n      baseRate = redeemedFractionOfSupply.div(this._beta).add(baseRate);\n    }\n\n    return Decimal_1.Decimal.min(constants_1.MINIMUM_REDEMPTION_RATE.add(baseRate), Decimal_1.Decimal.ONE);\n  }\n\n}\n\nexports.Fees = Fees;","map":{"version":3,"sources":["../../src/Fees.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fees = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst Decimal_1 = require(\"./Decimal\");\nconst constants_1 = require(\"./constants\");\n/**\n * Calculator for fees.\n *\n * @remarks\n * Returned by the {@link ReadableLiquity.getFees | getFees()} function.\n *\n * @public\n */\nclass Fees {\n    /** @internal */\n    constructor(baseRateWithoutDecay, minuteDecayFactor, beta, lastFeeOperation, timeOfLatestBlock, recoveryMode) {\n        this._baseRateWithoutDecay = Decimal_1.Decimal.from(baseRateWithoutDecay);\n        this._minuteDecayFactor = Decimal_1.Decimal.from(minuteDecayFactor);\n        this._beta = Decimal_1.Decimal.from(beta);\n        this._lastFeeOperation = lastFeeOperation;\n        this._timeOfLatestBlock = timeOfLatestBlock;\n        this._recoveryMode = recoveryMode;\n        assert_1.default(this._minuteDecayFactor.lt(1));\n    }\n    /** @internal */\n    _setRecoveryMode(recoveryMode) {\n        return new Fees(this._baseRateWithoutDecay, this._minuteDecayFactor, this._beta, this._lastFeeOperation, this._timeOfLatestBlock, recoveryMode);\n    }\n    /**\n     * Compare to another instance of `Fees`.\n     */\n    equals(that) {\n        return (this._baseRateWithoutDecay.eq(that._baseRateWithoutDecay) &&\n            this._minuteDecayFactor.eq(that._minuteDecayFactor) &&\n            this._beta.eq(that._beta) &&\n            this._lastFeeOperation.getTime() === that._lastFeeOperation.getTime() &&\n            this._timeOfLatestBlock.getTime() === that._timeOfLatestBlock.getTime() &&\n            this._recoveryMode === that._recoveryMode);\n    }\n    /** @internal */\n    toString() {\n        return (`{ baseRateWithoutDecay: ${this._baseRateWithoutDecay}` +\n            `, lastFeeOperation: \"${this._lastFeeOperation.toLocaleString()}\"` +\n            `, recoveryMode: ${this._recoveryMode} } `);\n    }\n    /** @internal */\n    baseRate(when = this._timeOfLatestBlock) {\n        const millisecondsSinceLastFeeOperation = Math.max(when.getTime() - this._lastFeeOperation.getTime(), 0 // Clamp negative elapsed time to 0, in case the client's time is in the past.\n        // We will calculate slightly higher than actual fees, which is fine.\n        );\n        const minutesSinceLastFeeOperation = Math.floor(millisecondsSinceLastFeeOperation / 60000);\n        return this._minuteDecayFactor.pow(minutesSinceLastFeeOperation).mul(this._baseRateWithoutDecay);\n    }\n    /**\n     * Calculate the current borrowing rate.\n     *\n     * @param when - Optional timestamp that can be used to calculate what the borrowing rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n     *\n     * To calculate the borrowing fee in LUSD, multiply the borrowed LUSD amount by the borrowing rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     *\n     * const borrowedLUSDAmount = 100;\n     * const borrowingRate = fees.borrowingRate();\n     * const borrowingFeeLUSD = borrowingRate.mul(borrowedLUSDAmount);\n     * ```\n     */\n    borrowingRate(when) {\n        return this._recoveryMode\n            ? Decimal_1.Decimal.ZERO\n            : Decimal_1.Decimal.min(constants_1.MINIMUM_BORROWING_RATE.add(this.baseRate(when)), constants_1.MAXIMUM_BORROWING_RATE);\n    }\n    /**\n     * Calculate the current redemption rate.\n     *\n     * @param redeemedFractionOfSupply - The amount of LUSD being redeemed divided by the total supply.\n     * @param when - Optional timestamp that can be used to calculate what the redemption rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n  \n     * Unlike the borrowing rate, the redemption rate depends on the amount being redeemed. To be more\n     * precise, it depends on the fraction of the redeemed amount compared to the total LUSD supply,\n     * which must be passed as a parameter.\n     *\n     * To calculate the redemption fee in LUSD, multiply the redeemed LUSD amount with the redemption\n     * rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     * const total = await liquity.getTotal();\n     *\n     * const redeemedLUSDAmount = Decimal.from(100);\n     * const redeemedFractionOfSupply = redeemedLUSDAmount.div(total.debt);\n     * const redemptionRate = fees.redemptionRate(redeemedFractionOfSupply);\n     * const redemptionFeeLUSD = redemptionRate.mul(redeemedLUSDAmount);\n     * ```\n     */\n    redemptionRate(redeemedFractionOfSupply = Decimal_1.Decimal.ZERO, when) {\n        redeemedFractionOfSupply = Decimal_1.Decimal.from(redeemedFractionOfSupply);\n        let baseRate = this.baseRate(when);\n        if (redeemedFractionOfSupply.nonZero) {\n            baseRate = redeemedFractionOfSupply.div(this._beta).add(baseRate);\n        }\n        return Decimal_1.Decimal.min(constants_1.MINIMUM_REDEMPTION_RATE.add(baseRate), Decimal_1.Decimal.ONE);\n    }\n}\nexports.Fees = Fees;\n//# sourceMappingURL=Fees.js.map"]},"metadata":{},"sourceType":"script"}