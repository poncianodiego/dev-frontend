{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableEthersLiquity = void 0;\n\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nconst debouncingDelayMs = 50;\n\nconst debounce = listener => {\n  let timeoutId = undefined;\n  let latestBlock = 0;\n  return (...args) => {\n    const event = args[args.length - 1];\n\n    if (event.blockNumber !== undefined && event.blockNumber > latestBlock) {\n      latestBlock = event.blockNumber;\n    }\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      listener(latestBlock);\n      timeoutId = undefined;\n    }, debouncingDelayMs);\n  };\n};\n/** @alpha */\n\n\nclass ObservableEthersLiquity {\n  constructor(readable) {\n    this._readable = readable;\n  }\n\n  watchTotalRedistributed(onTotalRedistributedChanged) {\n    const {\n      activePool,\n      defaultPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const etherSent = activePool.filters.EtherSent();\n    const redistributionListener = debounce(blockTag => {\n      this._readable.getTotalRedistributed({\n        blockTag\n      }).then(onTotalRedistributedChanged);\n    });\n\n    const etherSentListener = (toAddress, _amount, event) => {\n      if (toAddress === defaultPool.address) {\n        redistributionListener(event);\n      }\n    };\n\n    activePool.on(etherSent, etherSentListener);\n    return () => {\n      activePool.removeListener(etherSent, etherSentListener);\n    };\n  }\n\n  watchTroveWithoutRewards(onTroveChanged, address) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n    const {\n      troveManager,\n      borrowerOperations\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const troveUpdatedByTroveManager = troveManager.filters.TroveUpdated(address);\n    const troveUpdatedByBorrowerOperations = borrowerOperations.filters.TroveUpdated(address);\n    const troveListener = debounce(blockTag => {\n      this._readable.getTroveBeforeRedistribution(address, {\n        blockTag\n      }).then(onTroveChanged);\n    });\n    troveManager.on(troveUpdatedByTroveManager, troveListener);\n    borrowerOperations.on(troveUpdatedByBorrowerOperations, troveListener);\n    return () => {\n      troveManager.removeListener(troveUpdatedByTroveManager, troveListener);\n      borrowerOperations.removeListener(troveUpdatedByBorrowerOperations, troveListener);\n    };\n  }\n\n  watchNumberOfTroves(onNumberOfTrovesChanged) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const {\n      TroveUpdated\n    } = troveManager.filters;\n    const troveUpdated = TroveUpdated();\n    const troveUpdatedListener = debounce(blockTag => {\n      this._readable.getNumberOfTroves({\n        blockTag\n      }).then(onNumberOfTrovesChanged);\n    });\n    troveManager.on(troveUpdated, troveUpdatedListener);\n    return () => {\n      troveManager.removeListener(troveUpdated, troveUpdatedListener);\n    };\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  watchPrice(onPriceChanged) {\n    // TODO revisit\n    // We no longer have our own PriceUpdated events. If we want to implement this in an event-based\n    // manner, we'll need to listen to aggregator events directly. Or we could do polling.\n    throw new Error(\"Method not implemented.\");\n  }\n\n  watchTotal(onTotalChanged) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const {\n      TroveUpdated\n    } = troveManager.filters;\n    const troveUpdated = TroveUpdated();\n    const totalListener = debounce(blockTag => {\n      this._readable.getTotal({\n        blockTag\n      }).then(onTotalChanged);\n    });\n    troveManager.on(troveUpdated, totalListener);\n    return () => {\n      troveManager.removeListener(troveUpdated, totalListener);\n    };\n  }\n\n  watchStabilityDeposit(onStabilityDepositChanged, address) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n    const {\n      activePool,\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const {\n      UserDepositChanged\n    } = stabilityPool.filters;\n    const {\n      EtherSent\n    } = activePool.filters;\n    const userDepositChanged = UserDepositChanged(address);\n    const etherSent = EtherSent();\n    const depositListener = debounce(blockTag => {\n      this._readable.getStabilityDeposit(address, {\n        blockTag\n      }).then(onStabilityDepositChanged);\n    });\n\n    const etherSentListener = (toAddress, _amount, event) => {\n      if (toAddress === stabilityPool.address) {\n        // Liquidation while Stability Pool has some deposits\n        // There may be new gains\n        depositListener(event);\n      }\n    };\n\n    stabilityPool.on(userDepositChanged, depositListener);\n    activePool.on(etherSent, etherSentListener);\n    return () => {\n      stabilityPool.removeListener(userDepositChanged, depositListener);\n      activePool.removeListener(etherSent, etherSentListener);\n    };\n  }\n\n  watchLUSDInStabilityPool(onLUSDInStabilityPoolChanged) {\n    const {\n      lusdToken,\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const {\n      Transfer\n    } = lusdToken.filters;\n    const transferLUSDFromStabilityPool = Transfer(stabilityPool.address);\n    const transferLUSDToStabilityPool = Transfer(null, stabilityPool.address);\n    const stabilityPoolLUSDFilters = [transferLUSDFromStabilityPool, transferLUSDToStabilityPool];\n    const stabilityPoolLUSDListener = debounce(blockTag => {\n      this._readable.getLUSDInStabilityPool({\n        blockTag\n      }).then(onLUSDInStabilityPoolChanged);\n    });\n    stabilityPoolLUSDFilters.forEach(filter => lusdToken.on(filter, stabilityPoolLUSDListener));\n    return () => stabilityPoolLUSDFilters.forEach(filter => lusdToken.removeListener(filter, stabilityPoolLUSDListener));\n  }\n\n  watchLUSDBalance(onLUSDBalanceChanged, address) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n    const {\n      lusdToken\n    } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n\n    const {\n      Transfer\n    } = lusdToken.filters;\n    const transferLUSDFromUser = Transfer(address);\n    const transferLUSDToUser = Transfer(null, address);\n    const lusdTransferFilters = [transferLUSDFromUser, transferLUSDToUser];\n    const lusdTransferListener = debounce(blockTag => {\n      this._readable.getLUSDBalance(address, {\n        blockTag\n      }).then(onLUSDBalanceChanged);\n    });\n    lusdTransferFilters.forEach(filter => lusdToken.on(filter, lusdTransferListener));\n    return () => lusdTransferFilters.forEach(filter => lusdToken.removeListener(filter, lusdTransferListener));\n  }\n\n}\n\nexports.ObservableEthersLiquity = ObservableEthersLiquity;","map":{"version":3,"sources":["../../src/ObservableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservableEthersLiquity = void 0;\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst debouncingDelayMs = 50;\nconst debounce = (listener) => {\n    let timeoutId = undefined;\n    let latestBlock = 0;\n    return (...args) => {\n        const event = args[args.length - 1];\n        if (event.blockNumber !== undefined && event.blockNumber > latestBlock) {\n            latestBlock = event.blockNumber;\n        }\n        if (timeoutId !== undefined) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            listener(latestBlock);\n            timeoutId = undefined;\n        }, debouncingDelayMs);\n    };\n};\n/** @alpha */\nclass ObservableEthersLiquity {\n    constructor(readable) {\n        this._readable = readable;\n    }\n    watchTotalRedistributed(onTotalRedistributedChanged) {\n        const { activePool, defaultPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const etherSent = activePool.filters.EtherSent();\n        const redistributionListener = debounce((blockTag) => {\n            this._readable.getTotalRedistributed({ blockTag }).then(onTotalRedistributedChanged);\n        });\n        const etherSentListener = (toAddress, _amount, event) => {\n            if (toAddress === defaultPool.address) {\n                redistributionListener(event);\n            }\n        };\n        activePool.on(etherSent, etherSentListener);\n        return () => {\n            activePool.removeListener(etherSent, etherSentListener);\n        };\n    }\n    watchTroveWithoutRewards(onTroveChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { troveManager, borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const troveUpdatedByTroveManager = troveManager.filters.TroveUpdated(address);\n        const troveUpdatedByBorrowerOperations = borrowerOperations.filters.TroveUpdated(address);\n        const troveListener = debounce((blockTag) => {\n            this._readable.getTroveBeforeRedistribution(address, { blockTag }).then(onTroveChanged);\n        });\n        troveManager.on(troveUpdatedByTroveManager, troveListener);\n        borrowerOperations.on(troveUpdatedByBorrowerOperations, troveListener);\n        return () => {\n            troveManager.removeListener(troveUpdatedByTroveManager, troveListener);\n            borrowerOperations.removeListener(troveUpdatedByBorrowerOperations, troveListener);\n        };\n    }\n    watchNumberOfTroves(onNumberOfTrovesChanged) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { TroveUpdated } = troveManager.filters;\n        const troveUpdated = TroveUpdated();\n        const troveUpdatedListener = debounce((blockTag) => {\n            this._readable.getNumberOfTroves({ blockTag }).then(onNumberOfTrovesChanged);\n        });\n        troveManager.on(troveUpdated, troveUpdatedListener);\n        return () => {\n            troveManager.removeListener(troveUpdated, troveUpdatedListener);\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    watchPrice(onPriceChanged) {\n        // TODO revisit\n        // We no longer have our own PriceUpdated events. If we want to implement this in an event-based\n        // manner, we'll need to listen to aggregator events directly. Or we could do polling.\n        throw new Error(\"Method not implemented.\");\n    }\n    watchTotal(onTotalChanged) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { TroveUpdated } = troveManager.filters;\n        const troveUpdated = TroveUpdated();\n        const totalListener = debounce((blockTag) => {\n            this._readable.getTotal({ blockTag }).then(onTotalChanged);\n        });\n        troveManager.on(troveUpdated, totalListener);\n        return () => {\n            troveManager.removeListener(troveUpdated, totalListener);\n        };\n    }\n    watchStabilityDeposit(onStabilityDepositChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { activePool, stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { UserDepositChanged } = stabilityPool.filters;\n        const { EtherSent } = activePool.filters;\n        const userDepositChanged = UserDepositChanged(address);\n        const etherSent = EtherSent();\n        const depositListener = debounce((blockTag) => {\n            this._readable.getStabilityDeposit(address, { blockTag }).then(onStabilityDepositChanged);\n        });\n        const etherSentListener = (toAddress, _amount, event) => {\n            if (toAddress === stabilityPool.address) {\n                // Liquidation while Stability Pool has some deposits\n                // There may be new gains\n                depositListener(event);\n            }\n        };\n        stabilityPool.on(userDepositChanged, depositListener);\n        activePool.on(etherSent, etherSentListener);\n        return () => {\n            stabilityPool.removeListener(userDepositChanged, depositListener);\n            activePool.removeListener(etherSent, etherSentListener);\n        };\n    }\n    watchLUSDInStabilityPool(onLUSDInStabilityPoolChanged) {\n        const { lusdToken, stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { Transfer } = lusdToken.filters;\n        const transferLUSDFromStabilityPool = Transfer(stabilityPool.address);\n        const transferLUSDToStabilityPool = Transfer(null, stabilityPool.address);\n        const stabilityPoolLUSDFilters = [transferLUSDFromStabilityPool, transferLUSDToStabilityPool];\n        const stabilityPoolLUSDListener = debounce((blockTag) => {\n            this._readable.getLUSDInStabilityPool({ blockTag }).then(onLUSDInStabilityPoolChanged);\n        });\n        stabilityPoolLUSDFilters.forEach(filter => lusdToken.on(filter, stabilityPoolLUSDListener));\n        return () => stabilityPoolLUSDFilters.forEach(filter => lusdToken.removeListener(filter, stabilityPoolLUSDListener));\n    }\n    watchLUSDBalance(onLUSDBalanceChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { Transfer } = lusdToken.filters;\n        const transferLUSDFromUser = Transfer(address);\n        const transferLUSDToUser = Transfer(null, address);\n        const lusdTransferFilters = [transferLUSDFromUser, transferLUSDToUser];\n        const lusdTransferListener = debounce((blockTag) => {\n            this._readable.getLUSDBalance(address, { blockTag }).then(onLUSDBalanceChanged);\n        });\n        lusdTransferFilters.forEach(filter => lusdToken.on(filter, lusdTransferListener));\n        return () => lusdTransferFilters.forEach(filter => lusdToken.removeListener(filter, lusdTransferListener));\n    }\n}\nexports.ObservableEthersLiquity = ObservableEthersLiquity;\n//# sourceMappingURL=ObservableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}