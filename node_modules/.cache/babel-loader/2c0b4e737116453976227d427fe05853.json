{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TroveWithPendingRedistribution = exports.UserTrove = exports._emptyTrove = exports.Trove = exports._normalizeTroveAdjustment = exports._normalizeTroveCreation = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst Decimal_1 = require(\"./Decimal\");\n\nconst constants_1 = require(\"./constants\");\n\nconst invalidTroveCreation = (invalidTrove, error) => ({\n  type: \"invalidCreation\",\n  invalidTrove,\n  error\n});\n\nconst troveCreation = params => ({\n  type: \"creation\",\n  params\n});\n\nconst troveClosure = params => ({\n  type: \"closure\",\n  params\n});\n\nconst troveAdjustment = (params, setToZero) => ({\n  type: \"adjustment\",\n  params,\n  setToZero\n});\n\nconst valueIsDefined = entry => entry[1] !== undefined;\n\nconst allowedTroveCreationKeys = [\"depositCollateral\", \"borrowLUSD\"];\n\nfunction checkAllowedTroveCreationKeys(entries) {\n  const badKeys = entries.filter(([k]) => !allowedTroveCreationKeys.includes(k)).map(([k]) => `'${k}'`);\n\n  if (badKeys.length > 0) {\n    throw new Error(`TroveCreationParams: property ${badKeys.join(\", \")} not allowed`);\n  }\n}\n\nconst troveCreationParamsFromEntries = entries => {\n  const params = Object.fromEntries(entries);\n  const missingKeys = allowedTroveCreationKeys.filter(k => !(k in params)).map(k => `'${k}'`);\n\n  if (missingKeys.length > 0) {\n    throw new Error(`TroveCreationParams: property ${missingKeys.join(\", \")} missing`);\n  }\n\n  return params;\n};\n\nconst decimalize = ([k, v]) => [k, Decimal_1.Decimal.from(v)];\n\nconst nonZero = ([, v]) => !v.isZero;\n/** @internal */\n\n\nconst _normalizeTroveCreation = params => {\n  const definedEntries = Object.entries(params).filter(valueIsDefined);\n  checkAllowedTroveCreationKeys(definedEntries);\n  const nonZeroEntries = definedEntries.map(decimalize);\n  return troveCreationParamsFromEntries(nonZeroEntries);\n};\n\nexports._normalizeTroveCreation = _normalizeTroveCreation;\nconst allowedTroveAdjustmentKeys = [\"depositCollateral\", \"withdrawCollateral\", \"borrowLUSD\", \"repayLUSD\"];\n\nfunction checkAllowedTroveAdjustmentKeys(entries) {\n  const badKeys = entries.filter(([k]) => !allowedTroveAdjustmentKeys.includes(k)).map(([k]) => `'${k}'`);\n\n  if (badKeys.length > 0) {\n    throw new Error(`TroveAdjustmentParams: property ${badKeys.join(\", \")} not allowed`);\n  }\n}\n\nconst collateralChangeFrom = ({\n  depositCollateral,\n  withdrawCollateral\n}) => {\n  if (depositCollateral !== undefined && withdrawCollateral !== undefined) {\n    throw new Error(\"TroveAdjustmentParams: 'depositCollateral' and 'withdrawCollateral' \" + \"can't be present at the same time\");\n  }\n\n  if (depositCollateral !== undefined) {\n    return {\n      depositCollateral\n    };\n  }\n\n  if (withdrawCollateral !== undefined) {\n    return {\n      withdrawCollateral\n    };\n  }\n};\n\nconst debtChangeFrom = ({\n  borrowLUSD,\n  repayLUSD\n}) => {\n  if (borrowLUSD !== undefined && repayLUSD !== undefined) {\n    throw new Error(\"TroveAdjustmentParams: 'borrowLUSD' and 'repayLUSD' can't be present at the same time\");\n  }\n\n  if (borrowLUSD !== undefined) {\n    return {\n      borrowLUSD\n    };\n  }\n\n  if (repayLUSD !== undefined) {\n    return {\n      repayLUSD\n    };\n  }\n};\n\nconst troveAdjustmentParamsFromEntries = entries => {\n  const params = Object.fromEntries(entries);\n  const collateralChange = collateralChangeFrom(params);\n  const debtChange = debtChangeFrom(params);\n\n  if (collateralChange !== undefined && debtChange !== undefined) {\n    return { ...collateralChange,\n      ...debtChange\n    };\n  }\n\n  if (collateralChange !== undefined) {\n    return collateralChange;\n  }\n\n  if (debtChange !== undefined) {\n    return debtChange;\n  }\n\n  throw new Error(\"TroveAdjustmentParams: must include at least one non-zero parameter\");\n};\n/** @internal */\n\n\nconst _normalizeTroveAdjustment = params => {\n  const definedEntries = Object.entries(params).filter(valueIsDefined);\n  checkAllowedTroveAdjustmentKeys(definedEntries);\n  const nonZeroEntries = definedEntries.map(decimalize).filter(nonZero);\n  return troveAdjustmentParamsFromEntries(nonZeroEntries);\n};\n\nexports._normalizeTroveAdjustment = _normalizeTroveAdjustment;\n\nconst applyFee = (borrowingRate, debtIncrease) => debtIncrease.mul(Decimal_1.Decimal.ONE.add(borrowingRate));\n\nconst unapplyFee = (borrowingRate, debtIncrease) => debtIncrease._divCeil(Decimal_1.Decimal.ONE.add(borrowingRate));\n\nconst NOMINAL_COLLATERAL_RATIO_PRECISION = Decimal_1.Decimal.from(100);\n/**\n * A combination of collateral and debt.\n *\n * @public\n */\n\nclass Trove {\n  /** @internal */\n  constructor(collateral = Decimal_1.Decimal.ZERO, debt = Decimal_1.Decimal.ZERO) {\n    this.collateral = collateral;\n    this.debt = debt;\n  }\n\n  get isEmpty() {\n    return this.collateral.isZero && this.debt.isZero;\n  }\n  /**\n   * Amount of LUSD that must be repaid to close this Trove.\n   *\n   * @remarks\n   * This doesn't include the liquidation reserve, which is refunded in case of normal closure.\n   */\n\n\n  get netDebt() {\n    if (this.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n      throw new Error(`netDebt should not be used when debt < ${constants_1.LUSD_LIQUIDATION_RESERVE}`);\n    }\n\n    return this.debt.sub(constants_1.LUSD_LIQUIDATION_RESERVE);\n  }\n  /** @internal */\n\n\n  get _nominalCollateralRatio() {\n    return this.collateral.mulDiv(NOMINAL_COLLATERAL_RATIO_PRECISION, this.debt);\n  }\n  /** Calculate the Trove's collateralization ratio at a given price. */\n\n\n  collateralRatio(price) {\n    return this.collateral.mulDiv(price, this.debt);\n  }\n  /**\n   * Whether the Trove is undercollateralized at a given price.\n   *\n   * @returns\n   * `true` if the Trove's collateralization ratio is less than the\n   * {@link MINIMUM_COLLATERAL_RATIO}.\n   */\n\n\n  collateralRatioIsBelowMinimum(price) {\n    return this.collateralRatio(price).lt(constants_1.MINIMUM_COLLATERAL_RATIO);\n  }\n  /**\n   * Whether the collateralization ratio is less than the {@link CRITICAL_COLLATERAL_RATIO} at a\n   * given price.\n   *\n   * @example\n   * Can be used to check whether the Liquity protocol is in recovery mode by using it on the return\n   * value of {@link ReadableLiquity.getTotal | getTotal()}. For example:\n   *\n   * ```typescript\n   * const total = await liquity.getTotal();\n   * const price = await liquity.getPrice();\n   *\n   * if (total.collateralRatioIsBelowCritical(price)) {\n   *   // Recovery mode is active\n   * }\n   * ```\n   */\n\n\n  collateralRatioIsBelowCritical(price) {\n    return this.collateralRatio(price).lt(constants_1.CRITICAL_COLLATERAL_RATIO);\n  }\n  /** Whether the Trove is sufficiently collateralized to be opened during recovery mode. */\n\n\n  isOpenableInRecoveryMode(price) {\n    return this.collateralRatio(price).gte(constants_1.CRITICAL_COLLATERAL_RATIO);\n  }\n  /** @internal */\n\n\n  toString() {\n    return `{ collateral: ${this.collateral}, debt: ${this.debt} }`;\n  }\n\n  equals(that) {\n    return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);\n  }\n\n  add(that) {\n    return new Trove(this.collateral.add(that.collateral), this.debt.add(that.debt));\n  }\n\n  addCollateral(collateral) {\n    return new Trove(this.collateral.add(collateral), this.debt);\n  }\n\n  addDebt(debt) {\n    return new Trove(this.collateral, this.debt.add(debt));\n  }\n\n  subtract(that) {\n    const {\n      collateral,\n      debt\n    } = that;\n    return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n  }\n\n  subtractCollateral(collateral) {\n    return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt);\n  }\n\n  subtractDebt(debt) {\n    return new Trove(this.collateral, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n  }\n\n  multiply(multiplier) {\n    return new Trove(this.collateral.mul(multiplier), this.debt.mul(multiplier));\n  }\n\n  setCollateral(collateral) {\n    return new Trove(Decimal_1.Decimal.from(collateral), this.debt);\n  }\n\n  setDebt(debt) {\n    return new Trove(this.collateral, Decimal_1.Decimal.from(debt));\n  }\n\n  _debtChange({\n    debt\n  }, borrowingRate) {\n    return debt.gt(this.debt) ? {\n      borrowLUSD: unapplyFee(borrowingRate, debt.sub(this.debt))\n    } : {\n      repayLUSD: this.debt.sub(debt)\n    };\n  }\n\n  _collateralChange({\n    collateral\n  }) {\n    return collateral.gt(this.collateral) ? {\n      depositCollateral: collateral.sub(this.collateral)\n    } : {\n      withdrawCollateral: this.collateral.sub(collateral)\n    };\n  }\n  /**\n   * Calculate the difference between this Trove and another.\n   *\n   * @param that - The other Trove.\n   * @param borrowingRate - Borrowing rate to use when calculating a borrowed amount.\n   *\n   * @returns\n   * An object representing the change, or `undefined` if the Troves are equal.\n   */\n\n\n  whatChanged(that, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n    var _a;\n\n    if (this.collateral.eq(that.collateral) && this.debt.eq(that.debt)) {\n      return undefined;\n    }\n\n    if (this.isEmpty) {\n      if (that.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n        return invalidTroveCreation(that, \"missingLiquidationReserve\");\n      }\n\n      return troveCreation({\n        depositCollateral: that.collateral,\n        borrowLUSD: unapplyFee(borrowingRate, that.netDebt)\n      });\n    }\n\n    if (that.isEmpty) {\n      return troveClosure(this.netDebt.nonZero ? {\n        withdrawCollateral: this.collateral,\n        repayLUSD: this.netDebt\n      } : {\n        withdrawCollateral: this.collateral\n      });\n    }\n\n    return this.collateral.eq(that.collateral) ? troveAdjustment(this._debtChange(that, borrowingRate), that.debt.zero && \"debt\") : this.debt.eq(that.debt) ? troveAdjustment(this._collateralChange(that), that.collateral.zero && \"collateral\") : troveAdjustment({ ...this._debtChange(that, borrowingRate),\n      ...this._collateralChange(that)\n    }, (_a = that.debt.zero && \"debt\") !== null && _a !== void 0 ? _a : that.collateral.zero && \"collateral\");\n  }\n  /**\n   * Make a new Trove by applying a {@link TroveChange} to this Trove.\n   *\n   * @param change - The change to apply.\n   * @param borrowingRate - Borrowing rate to use when adding a borrowed amount to the Trove's debt.\n   */\n\n\n  apply(change, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n    if (!change) {\n      return this;\n    }\n\n    switch (change.type) {\n      case \"invalidCreation\":\n        if (!this.isEmpty) {\n          throw new Error(\"Can't create onto existing Trove\");\n        }\n\n        return change.invalidTrove;\n\n      case \"creation\":\n        {\n          if (!this.isEmpty) {\n            throw new Error(\"Can't create onto existing Trove\");\n          }\n\n          const {\n            depositCollateral,\n            borrowLUSD\n          } = change.params;\n          return new Trove(depositCollateral, constants_1.LUSD_LIQUIDATION_RESERVE.add(applyFee(borrowingRate, borrowLUSD)));\n        }\n\n      case \"closure\":\n        if (this.isEmpty) {\n          throw new Error(\"Can't close empty Trove\");\n        }\n\n        return exports._emptyTrove;\n\n      case \"adjustment\":\n        {\n          const {\n            setToZero,\n            params: {\n              depositCollateral,\n              withdrawCollateral,\n              borrowLUSD,\n              repayLUSD\n            }\n          } = change;\n          const collateralDecrease = withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : Decimal_1.Decimal.ZERO;\n          const collateralIncrease = depositCollateral !== null && depositCollateral !== void 0 ? depositCollateral : Decimal_1.Decimal.ZERO;\n          const debtDecrease = repayLUSD !== null && repayLUSD !== void 0 ? repayLUSD : Decimal_1.Decimal.ZERO;\n          const debtIncrease = borrowLUSD ? applyFee(borrowingRate, borrowLUSD) : Decimal_1.Decimal.ZERO;\n          return setToZero === \"collateral\" ? this.setCollateral(Decimal_1.Decimal.ZERO).addDebt(debtIncrease).subtractDebt(debtDecrease) : setToZero === \"debt\" ? this.setDebt(Decimal_1.Decimal.ZERO).addCollateral(collateralIncrease).subtractCollateral(collateralDecrease) : this.add(new Trove(collateralIncrease, debtIncrease)).subtract(new Trove(collateralDecrease, debtDecrease));\n        }\n    }\n  }\n  /**\n   * Calculate the result of an {@link TransactableLiquity.openTrove | openTrove()} transaction.\n   *\n   * @param params - Parameters of the transaction.\n   * @param borrowingRate - Borrowing rate to use when calculating the Trove's debt.\n   */\n\n\n  static create(params, borrowingRate) {\n    return exports._emptyTrove.apply(troveCreation(exports._normalizeTroveCreation(params)), borrowingRate);\n  }\n  /**\n   * Calculate the parameters of an {@link TransactableLiquity.openTrove | openTrove()} transaction\n   * that will result in the given Trove.\n   *\n   * @param that - The Trove to recreate.\n   * @param borrowingRate - Current borrowing rate.\n   */\n\n\n  static recreate(that, borrowingRate) {\n    const change = exports._emptyTrove.whatChanged(that, borrowingRate);\n\n    assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"creation\");\n    return change.params;\n  }\n  /**\n   * Calculate the result of an {@link TransactableLiquity.adjustTrove | adjustTrove()} transaction\n   * on this Trove.\n   *\n   * @param params - Parameters of the transaction.\n   * @param borrowingRate - Borrowing rate to use when adding to the Trove's debt.\n   */\n\n\n  adjust(params, borrowingRate) {\n    return this.apply(troveAdjustment(exports._normalizeTroveAdjustment(params)), borrowingRate);\n  }\n  /**\n   * Calculate the parameters of an {@link TransactableLiquity.adjustTrove | adjustTrove()}\n   * transaction that will change this Trove into the given Trove.\n   *\n   * @param that - The desired result of the transaction.\n   * @param borrowingRate - Current borrowing rate.\n   */\n\n\n  adjustTo(that, borrowingRate) {\n    const change = this.whatChanged(that, borrowingRate);\n    assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"adjustment\");\n    return change.params;\n  }\n\n}\n\nexports.Trove = Trove;\n/** @internal */\n\nexports._emptyTrove = new Trove();\n/**\n * A Trove that is associated with a single owner.\n *\n * @remarks\n * The SDK uses the base {@link Trove} class as a generic container of collateral and debt, for\n * example to represent the {@link ReadableLiquity.getTotal | total collateral and debt} locked up\n * in the protocol.\n *\n * The `UserTrove` class extends `Trove` with extra information that's only available for Troves\n * that are associated with a single owner (such as the owner's address, or the Trove's status).\n *\n * @public\n */\n\nclass UserTrove extends Trove {\n  /** @internal */\n  constructor(ownerAddress, status, collateral, debt) {\n    super(collateral, debt);\n    this.ownerAddress = ownerAddress;\n    this.status = status;\n  }\n\n  equals(that) {\n    return super.equals(that) && this.ownerAddress === that.ownerAddress && this.status === that.status;\n  }\n  /** @internal */\n\n\n  toString() {\n    return `{ ownerAddress: \"${this.ownerAddress}\"` + `, collateral: ${this.collateral}` + `, debt: ${this.debt}` + `, status: \"${this.status}\" }`;\n  }\n\n}\n\nexports.UserTrove = UserTrove;\n/**\n * A Trove in its state after the last direct modification.\n *\n * @remarks\n * The Trove may have received collateral and debt shares from liquidations since then.\n * Use {@link TroveWithPendingRedistribution.applyRedistribution | applyRedistribution()} to\n * calculate the Trove's most up-to-date state.\n *\n * @public\n */\n\nclass TroveWithPendingRedistribution extends UserTrove {\n  /** @internal */\n  constructor(ownerAddress, status, collateral, debt, stake = Decimal_1.Decimal.ZERO, snapshotOfTotalRedistributed = exports._emptyTrove) {\n    super(ownerAddress, status, collateral, debt);\n    this.stake = stake;\n    this.snapshotOfTotalRedistributed = snapshotOfTotalRedistributed;\n  }\n\n  applyRedistribution(totalRedistributed) {\n    const afterRedistribution = this.add(totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake));\n    return new UserTrove(this.ownerAddress, this.status, afterRedistribution.collateral, afterRedistribution.debt);\n  }\n\n  equals(that) {\n    return super.equals(that) && this.stake.eq(that.stake) && this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed);\n  }\n\n}\n\nexports.TroveWithPendingRedistribution = TroveWithPendingRedistribution;","map":{"version":3,"sources":["../../src/Trove.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TroveWithPendingRedistribution = exports.UserTrove = exports._emptyTrove = exports.Trove = exports._normalizeTroveAdjustment = exports._normalizeTroveCreation = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst Decimal_1 = require(\"./Decimal\");\nconst constants_1 = require(\"./constants\");\nconst invalidTroveCreation = (invalidTrove, error) => ({\n    type: \"invalidCreation\",\n    invalidTrove,\n    error\n});\nconst troveCreation = (params) => ({\n    type: \"creation\",\n    params\n});\nconst troveClosure = (params) => ({\n    type: \"closure\",\n    params\n});\nconst troveAdjustment = (params, setToZero) => ({\n    type: \"adjustment\",\n    params,\n    setToZero\n});\nconst valueIsDefined = (entry) => entry[1] !== undefined;\nconst allowedTroveCreationKeys = [\n    \"depositCollateral\",\n    \"borrowLUSD\"\n];\nfunction checkAllowedTroveCreationKeys(entries) {\n    const badKeys = entries\n        .filter(([k]) => !allowedTroveCreationKeys.includes(k))\n        .map(([k]) => `'${k}'`);\n    if (badKeys.length > 0) {\n        throw new Error(`TroveCreationParams: property ${badKeys.join(\", \")} not allowed`);\n    }\n}\nconst troveCreationParamsFromEntries = (entries) => {\n    const params = Object.fromEntries(entries);\n    const missingKeys = allowedTroveCreationKeys.filter(k => !(k in params)).map(k => `'${k}'`);\n    if (missingKeys.length > 0) {\n        throw new Error(`TroveCreationParams: property ${missingKeys.join(\", \")} missing`);\n    }\n    return params;\n};\nconst decimalize = ([k, v]) => [k, Decimal_1.Decimal.from(v)];\nconst nonZero = ([, v]) => !v.isZero;\n/** @internal */\nconst _normalizeTroveCreation = (params) => {\n    const definedEntries = Object.entries(params).filter(valueIsDefined);\n    checkAllowedTroveCreationKeys(definedEntries);\n    const nonZeroEntries = definedEntries.map(decimalize);\n    return troveCreationParamsFromEntries(nonZeroEntries);\n};\nexports._normalizeTroveCreation = _normalizeTroveCreation;\nconst allowedTroveAdjustmentKeys = [\n    \"depositCollateral\",\n    \"withdrawCollateral\",\n    \"borrowLUSD\",\n    \"repayLUSD\"\n];\nfunction checkAllowedTroveAdjustmentKeys(entries) {\n    const badKeys = entries\n        .filter(([k]) => !allowedTroveAdjustmentKeys.includes(k))\n        .map(([k]) => `'${k}'`);\n    if (badKeys.length > 0) {\n        throw new Error(`TroveAdjustmentParams: property ${badKeys.join(\", \")} not allowed`);\n    }\n}\nconst collateralChangeFrom = ({ depositCollateral, withdrawCollateral }) => {\n    if (depositCollateral !== undefined && withdrawCollateral !== undefined) {\n        throw new Error(\"TroveAdjustmentParams: 'depositCollateral' and 'withdrawCollateral' \" +\n            \"can't be present at the same time\");\n    }\n    if (depositCollateral !== undefined) {\n        return { depositCollateral };\n    }\n    if (withdrawCollateral !== undefined) {\n        return { withdrawCollateral };\n    }\n};\nconst debtChangeFrom = ({ borrowLUSD, repayLUSD }) => {\n    if (borrowLUSD !== undefined && repayLUSD !== undefined) {\n        throw new Error(\"TroveAdjustmentParams: 'borrowLUSD' and 'repayLUSD' can't be present at the same time\");\n    }\n    if (borrowLUSD !== undefined) {\n        return { borrowLUSD };\n    }\n    if (repayLUSD !== undefined) {\n        return { repayLUSD };\n    }\n};\nconst troveAdjustmentParamsFromEntries = (entries) => {\n    const params = Object.fromEntries(entries);\n    const collateralChange = collateralChangeFrom(params);\n    const debtChange = debtChangeFrom(params);\n    if (collateralChange !== undefined && debtChange !== undefined) {\n        return { ...collateralChange, ...debtChange };\n    }\n    if (collateralChange !== undefined) {\n        return collateralChange;\n    }\n    if (debtChange !== undefined) {\n        return debtChange;\n    }\n    throw new Error(\"TroveAdjustmentParams: must include at least one non-zero parameter\");\n};\n/** @internal */\nconst _normalizeTroveAdjustment = (params) => {\n    const definedEntries = Object.entries(params).filter(valueIsDefined);\n    checkAllowedTroveAdjustmentKeys(definedEntries);\n    const nonZeroEntries = definedEntries.map(decimalize).filter(nonZero);\n    return troveAdjustmentParamsFromEntries(nonZeroEntries);\n};\nexports._normalizeTroveAdjustment = _normalizeTroveAdjustment;\nconst applyFee = (borrowingRate, debtIncrease) => debtIncrease.mul(Decimal_1.Decimal.ONE.add(borrowingRate));\nconst unapplyFee = (borrowingRate, debtIncrease) => debtIncrease._divCeil(Decimal_1.Decimal.ONE.add(borrowingRate));\nconst NOMINAL_COLLATERAL_RATIO_PRECISION = Decimal_1.Decimal.from(100);\n/**\n * A combination of collateral and debt.\n *\n * @public\n */\nclass Trove {\n    /** @internal */\n    constructor(collateral = Decimal_1.Decimal.ZERO, debt = Decimal_1.Decimal.ZERO) {\n        this.collateral = collateral;\n        this.debt = debt;\n    }\n    get isEmpty() {\n        return this.collateral.isZero && this.debt.isZero;\n    }\n    /**\n     * Amount of LUSD that must be repaid to close this Trove.\n     *\n     * @remarks\n     * This doesn't include the liquidation reserve, which is refunded in case of normal closure.\n     */\n    get netDebt() {\n        if (this.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n            throw new Error(`netDebt should not be used when debt < ${constants_1.LUSD_LIQUIDATION_RESERVE}`);\n        }\n        return this.debt.sub(constants_1.LUSD_LIQUIDATION_RESERVE);\n    }\n    /** @internal */\n    get _nominalCollateralRatio() {\n        return this.collateral.mulDiv(NOMINAL_COLLATERAL_RATIO_PRECISION, this.debt);\n    }\n    /** Calculate the Trove's collateralization ratio at a given price. */\n    collateralRatio(price) {\n        return this.collateral.mulDiv(price, this.debt);\n    }\n    /**\n     * Whether the Trove is undercollateralized at a given price.\n     *\n     * @returns\n     * `true` if the Trove's collateralization ratio is less than the\n     * {@link MINIMUM_COLLATERAL_RATIO}.\n     */\n    collateralRatioIsBelowMinimum(price) {\n        return this.collateralRatio(price).lt(constants_1.MINIMUM_COLLATERAL_RATIO);\n    }\n    /**\n     * Whether the collateralization ratio is less than the {@link CRITICAL_COLLATERAL_RATIO} at a\n     * given price.\n     *\n     * @example\n     * Can be used to check whether the Liquity protocol is in recovery mode by using it on the return\n     * value of {@link ReadableLiquity.getTotal | getTotal()}. For example:\n     *\n     * ```typescript\n     * const total = await liquity.getTotal();\n     * const price = await liquity.getPrice();\n     *\n     * if (total.collateralRatioIsBelowCritical(price)) {\n     *   // Recovery mode is active\n     * }\n     * ```\n     */\n    collateralRatioIsBelowCritical(price) {\n        return this.collateralRatio(price).lt(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** Whether the Trove is sufficiently collateralized to be opened during recovery mode. */\n    isOpenableInRecoveryMode(price) {\n        return this.collateralRatio(price).gte(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** @internal */\n    toString() {\n        return `{ collateral: ${this.collateral}, debt: ${this.debt} }`;\n    }\n    equals(that) {\n        return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);\n    }\n    add(that) {\n        return new Trove(this.collateral.add(that.collateral), this.debt.add(that.debt));\n    }\n    addCollateral(collateral) {\n        return new Trove(this.collateral.add(collateral), this.debt);\n    }\n    addDebt(debt) {\n        return new Trove(this.collateral, this.debt.add(debt));\n    }\n    subtract(that) {\n        const { collateral, debt } = that;\n        return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n    subtractCollateral(collateral) {\n        return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt);\n    }\n    subtractDebt(debt) {\n        return new Trove(this.collateral, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n    multiply(multiplier) {\n        return new Trove(this.collateral.mul(multiplier), this.debt.mul(multiplier));\n    }\n    setCollateral(collateral) {\n        return new Trove(Decimal_1.Decimal.from(collateral), this.debt);\n    }\n    setDebt(debt) {\n        return new Trove(this.collateral, Decimal_1.Decimal.from(debt));\n    }\n    _debtChange({ debt }, borrowingRate) {\n        return debt.gt(this.debt)\n            ? { borrowLUSD: unapplyFee(borrowingRate, debt.sub(this.debt)) }\n            : { repayLUSD: this.debt.sub(debt) };\n    }\n    _collateralChange({ collateral }) {\n        return collateral.gt(this.collateral)\n            ? { depositCollateral: collateral.sub(this.collateral) }\n            : { withdrawCollateral: this.collateral.sub(collateral) };\n    }\n    /**\n     * Calculate the difference between this Trove and another.\n     *\n     * @param that - The other Trove.\n     * @param borrowingRate - Borrowing rate to use when calculating a borrowed amount.\n     *\n     * @returns\n     * An object representing the change, or `undefined` if the Troves are equal.\n     */\n    whatChanged(that, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n        var _a;\n        if (this.collateral.eq(that.collateral) && this.debt.eq(that.debt)) {\n            return undefined;\n        }\n        if (this.isEmpty) {\n            if (that.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n                return invalidTroveCreation(that, \"missingLiquidationReserve\");\n            }\n            return troveCreation({\n                depositCollateral: that.collateral,\n                borrowLUSD: unapplyFee(borrowingRate, that.netDebt)\n            });\n        }\n        if (that.isEmpty) {\n            return troveClosure(this.netDebt.nonZero\n                ? { withdrawCollateral: this.collateral, repayLUSD: this.netDebt }\n                : { withdrawCollateral: this.collateral });\n        }\n        return this.collateral.eq(that.collateral)\n            ? troveAdjustment(this._debtChange(that, borrowingRate), that.debt.zero && \"debt\")\n            : this.debt.eq(that.debt)\n                ? troveAdjustment(this._collateralChange(that), that.collateral.zero && \"collateral\")\n                : troveAdjustment({\n                    ...this._debtChange(that, borrowingRate),\n                    ...this._collateralChange(that)\n                }, (_a = (that.debt.zero && \"debt\")) !== null && _a !== void 0 ? _a : (that.collateral.zero && \"collateral\"));\n    }\n    /**\n     * Make a new Trove by applying a {@link TroveChange} to this Trove.\n     *\n     * @param change - The change to apply.\n     * @param borrowingRate - Borrowing rate to use when adding a borrowed amount to the Trove's debt.\n     */\n    apply(change, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n        if (!change) {\n            return this;\n        }\n        switch (change.type) {\n            case \"invalidCreation\":\n                if (!this.isEmpty) {\n                    throw new Error(\"Can't create onto existing Trove\");\n                }\n                return change.invalidTrove;\n            case \"creation\": {\n                if (!this.isEmpty) {\n                    throw new Error(\"Can't create onto existing Trove\");\n                }\n                const { depositCollateral, borrowLUSD } = change.params;\n                return new Trove(depositCollateral, constants_1.LUSD_LIQUIDATION_RESERVE.add(applyFee(borrowingRate, borrowLUSD)));\n            }\n            case \"closure\":\n                if (this.isEmpty) {\n                    throw new Error(\"Can't close empty Trove\");\n                }\n                return exports._emptyTrove;\n            case \"adjustment\": {\n                const { setToZero, params: { depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD } } = change;\n                const collateralDecrease = withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : Decimal_1.Decimal.ZERO;\n                const collateralIncrease = depositCollateral !== null && depositCollateral !== void 0 ? depositCollateral : Decimal_1.Decimal.ZERO;\n                const debtDecrease = repayLUSD !== null && repayLUSD !== void 0 ? repayLUSD : Decimal_1.Decimal.ZERO;\n                const debtIncrease = borrowLUSD ? applyFee(borrowingRate, borrowLUSD) : Decimal_1.Decimal.ZERO;\n                return setToZero === \"collateral\"\n                    ? this.setCollateral(Decimal_1.Decimal.ZERO).addDebt(debtIncrease).subtractDebt(debtDecrease)\n                    : setToZero === \"debt\"\n                        ? this.setDebt(Decimal_1.Decimal.ZERO)\n                            .addCollateral(collateralIncrease)\n                            .subtractCollateral(collateralDecrease)\n                        : this.add(new Trove(collateralIncrease, debtIncrease)).subtract(new Trove(collateralDecrease, debtDecrease));\n            }\n        }\n    }\n    /**\n     * Calculate the result of an {@link TransactableLiquity.openTrove | openTrove()} transaction.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when calculating the Trove's debt.\n     */\n    static create(params, borrowingRate) {\n        return exports._emptyTrove.apply(troveCreation(exports._normalizeTroveCreation(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.openTrove | openTrove()} transaction\n     * that will result in the given Trove.\n     *\n     * @param that - The Trove to recreate.\n     * @param borrowingRate - Current borrowing rate.\n     */\n    static recreate(that, borrowingRate) {\n        const change = exports._emptyTrove.whatChanged(that, borrowingRate);\n        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"creation\");\n        return change.params;\n    }\n    /**\n     * Calculate the result of an {@link TransactableLiquity.adjustTrove | adjustTrove()} transaction\n     * on this Trove.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when adding to the Trove's debt.\n     */\n    adjust(params, borrowingRate) {\n        return this.apply(troveAdjustment(exports._normalizeTroveAdjustment(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.adjustTrove | adjustTrove()}\n     * transaction that will change this Trove into the given Trove.\n     *\n     * @param that - The desired result of the transaction.\n     * @param borrowingRate - Current borrowing rate.\n     */\n    adjustTo(that, borrowingRate) {\n        const change = this.whatChanged(that, borrowingRate);\n        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"adjustment\");\n        return change.params;\n    }\n}\nexports.Trove = Trove;\n/** @internal */\nexports._emptyTrove = new Trove();\n/**\n * A Trove that is associated with a single owner.\n *\n * @remarks\n * The SDK uses the base {@link Trove} class as a generic container of collateral and debt, for\n * example to represent the {@link ReadableLiquity.getTotal | total collateral and debt} locked up\n * in the protocol.\n *\n * The `UserTrove` class extends `Trove` with extra information that's only available for Troves\n * that are associated with a single owner (such as the owner's address, or the Trove's status).\n *\n * @public\n */\nclass UserTrove extends Trove {\n    /** @internal */\n    constructor(ownerAddress, status, collateral, debt) {\n        super(collateral, debt);\n        this.ownerAddress = ownerAddress;\n        this.status = status;\n    }\n    equals(that) {\n        return (super.equals(that) && this.ownerAddress === that.ownerAddress && this.status === that.status);\n    }\n    /** @internal */\n    toString() {\n        return (`{ ownerAddress: \"${this.ownerAddress}\"` +\n            `, collateral: ${this.collateral}` +\n            `, debt: ${this.debt}` +\n            `, status: \"${this.status}\" }`);\n    }\n}\nexports.UserTrove = UserTrove;\n/**\n * A Trove in its state after the last direct modification.\n *\n * @remarks\n * The Trove may have received collateral and debt shares from liquidations since then.\n * Use {@link TroveWithPendingRedistribution.applyRedistribution | applyRedistribution()} to\n * calculate the Trove's most up-to-date state.\n *\n * @public\n */\nclass TroveWithPendingRedistribution extends UserTrove {\n    /** @internal */\n    constructor(ownerAddress, status, collateral, debt, stake = Decimal_1.Decimal.ZERO, snapshotOfTotalRedistributed = exports._emptyTrove) {\n        super(ownerAddress, status, collateral, debt);\n        this.stake = stake;\n        this.snapshotOfTotalRedistributed = snapshotOfTotalRedistributed;\n    }\n    applyRedistribution(totalRedistributed) {\n        const afterRedistribution = this.add(totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake));\n        return new UserTrove(this.ownerAddress, this.status, afterRedistribution.collateral, afterRedistribution.debt);\n    }\n    equals(that) {\n        return (super.equals(that) &&\n            this.stake.eq(that.stake) &&\n            this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed));\n    }\n}\nexports.TroveWithPendingRedistribution = TroveWithPendingRedistribution;\n//# sourceMappingURL=Trove.js.map"]},"metadata":{},"sourceType":"script"}