{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fees = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar Decimal_1 = require(\"./Decimal\");\n\nvar constants_1 = require(\"./constants\");\n/**\n * Calculator for fees.\n *\n * @remarks\n * Returned by the {@link ReadableLiquity.getFees | getFees()} function.\n *\n * @public\n */\n\n\nvar Fees = /*#__PURE__*/function () {\n  /** @internal */\n  function Fees(baseRateWithoutDecay, minuteDecayFactor, beta, lastFeeOperation, timeOfLatestBlock, recoveryMode) {\n    _classCallCheck(this, Fees);\n\n    this._baseRateWithoutDecay = Decimal_1.Decimal.from(baseRateWithoutDecay);\n    this._minuteDecayFactor = Decimal_1.Decimal.from(minuteDecayFactor);\n    this._beta = Decimal_1.Decimal.from(beta);\n    this._lastFeeOperation = lastFeeOperation;\n    this._timeOfLatestBlock = timeOfLatestBlock;\n    this._recoveryMode = recoveryMode;\n    assert_1.default(this._minuteDecayFactor.lt(1));\n  }\n  /** @internal */\n\n\n  _createClass(Fees, [{\n    key: \"_setRecoveryMode\",\n    value: function _setRecoveryMode(recoveryMode) {\n      return new Fees(this._baseRateWithoutDecay, this._minuteDecayFactor, this._beta, this._lastFeeOperation, this._timeOfLatestBlock, recoveryMode);\n    }\n    /**\n     * Compare to another instance of `Fees`.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(that) {\n      return this._baseRateWithoutDecay.eq(that._baseRateWithoutDecay) && this._minuteDecayFactor.eq(that._minuteDecayFactor) && this._beta.eq(that._beta) && this._lastFeeOperation.getTime() === that._lastFeeOperation.getTime() && this._timeOfLatestBlock.getTime() === that._timeOfLatestBlock.getTime() && this._recoveryMode === that._recoveryMode;\n    }\n    /** @internal */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"{ baseRateWithoutDecay: \".concat(this._baseRateWithoutDecay) + \", lastFeeOperation: \\\"\".concat(this._lastFeeOperation.toLocaleString(), \"\\\"\") + \", recoveryMode: \".concat(this._recoveryMode, \" } \");\n    }\n    /** @internal */\n\n  }, {\n    key: \"baseRate\",\n    value: function baseRate() {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._timeOfLatestBlock;\n      var millisecondsSinceLastFeeOperation = Math.max(when.getTime() - this._lastFeeOperation.getTime(), 0 // Clamp negative elapsed time to 0, in case the client's time is in the past.\n      // We will calculate slightly higher than actual fees, which is fine.\n      );\n      var minutesSinceLastFeeOperation = Math.floor(millisecondsSinceLastFeeOperation / 60000);\n      return this._minuteDecayFactor.pow(minutesSinceLastFeeOperation).mul(this._baseRateWithoutDecay);\n    }\n    /**\n     * Calculate the current borrowing rate.\n     *\n     * @param when - Optional timestamp that can be used to calculate what the borrowing rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n     *\n     * To calculate the borrowing fee in LUSD, multiply the borrowed LUSD amount by the borrowing rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     *\n     * const borrowedLUSDAmount = 100;\n     * const borrowingRate = fees.borrowingRate();\n     * const borrowingFeeLUSD = borrowingRate.mul(borrowedLUSDAmount);\n     * ```\n     */\n\n  }, {\n    key: \"borrowingRate\",\n    value: function borrowingRate(when) {\n      return this._recoveryMode ? Decimal_1.Decimal.ZERO : Decimal_1.Decimal.min(constants_1.MINIMUM_BORROWING_RATE.add(this.baseRate(when)), constants_1.MAXIMUM_BORROWING_RATE);\n    }\n    /**\n     * Calculate the current redemption rate.\n     *\n     * @param redeemedFractionOfSupply - The amount of LUSD being redeemed divided by the total supply.\n     * @param when - Optional timestamp that can be used to calculate what the redemption rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n        * Unlike the borrowing rate, the redemption rate depends on the amount being redeemed. To be more\n     * precise, it depends on the fraction of the redeemed amount compared to the total LUSD supply,\n     * which must be passed as a parameter.\n     *\n     * To calculate the redemption fee in LUSD, multiply the redeemed LUSD amount with the redemption\n     * rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     * const total = await liquity.getTotal();\n     *\n     * const redeemedLUSDAmount = Decimal.from(100);\n     * const redeemedFractionOfSupply = redeemedLUSDAmount.div(total.debt);\n     * const redemptionRate = fees.redemptionRate(redeemedFractionOfSupply);\n     * const redemptionFeeLUSD = redemptionRate.mul(redeemedLUSDAmount);\n     * ```\n     */\n\n  }, {\n    key: \"redemptionRate\",\n    value: function redemptionRate() {\n      var redeemedFractionOfSupply = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Decimal_1.Decimal.ZERO;\n      var when = arguments.length > 1 ? arguments[1] : undefined;\n      redeemedFractionOfSupply = Decimal_1.Decimal.from(redeemedFractionOfSupply);\n      var baseRate = this.baseRate(when);\n\n      if (redeemedFractionOfSupply.nonZero) {\n        baseRate = redeemedFractionOfSupply.div(this._beta).add(baseRate);\n      }\n\n      return Decimal_1.Decimal.min(constants_1.MINIMUM_REDEMPTION_RATE.add(baseRate), Decimal_1.Decimal.ONE);\n    }\n  }]);\n\n  return Fees;\n}();\n\nexports.Fees = Fees;","map":{"version":3,"sources":["../../src/Fees.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fees = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst Decimal_1 = require(\"./Decimal\");\nconst constants_1 = require(\"./constants\");\n/**\n * Calculator for fees.\n *\n * @remarks\n * Returned by the {@link ReadableLiquity.getFees | getFees()} function.\n *\n * @public\n */\nclass Fees {\n    /** @internal */\n    constructor(baseRateWithoutDecay, minuteDecayFactor, beta, lastFeeOperation, timeOfLatestBlock, recoveryMode) {\n        this._baseRateWithoutDecay = Decimal_1.Decimal.from(baseRateWithoutDecay);\n        this._minuteDecayFactor = Decimal_1.Decimal.from(minuteDecayFactor);\n        this._beta = Decimal_1.Decimal.from(beta);\n        this._lastFeeOperation = lastFeeOperation;\n        this._timeOfLatestBlock = timeOfLatestBlock;\n        this._recoveryMode = recoveryMode;\n        assert_1.default(this._minuteDecayFactor.lt(1));\n    }\n    /** @internal */\n    _setRecoveryMode(recoveryMode) {\n        return new Fees(this._baseRateWithoutDecay, this._minuteDecayFactor, this._beta, this._lastFeeOperation, this._timeOfLatestBlock, recoveryMode);\n    }\n    /**\n     * Compare to another instance of `Fees`.\n     */\n    equals(that) {\n        return (this._baseRateWithoutDecay.eq(that._baseRateWithoutDecay) &&\n            this._minuteDecayFactor.eq(that._minuteDecayFactor) &&\n            this._beta.eq(that._beta) &&\n            this._lastFeeOperation.getTime() === that._lastFeeOperation.getTime() &&\n            this._timeOfLatestBlock.getTime() === that._timeOfLatestBlock.getTime() &&\n            this._recoveryMode === that._recoveryMode);\n    }\n    /** @internal */\n    toString() {\n        return (`{ baseRateWithoutDecay: ${this._baseRateWithoutDecay}` +\n            `, lastFeeOperation: \"${this._lastFeeOperation.toLocaleString()}\"` +\n            `, recoveryMode: ${this._recoveryMode} } `);\n    }\n    /** @internal */\n    baseRate(when = this._timeOfLatestBlock) {\n        const millisecondsSinceLastFeeOperation = Math.max(when.getTime() - this._lastFeeOperation.getTime(), 0 // Clamp negative elapsed time to 0, in case the client's time is in the past.\n        // We will calculate slightly higher than actual fees, which is fine.\n        );\n        const minutesSinceLastFeeOperation = Math.floor(millisecondsSinceLastFeeOperation / 60000);\n        return this._minuteDecayFactor.pow(minutesSinceLastFeeOperation).mul(this._baseRateWithoutDecay);\n    }\n    /**\n     * Calculate the current borrowing rate.\n     *\n     * @param when - Optional timestamp that can be used to calculate what the borrowing rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n     *\n     * To calculate the borrowing fee in LUSD, multiply the borrowed LUSD amount by the borrowing rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     *\n     * const borrowedLUSDAmount = 100;\n     * const borrowingRate = fees.borrowingRate();\n     * const borrowingFeeLUSD = borrowingRate.mul(borrowedLUSDAmount);\n     * ```\n     */\n    borrowingRate(when) {\n        return this._recoveryMode\n            ? Decimal_1.Decimal.ZERO\n            : Decimal_1.Decimal.min(constants_1.MINIMUM_BORROWING_RATE.add(this.baseRate(when)), constants_1.MAXIMUM_BORROWING_RATE);\n    }\n    /**\n     * Calculate the current redemption rate.\n     *\n     * @param redeemedFractionOfSupply - The amount of LUSD being redeemed divided by the total supply.\n     * @param when - Optional timestamp that can be used to calculate what the redemption rate would\n     *               decay to at a point of time in the future.\n     *\n     * @remarks\n     * By default, the fee is calculated at the time of the latest block. This can be overridden using\n     * the `when` parameter.\n  \n     * Unlike the borrowing rate, the redemption rate depends on the amount being redeemed. To be more\n     * precise, it depends on the fraction of the redeemed amount compared to the total LUSD supply,\n     * which must be passed as a parameter.\n     *\n     * To calculate the redemption fee in LUSD, multiply the redeemed LUSD amount with the redemption\n     * rate.\n     *\n     * @example\n     * ```typescript\n     * const fees = await liquity.getFees();\n     * const total = await liquity.getTotal();\n     *\n     * const redeemedLUSDAmount = Decimal.from(100);\n     * const redeemedFractionOfSupply = redeemedLUSDAmount.div(total.debt);\n     * const redemptionRate = fees.redemptionRate(redeemedFractionOfSupply);\n     * const redemptionFeeLUSD = redemptionRate.mul(redeemedLUSDAmount);\n     * ```\n     */\n    redemptionRate(redeemedFractionOfSupply = Decimal_1.Decimal.ZERO, when) {\n        redeemedFractionOfSupply = Decimal_1.Decimal.from(redeemedFractionOfSupply);\n        let baseRate = this.baseRate(when);\n        if (redeemedFractionOfSupply.nonZero) {\n            baseRate = redeemedFractionOfSupply.div(this._beta).add(baseRate);\n        }\n        return Decimal_1.Decimal.min(constants_1.MINIMUM_REDEMPTION_RATE.add(baseRate), Decimal_1.Decimal.ONE);\n    }\n}\nexports.Fees = Fees;\n//# sourceMappingURL=Fees.js.map"]},"metadata":{},"sourceType":"script"}