{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logsToString = void 0;\n\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\n\nconst constants_1 = require(\"@ethersproject/constants\");\n\nconst lib_base_1 = require(\"@liquity/lib-base\");\n\nconst interfaceLookupFrom = contractLookup => {\n  return Object.fromEntries(Object.entries(contractLookup).map(([, contract]) => [contract.address, contract.interface]));\n};\n\nconst nameLookupFrom = contractLookup => {\n  return Object.fromEntries(Object.entries(contractLookup).map(([name, contract]) => [contract.address, name]));\n};\n\nconst tryToParseLog = (log, interfaceLookup) => {\n  const {\n    address\n  } = log;\n\n  if (address in interfaceLookup) {\n    try {\n      return {\n        address,\n        logDescription: interfaceLookup[address].parseLog(log)\n      };\n    } catch (err) {\n      console.warn(\"Failed to parse log:\");\n      console.warn(log);\n      console.warn(\"Caught:\");\n      console.warn(err);\n    }\n  }\n};\n\nconst parseLogs = (logs, interfaceLookup) => {\n  const parsedLogs = [];\n  const unparsedLogs = [];\n  logs.forEach(log => {\n    const parsedLog = tryToParseLog(log, interfaceLookup);\n\n    if (parsedLog) {\n      parsedLogs.push(parsedLog);\n    } else {\n      unparsedLogs.push(log);\n    }\n  });\n  return [parsedLogs, unparsedLogs];\n};\n\nconst VERY_BIG = bignumber_1.BigNumber.from(10).pow(9);\n\nconst prettify = (arg, nameLookup) => {\n  if (bignumber_1.BigNumber.isBigNumber(arg)) {\n    if (arg.gte(VERY_BIG)) {\n      return `${lib_base_1.Decimal.fromBigNumberString(arg.toHexString())}e18`;\n    } else {\n      return arg.toString();\n    }\n  } else if (typeof arg === \"string\") {\n    return arg === constants_1.AddressZero ? \"address(0)\" : nameLookup && arg in nameLookup ? nameLookup[arg] : arg;\n  } else {\n    return String(arg);\n  }\n};\n\nconst logDescriptionToString = (logDescription, nameLookup) => {\n  const prettyEntries = Object.entries(logDescription.args).filter(([key]) => !key.match(/^[0-9]/)).map(([key, value]) => `${key}: ${prettify(value, nameLookup)}`);\n  return `${logDescription.name}({ ${prettyEntries.join(\", \")} })`;\n};\n\nconst logsToString = (receipt, contracts) => {\n  const contractLookup = contracts;\n  const interfaceLookup = interfaceLookupFrom(contractLookup);\n  const contractNameLookup = nameLookupFrom(contractLookup);\n  const nameLookup = {\n    [receipt.from]: \"user\",\n    ...contractNameLookup\n  };\n  const [parsedLogs, unparsedLogs] = parseLogs(receipt.logs, interfaceLookup);\n\n  if (unparsedLogs.length > 0) {\n    console.warn(\"Warning: not all logs were parsed. Unparsed logs:\");\n    console.warn(unparsedLogs);\n  }\n\n  if (parsedLogs.length > 0) {\n    return `Logs of tx ${receipt.transactionHash}:\\n` + parsedLogs.map(({\n      address,\n      logDescription\n    }) => `  ${contractNameLookup[address]}.${logDescriptionToString(logDescription, nameLookup)}`).join(\"\\n\");\n  } else {\n    return `No logs were parsed in tx ${receipt.transactionHash}`;\n  }\n};\n\nexports.logsToString = logsToString;","map":{"version":3,"sources":["../../src/parseLogs.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,WAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAIA,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAgBA,MAAM,mBAAmB,GAAI,cAAD,IAAoD;AAC9E,SAAO,MAAM,CAAC,WAAP,CACL,MAAM,CAAC,OAAP,CAAe,cAAf,EAA+B,GAA/B,CAAmC,CAAC,GAAG,QAAH,CAAD,KAAkB,CAAC,QAAQ,CAAC,OAAV,EAAmB,QAAQ,CAAC,SAA5B,CAArD,CADK,CAAP;AAGD,CAJD;;AAMA,MAAM,cAAc,GAAI,cAAD,IAA+C;AACpE,SAAO,MAAM,CAAC,WAAP,CACL,MAAM,CAAC,OAAP,CAAe,cAAf,EAA+B,GAA/B,CAAmC,CAAC,CAAC,IAAD,EAAO,QAAP,CAAD,KAAsB,CAAC,QAAQ,CAAC,OAAV,EAAmB,IAAnB,CAAzD,CADK,CAAP;AAGD,CAJD;;AAWA,MAAM,aAAa,GAAG,CAAC,GAAD,EAAW,eAAX,KAAsE;AAC1F,QAAM;AAAE,IAAA;AAAF,MAAc,GAApB;;AAEA,MAAI,OAAO,IAAI,eAAf,EAAgC;AAC9B,QAAI;AACF,aAAO;AAAE,QAAA,OAAF;AAAW,QAAA,cAAc,EAAE,eAAe,CAAC,OAAD,CAAf,CAAyB,QAAzB,CAAkC,GAAlC;AAA3B,OAAP;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,MAAA,OAAO,CAAC,IAAR,CAAa,sBAAb;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,GAAb;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,SAAb;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,GAAb;AACD;AACF;AACF,CAbD;;AAeA,MAAM,SAAS,GAAG,CAChB,IADgB,EAEhB,eAFgB,KAGkC;AAClD,QAAM,UAAU,GAAgB,EAAhC;AACA,QAAM,YAAY,GAAU,EAA5B;AAEA,EAAA,IAAI,CAAC,OAAL,CAAa,GAAG,IAAG;AACjB,UAAM,SAAS,GAAG,aAAa,CAAC,GAAD,EAAM,eAAN,CAA/B;;AAEA,QAAI,SAAJ,EAAe;AACb,MAAA,UAAU,CAAC,IAAX,CAAgB,SAAhB;AACD,KAFD,MAEO;AACL,MAAA,YAAY,CAAC,IAAb,CAAkB,GAAlB;AACD;AACF,GARD;AAUA,SAAO,CAAC,UAAD,EAAa,YAAb,CAAP;AACD,CAlBD;;AAoBA,MAAM,QAAQ,GAAG,WAAA,CAAA,SAAA,CAAU,IAAV,CAAe,EAAf,EAAmB,GAAnB,CAAuB,CAAvB,CAAjB;;AAEA,MAAM,QAAQ,GAAG,CAAC,GAAD,EAAe,UAAf,KAAyC;AACxD,MAAI,WAAA,CAAA,SAAA,CAAU,WAAV,CAAsB,GAAtB,CAAJ,EAAgC;AAC9B,QAAI,GAAG,CAAC,GAAJ,CAAQ,QAAR,CAAJ,EAAuB;AACrB,aAAO,GAAG,UAAA,CAAA,OAAA,CAAQ,mBAAR,CAA4B,GAAG,CAAC,WAAJ,EAA5B,CAA8C,KAAxD;AACD,KAFD,MAEO;AACL,aAAO,GAAG,CAAC,QAAJ,EAAP;AACD;AACF,GAND,MAMO,IAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAClC,WAAO,GAAG,KAAK,WAAA,CAAA,WAAR,GACH,YADG,GAEH,UAAU,IAAI,GAAG,IAAI,UAArB,GACA,UAAU,CAAC,GAAD,CADV,GAEA,GAJJ;AAKD,GANM,MAMA;AACL,WAAO,MAAM,CAAC,GAAD,CAAb;AACD;AACF,CAhBD;;AAkBA,MAAM,sBAAsB,GAAG,CAAC,cAAD,EAAiC,UAAjC,KAA2D;AACxF,QAAM,aAAa,GAAG,MAAM,CAAC,OAAP,CAAe,cAAc,CAAC,IAA9B,EACnB,MADmB,CACZ,CAAC,CAAC,GAAD,CAAD,KAAW,CAAC,GAAG,CAAC,KAAJ,CAAU,QAAV,CADA,EAEnB,GAFmB,CAEf,CAAC,CAAC,GAAD,EAAM,KAAN,CAAD,KAAkB,GAAG,GAAG,KAAK,QAAQ,CAAC,KAAD,EAAQ,UAAR,CAAmB,EAFzC,CAAtB;AAIA,SAAO,GAAG,cAAc,CAAC,IAAI,MAAM,aAAa,CAAC,IAAd,CAAmB,IAAnB,CAAwB,KAA3D;AACD,CAND;;AAQO,MAAM,YAAY,GAAG,CAAC,OAAD,EAA8B,SAA9B,KAAsE;AAChG,QAAM,cAAc,GAAI,SAAxB;AACA,QAAM,eAAe,GAAG,mBAAmB,CAAC,cAAD,CAA3C;AACA,QAAM,kBAAkB,GAAG,cAAc,CAAC,cAAD,CAAzC;AAEA,QAAM,UAAU,GAAG;AACjB,KAAC,OAAO,CAAC,IAAT,GAAgB,MADC;AAEjB,OAAG;AAFc,GAAnB;AAKA,QAAM,CAAC,UAAD,EAAa,YAAb,IAA6B,SAAS,CAAC,OAAO,CAAC,IAAT,EAAe,eAAf,CAA5C;;AAEA,MAAI,YAAY,CAAC,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,IAAA,OAAO,CAAC,IAAR,CAAa,mDAAb;AACA,IAAA,OAAO,CAAC,IAAR,CAAa,YAAb;AACD;;AAED,MAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,WACE,cAAc,OAAO,CAAC,eAAe,KAArC,GACA,UAAU,CACP,GADH,CAEI,CAAC;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,KAAD,KACE,KAAK,kBAAkB,CAAC,OAAD,CAAS,IAAI,sBAAsB,CAAC,cAAD,EAAiB,UAAjB,CAA4B,EAH5F,EAKG,IALH,CAKQ,IALR,CAFF;AASD,GAVD,MAUO;AACL,WAAO,6BAA6B,OAAO,CAAC,eAAe,EAA3D;AACD;AACF,CA9BM;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logsToString = void 0;\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\nconst constants_1 = require(\"@ethersproject/constants\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst interfaceLookupFrom = (contractLookup) => {\n    return Object.fromEntries(Object.entries(contractLookup).map(([, contract]) => [contract.address, contract.interface]));\n};\nconst nameLookupFrom = (contractLookup) => {\n    return Object.fromEntries(Object.entries(contractLookup).map(([name, contract]) => [contract.address, name]));\n};\nconst tryToParseLog = (log, interfaceLookup) => {\n    const { address } = log;\n    if (address in interfaceLookup) {\n        try {\n            return { address, logDescription: interfaceLookup[address].parseLog(log) };\n        }\n        catch (err) {\n            console.warn(\"Failed to parse log:\");\n            console.warn(log);\n            console.warn(\"Caught:\");\n            console.warn(err);\n        }\n    }\n};\nconst parseLogs = (logs, interfaceLookup) => {\n    const parsedLogs = [];\n    const unparsedLogs = [];\n    logs.forEach(log => {\n        const parsedLog = tryToParseLog(log, interfaceLookup);\n        if (parsedLog) {\n            parsedLogs.push(parsedLog);\n        }\n        else {\n            unparsedLogs.push(log);\n        }\n    });\n    return [parsedLogs, unparsedLogs];\n};\nconst VERY_BIG = bignumber_1.BigNumber.from(10).pow(9);\nconst prettify = (arg, nameLookup) => {\n    if (bignumber_1.BigNumber.isBigNumber(arg)) {\n        if (arg.gte(VERY_BIG)) {\n            return `${lib_base_1.Decimal.fromBigNumberString(arg.toHexString())}e18`;\n        }\n        else {\n            return arg.toString();\n        }\n    }\n    else if (typeof arg === \"string\") {\n        return arg === constants_1.AddressZero\n            ? \"address(0)\"\n            : nameLookup && arg in nameLookup\n                ? nameLookup[arg]\n                : arg;\n    }\n    else {\n        return String(arg);\n    }\n};\nconst logDescriptionToString = (logDescription, nameLookup) => {\n    const prettyEntries = Object.entries(logDescription.args)\n        .filter(([key]) => !key.match(/^[0-9]/))\n        .map(([key, value]) => `${key}: ${prettify(value, nameLookup)}`);\n    return `${logDescription.name}({ ${prettyEntries.join(\", \")} })`;\n};\nconst logsToString = (receipt, contracts) => {\n    const contractLookup = contracts;\n    const interfaceLookup = interfaceLookupFrom(contractLookup);\n    const contractNameLookup = nameLookupFrom(contractLookup);\n    const nameLookup = {\n        [receipt.from]: \"user\",\n        ...contractNameLookup\n    };\n    const [parsedLogs, unparsedLogs] = parseLogs(receipt.logs, interfaceLookup);\n    if (unparsedLogs.length > 0) {\n        console.warn(\"Warning: not all logs were parsed. Unparsed logs:\");\n        console.warn(unparsedLogs);\n    }\n    if (parsedLogs.length > 0) {\n        return (`Logs of tx ${receipt.transactionHash}:\\n` +\n            parsedLogs\n                .map(({ address, logDescription }) => `  ${contractNameLookup[address]}.${logDescriptionToString(logDescription, nameLookup)}`)\n                .join(\"\\n\"));\n    }\n    else {\n        return `No logs were parsed in tx ${receipt.transactionHash}`;\n    }\n};\nexports.logsToString = logsToString;\n//# sourceMappingURL=parseLogs.js.map"]},"metadata":{},"sourceType":"script"}