{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented = exports.isWebSocketAugmentedProvider = void 0;\n\nconst providers_1 = require(\"@ethersproject/providers\");\n\nconst WebSocketProvider_1 = require(\"./WebSocketProvider\");\n\nconst webSocketAugmentedProviders = [];\n\nconst isWebSocketAugmentedProvider = provider => webSocketAugmentedProviders.some(webSocketAugmentedProvider => provider instanceof webSocketAugmentedProvider);\n\nexports.isWebSocketAugmentedProvider = isWebSocketAugmentedProvider;\n\nconst isHeaderNotFoundError = error => typeof error === \"object\" && typeof error.message === \"string\" && error.message.includes(\"header not found\");\n\nconst loadBalancingGlitchRetryIntervalMs = 200;\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\nconst WebSocketAugmented = Base => {\n  let webSocketAugmentedProvider = class extends Base {\n    constructor() {\n      super(...arguments);\n      this._seenBlock = 0;\n      this._blockListenerScheduled = false;\n      this._blockListeners = new Set();\n      this._blockListener = this._onBlock.bind(this);\n    }\n\n    openWebSocket(url, network) {\n      this._wsProvider = new WebSocketProvider_1.WebSocketProvider(url, network);\n      this._wsProvider.onClose = this._onWebSocketClose.bind(this);\n      this._wsParams = [url, network];\n\n      this._switchover();\n    }\n\n    _onWebSocketClose() {\n      this.closeWebSocket();\n      console.warn(\"WebSocketProvider disconnected. Retrying in 10 seconds.\");\n      this._reconnectTimerId = setTimeout(() => this.openWebSocket(...this._wsParams), 10000);\n    }\n\n    closeWebSocket() {\n      if (this._wsProvider) {\n        this._wsProvider.onClose = null;\n\n        this._wsProvider.close(1000); // normal closure\n\n\n        this._wsProvider = undefined;\n\n        this._switchover();\n\n        if (this._reconnectTimerId !== undefined) {\n          clearTimeout(this._reconnectTimerId);\n          this._reconnectTimerId = undefined;\n        }\n      }\n    }\n\n    _switchover() {\n      if (this._blockListeners.size > 0) {\n        if (this._wsProvider) {\n          super.off(\"block\", this._blockListener);\n        }\n\n        this._startBlockEvents();\n      }\n    }\n\n    _onBlock(blockNumber) {\n      this._seenBlock = blockNumber;\n\n      if (!this._blockListenerScheduled) {\n        this._blockListenerScheduled = true;\n        setTimeout(() => {\n          this._blockListenerScheduled = false;\n          [...this._blockListeners].forEach(listener => listener(this._seenBlock));\n        }, 50);\n      }\n    }\n\n    async _retrySeenBlock(perform, startingBlock) {\n      for (let retries = 0;; ++retries) {\n        try {\n          const ret = await perform();\n\n          if (retries) {// console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n          }\n\n          return ret;\n        } catch (error) {\n          if (this._seenBlock !== startingBlock || !isHeaderNotFoundError(error)) {\n            throw error;\n          }\n        } // console.warn(\"Load balancing glitch. Retrying...\");\n\n\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n    }\n\n    async call(transaction, blockTag) {\n      const resolvedBlockTag = await blockTag;\n\n      const perform = () => {\n        var _a;\n\n        return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.call(transaction, resolvedBlockTag) : super.call(transaction, resolvedBlockTag);\n      };\n\n      return resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform();\n    }\n\n    async getBalance(addressOrName, blockTag) {\n      const resolvedBlockTag = await blockTag;\n\n      const perform = () => {\n        var _a;\n\n        return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBalance(addressOrName, resolvedBlockTag) : super.getBalance(addressOrName, resolvedBlockTag);\n      };\n\n      return resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform();\n    }\n\n    _startBlockEvents() {\n      if (this._wsProvider) {\n        console.log(\"Listening for new blocks on WebSocketProvider\");\n\n        this._wsProvider.on(\"block\", this._blockListener);\n      } else {\n        console.log(\"Listening for new blocks on basic Provider\");\n        super.on(\"block\", this._blockListener);\n      }\n    }\n\n    _stopBlockEvents() {\n      if (this._wsProvider) {\n        this._wsProvider.off(\"block\", this._blockListener);\n      } else {\n        super.off(\"block\", this._blockListener);\n      }\n    }\n\n    on(eventName, listener) {\n      if (eventName === \"block\") {\n        return this._addBlockListener(listener);\n      } else {\n        return super.on(eventName, listener);\n      }\n    }\n\n    _addBlockListener(listener) {\n      if (!this._blockListeners.has(listener)) {\n        this._blockListeners.add(listener);\n\n        if (this._blockListeners.size === 1) {\n          this._startBlockEvents();\n        }\n      }\n\n      return this;\n    }\n\n    once(eventName, listener) {\n      if (eventName === \"block\") {\n        const listenOnce = blockNumber => {\n          listener(blockNumber);\n\n          this._removeBlockListener(listenOnce);\n        };\n\n        return this._addBlockListener(listenOnce);\n      } else {\n        return super.once(eventName, listener);\n      }\n    }\n\n    off(eventName, listener) {\n      if (eventName === \"block\") {\n        return this._removeBlockListener(listener);\n      } else {\n        return super.off(eventName, listener);\n      }\n    }\n\n    _removeBlockListener(listener) {\n      if (this._blockListeners.has(listener)) {\n        this._blockListeners.delete(listener);\n\n        if (this._blockListeners.size === 0) {\n          this._stopBlockEvents();\n        }\n      }\n\n      return this;\n    }\n\n    getTransactionReceipt(transactionHash) {\n      var _a;\n\n      return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.ready) ? this._wsProvider.getTransactionReceipt(transactionHash) : super.getTransactionReceipt(transactionHash);\n    }\n\n    async _blockContainsTx(blockNumber, txHash) {\n      let block;\n\n      for (block = null; !block; block = await this.getBlock(blockNumber)) {\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n\n      return block.transactions.some(txHashInBlock => txHashInBlock === txHash);\n    }\n\n    async _getTransactionReceiptFromLatest(txHash, latestBlock) {\n      txHash = await txHash;\n\n      for (let retries = 0;; ++retries) {\n        const receipt = await this.getTransactionReceipt(txHash);\n\n        if (latestBlock === undefined || receipt === null && !(await this._blockContainsTx(latestBlock, txHash)) || receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock) {\n          if (retries) {// console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n          }\n\n          return receipt;\n        } // console.warn(\"Load balancing glitch. Retrying...\");\n\n\n        await delay(loadBalancingGlitchRetryIntervalMs);\n      }\n    }\n\n    async waitForTransaction(txHash, confirmations, timeout) {\n      if (timeout !== undefined) {\n        // We don't use timeout, don't implement it\n        return super.waitForTransaction(txHash, confirmations, timeout);\n      }\n\n      let latestBlock = undefined;\n\n      for (;;) {\n        const receipt = await this._getTransactionReceiptFromLatest(txHash, latestBlock);\n\n        if (receipt !== null && (confirmations === undefined || receipt.confirmations >= confirmations)) {\n          return receipt;\n        }\n\n        latestBlock = await new Promise(resolve => this.once(\"block\", resolve));\n      }\n    }\n\n  };\n  webSocketAugmentedProviders.push(webSocketAugmentedProvider);\n  return webSocketAugmentedProvider;\n};\n\nexports.WebSocketAugmented = WebSocketAugmented;\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented(providers_1.Web3Provider);","map":{"version":3,"sources":["../../src/WebSocketAugmentedProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented = exports.isWebSocketAugmentedProvider = void 0;\nconst providers_1 = require(\"@ethersproject/providers\");\nconst WebSocketProvider_1 = require(\"./WebSocketProvider\");\nconst webSocketAugmentedProviders = [];\nconst isWebSocketAugmentedProvider = (provider) => webSocketAugmentedProviders.some(webSocketAugmentedProvider => provider instanceof webSocketAugmentedProvider);\nexports.isWebSocketAugmentedProvider = isWebSocketAugmentedProvider;\nconst isHeaderNotFoundError = (error) => typeof error === \"object\" &&\n    typeof error.message === \"string\" &&\n    error.message.includes(\"header not found\");\nconst loadBalancingGlitchRetryIntervalMs = 200;\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nconst WebSocketAugmented = (Base) => {\n    let webSocketAugmentedProvider = class extends Base {\n        constructor() {\n            super(...arguments);\n            this._seenBlock = 0;\n            this._blockListenerScheduled = false;\n            this._blockListeners = new Set();\n            this._blockListener = this._onBlock.bind(this);\n        }\n        openWebSocket(url, network) {\n            this._wsProvider = new WebSocketProvider_1.WebSocketProvider(url, network);\n            this._wsProvider.onClose = this._onWebSocketClose.bind(this);\n            this._wsParams = [url, network];\n            this._switchover();\n        }\n        _onWebSocketClose() {\n            this.closeWebSocket();\n            console.warn(\"WebSocketProvider disconnected. Retrying in 10 seconds.\");\n            this._reconnectTimerId = setTimeout(() => this.openWebSocket(...this._wsParams), 10000);\n        }\n        closeWebSocket() {\n            if (this._wsProvider) {\n                this._wsProvider.onClose = null;\n                this._wsProvider.close(1000); // normal closure\n                this._wsProvider = undefined;\n                this._switchover();\n                if (this._reconnectTimerId !== undefined) {\n                    clearTimeout(this._reconnectTimerId);\n                    this._reconnectTimerId = undefined;\n                }\n            }\n        }\n        _switchover() {\n            if (this._blockListeners.size > 0) {\n                if (this._wsProvider) {\n                    super.off(\"block\", this._blockListener);\n                }\n                this._startBlockEvents();\n            }\n        }\n        _onBlock(blockNumber) {\n            this._seenBlock = blockNumber;\n            if (!this._blockListenerScheduled) {\n                this._blockListenerScheduled = true;\n                setTimeout(() => {\n                    this._blockListenerScheduled = false;\n                    [...this._blockListeners].forEach(listener => listener(this._seenBlock));\n                }, 50);\n            }\n        }\n        async _retrySeenBlock(perform, startingBlock) {\n            for (let retries = 0;; ++retries) {\n                try {\n                    const ret = await perform();\n                    if (retries) {\n                        // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                    }\n                    return ret;\n                }\n                catch (error) {\n                    if (this._seenBlock !== startingBlock || !isHeaderNotFoundError(error)) {\n                        throw error;\n                    }\n                }\n                // console.warn(\"Load balancing glitch. Retrying...\");\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n        }\n        async call(transaction, blockTag) {\n            const resolvedBlockTag = await blockTag;\n            const perform = () => {\n                var _a;\n                return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.call(transaction, resolvedBlockTag)\n                    : super.call(transaction, resolvedBlockTag);\n            };\n            return resolvedBlockTag === this._seenBlock\n                ? this._retrySeenBlock(perform, this._seenBlock)\n                : perform();\n        }\n        async getBalance(addressOrName, blockTag) {\n            const resolvedBlockTag = await blockTag;\n            const perform = () => {\n                var _a;\n                return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBalance(addressOrName, resolvedBlockTag)\n                    : super.getBalance(addressOrName, resolvedBlockTag);\n            };\n            return resolvedBlockTag === this._seenBlock\n                ? this._retrySeenBlock(perform, this._seenBlock)\n                : perform();\n        }\n        _startBlockEvents() {\n            if (this._wsProvider) {\n                console.log(\"Listening for new blocks on WebSocketProvider\");\n                this._wsProvider.on(\"block\", this._blockListener);\n            }\n            else {\n                console.log(\"Listening for new blocks on basic Provider\");\n                super.on(\"block\", this._blockListener);\n            }\n        }\n        _stopBlockEvents() {\n            if (this._wsProvider) {\n                this._wsProvider.off(\"block\", this._blockListener);\n            }\n            else {\n                super.off(\"block\", this._blockListener);\n            }\n        }\n        on(eventName, listener) {\n            if (eventName === \"block\") {\n                return this._addBlockListener(listener);\n            }\n            else {\n                return super.on(eventName, listener);\n            }\n        }\n        _addBlockListener(listener) {\n            if (!this._blockListeners.has(listener)) {\n                this._blockListeners.add(listener);\n                if (this._blockListeners.size === 1) {\n                    this._startBlockEvents();\n                }\n            }\n            return this;\n        }\n        once(eventName, listener) {\n            if (eventName === \"block\") {\n                const listenOnce = (blockNumber) => {\n                    listener(blockNumber);\n                    this._removeBlockListener(listenOnce);\n                };\n                return this._addBlockListener(listenOnce);\n            }\n            else {\n                return super.once(eventName, listener);\n            }\n        }\n        off(eventName, listener) {\n            if (eventName === \"block\") {\n                return this._removeBlockListener(listener);\n            }\n            else {\n                return super.off(eventName, listener);\n            }\n        }\n        _removeBlockListener(listener) {\n            if (this._blockListeners.has(listener)) {\n                this._blockListeners.delete(listener);\n                if (this._blockListeners.size === 0) {\n                    this._stopBlockEvents();\n                }\n            }\n            return this;\n        }\n        getTransactionReceipt(transactionHash) {\n            var _a;\n            return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.ready) ? this._wsProvider.getTransactionReceipt(transactionHash)\n                : super.getTransactionReceipt(transactionHash);\n        }\n        async _blockContainsTx(blockNumber, txHash) {\n            let block;\n            for (block = null; !block; block = await this.getBlock(blockNumber)) {\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n            return block.transactions.some(txHashInBlock => txHashInBlock === txHash);\n        }\n        async _getTransactionReceiptFromLatest(txHash, latestBlock) {\n            txHash = await txHash;\n            for (let retries = 0;; ++retries) {\n                const receipt = (await this.getTransactionReceipt(txHash));\n                if (latestBlock === undefined ||\n                    (receipt === null && !(await this._blockContainsTx(latestBlock, txHash))) ||\n                    (receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock)) {\n                    if (retries) {\n                        // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                    }\n                    return receipt;\n                }\n                // console.warn(\"Load balancing glitch. Retrying...\");\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n        }\n        async waitForTransaction(txHash, confirmations, timeout) {\n            if (timeout !== undefined) {\n                // We don't use timeout, don't implement it\n                return super.waitForTransaction(txHash, confirmations, timeout);\n            }\n            let latestBlock = undefined;\n            for (;;) {\n                const receipt = await this._getTransactionReceiptFromLatest(txHash, latestBlock);\n                if (receipt !== null &&\n                    (confirmations === undefined || receipt.confirmations >= confirmations)) {\n                    return receipt;\n                }\n                latestBlock = await new Promise(resolve => this.once(\"block\", resolve));\n            }\n        }\n    };\n    webSocketAugmentedProviders.push(webSocketAugmentedProvider);\n    return webSocketAugmentedProvider;\n};\nexports.WebSocketAugmented = WebSocketAugmented;\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented(providers_1.Web3Provider);\n//# sourceMappingURL=WebSocketAugmentedProvider.js.map"]},"metadata":{},"sourceType":"script"}