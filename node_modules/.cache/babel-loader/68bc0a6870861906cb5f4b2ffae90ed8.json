{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented = exports.isWebSocketAugmentedProvider = void 0;\n\nvar providers_1 = require(\"@ethersproject/providers\");\n\nvar WebSocketProvider_1 = require(\"./WebSocketProvider\");\n\nvar webSocketAugmentedProviders = [];\n\nvar isWebSocketAugmentedProvider = function isWebSocketAugmentedProvider(provider) {\n  return webSocketAugmentedProviders.some(function (webSocketAugmentedProvider) {\n    return provider instanceof webSocketAugmentedProvider;\n  });\n};\n\nexports.isWebSocketAugmentedProvider = isWebSocketAugmentedProvider;\n\nvar isHeaderNotFoundError = function isHeaderNotFoundError(error) {\n  return typeof error === \"object\" && typeof error.message === \"string\" && error.message.includes(\"header not found\");\n};\n\nvar loadBalancingGlitchRetryIntervalMs = 200;\n\nvar delay = function delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n};\n\nvar WebSocketAugmented = function WebSocketAugmented(Base) {\n  var webSocketAugmentedProvider = /*#__PURE__*/function (_Base) {\n    _inherits(webSocketAugmentedProvider, _Base);\n\n    var _super = _createSuper(webSocketAugmentedProvider);\n\n    function webSocketAugmentedProvider() {\n      var _this;\n\n      _classCallCheck(this, webSocketAugmentedProvider);\n\n      _this = _super.apply(this, arguments);\n      _this._seenBlock = 0;\n      _this._blockListenerScheduled = false;\n      _this._blockListeners = new Set();\n      _this._blockListener = _this._onBlock.bind(_assertThisInitialized(_this));\n      return _this;\n    }\n\n    _createClass(webSocketAugmentedProvider, [{\n      key: \"openWebSocket\",\n      value: function openWebSocket(url, network) {\n        this._wsProvider = new WebSocketProvider_1.WebSocketProvider(url, network);\n        this._wsProvider.onClose = this._onWebSocketClose.bind(this);\n        this._wsParams = [url, network];\n\n        this._switchover();\n      }\n    }, {\n      key: \"_onWebSocketClose\",\n      value: function _onWebSocketClose() {\n        var _this2 = this;\n\n        this.closeWebSocket();\n        console.warn(\"WebSocketProvider disconnected. Retrying in 10 seconds.\");\n        this._reconnectTimerId = setTimeout(function () {\n          return _this2.openWebSocket.apply(_this2, _toConsumableArray(_this2._wsParams));\n        }, 10000);\n      }\n    }, {\n      key: \"closeWebSocket\",\n      value: function closeWebSocket() {\n        if (this._wsProvider) {\n          this._wsProvider.onClose = null;\n\n          this._wsProvider.close(1000); // normal closure\n\n\n          this._wsProvider = undefined;\n\n          this._switchover();\n\n          if (this._reconnectTimerId !== undefined) {\n            clearTimeout(this._reconnectTimerId);\n            this._reconnectTimerId = undefined;\n          }\n        }\n      }\n    }, {\n      key: \"_switchover\",\n      value: function _switchover() {\n        if (this._blockListeners.size > 0) {\n          if (this._wsProvider) {\n            _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"off\", this).call(this, \"block\", this._blockListener);\n          }\n\n          this._startBlockEvents();\n        }\n      }\n    }, {\n      key: \"_onBlock\",\n      value: function _onBlock(blockNumber) {\n        var _this3 = this;\n\n        this._seenBlock = blockNumber;\n\n        if (!this._blockListenerScheduled) {\n          this._blockListenerScheduled = true;\n          setTimeout(function () {\n            _this3._blockListenerScheduled = false;\n\n            _toConsumableArray(_this3._blockListeners).forEach(function (listener) {\n              return listener(_this3._seenBlock);\n            });\n          }, 50);\n        }\n      }\n    }, {\n      key: \"_retrySeenBlock\",\n      value: function () {\n        var _retrySeenBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(perform, startingBlock) {\n          var retries, ret;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  retries = 0;\n\n                case 1:\n                  _context.prev = 1;\n                  _context.next = 4;\n                  return perform();\n\n                case 4:\n                  ret = _context.sent;\n\n                  if (retries) {// console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                  }\n\n                  return _context.abrupt(\"return\", ret);\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](1);\n\n                  if (!(this._seenBlock !== startingBlock || !isHeaderNotFoundError(_context.t0))) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  throw _context.t0;\n\n                case 13:\n                  _context.next = 15;\n                  return delay(loadBalancingGlitchRetryIntervalMs);\n\n                case 15:\n                  ++retries;\n                  _context.next = 1;\n                  break;\n\n                case 18:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[1, 9]]);\n        }));\n\n        function _retrySeenBlock(_x, _x2) {\n          return _retrySeenBlock2.apply(this, arguments);\n        }\n\n        return _retrySeenBlock;\n      }()\n    }, {\n      key: \"call\",\n      value: function () {\n        var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(transaction, blockTag) {\n          var _this4 = this;\n\n          var resolvedBlockTag, perform;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return blockTag;\n\n                case 2:\n                  resolvedBlockTag = _context2.sent;\n\n                  perform = function perform() {\n                    var _a;\n\n                    return ((_a = _this4._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? _this4._wsProvider.call(transaction, resolvedBlockTag) : _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"call\", _this4).call(_this4, transaction, resolvedBlockTag);\n                  };\n\n                  return _context2.abrupt(\"return\", resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform());\n\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function call(_x3, _x4) {\n          return _call.apply(this, arguments);\n        }\n\n        return call;\n      }()\n    }, {\n      key: \"getBalance\",\n      value: function () {\n        var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(addressOrName, blockTag) {\n          var _this5 = this;\n\n          var resolvedBlockTag, perform;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return blockTag;\n\n                case 2:\n                  resolvedBlockTag = _context3.sent;\n\n                  perform = function perform() {\n                    var _a;\n\n                    return ((_a = _this5._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? _this5._wsProvider.getBalance(addressOrName, resolvedBlockTag) : _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"getBalance\", _this5).call(_this5, addressOrName, resolvedBlockTag);\n                  };\n\n                  return _context3.abrupt(\"return\", resolvedBlockTag === this._seenBlock ? this._retrySeenBlock(perform, this._seenBlock) : perform());\n\n                case 5:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function getBalance(_x5, _x6) {\n          return _getBalance.apply(this, arguments);\n        }\n\n        return getBalance;\n      }()\n    }, {\n      key: \"_startBlockEvents\",\n      value: function _startBlockEvents() {\n        if (this._wsProvider) {\n          console.log(\"Listening for new blocks on WebSocketProvider\");\n\n          this._wsProvider.on(\"block\", this._blockListener);\n        } else {\n          console.log(\"Listening for new blocks on basic Provider\");\n\n          _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"on\", this).call(this, \"block\", this._blockListener);\n        }\n      }\n    }, {\n      key: \"_stopBlockEvents\",\n      value: function _stopBlockEvents() {\n        if (this._wsProvider) {\n          this._wsProvider.off(\"block\", this._blockListener);\n        } else {\n          _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"off\", this).call(this, \"block\", this._blockListener);\n        }\n      }\n    }, {\n      key: \"on\",\n      value: function on(eventName, listener) {\n        if (eventName === \"block\") {\n          return this._addBlockListener(listener);\n        } else {\n          return _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"on\", this).call(this, eventName, listener);\n        }\n      }\n    }, {\n      key: \"_addBlockListener\",\n      value: function _addBlockListener(listener) {\n        if (!this._blockListeners.has(listener)) {\n          this._blockListeners.add(listener);\n\n          if (this._blockListeners.size === 1) {\n            this._startBlockEvents();\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(eventName, listener) {\n        var _this6 = this;\n\n        if (eventName === \"block\") {\n          var listenOnce = function listenOnce(blockNumber) {\n            listener(blockNumber);\n\n            _this6._removeBlockListener(listenOnce);\n          };\n\n          return this._addBlockListener(listenOnce);\n        } else {\n          return _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"once\", this).call(this, eventName, listener);\n        }\n      }\n    }, {\n      key: \"off\",\n      value: function off(eventName, listener) {\n        if (eventName === \"block\") {\n          return this._removeBlockListener(listener);\n        } else {\n          return _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"off\", this).call(this, eventName, listener);\n        }\n      }\n    }, {\n      key: \"_removeBlockListener\",\n      value: function _removeBlockListener(listener) {\n        if (this._blockListeners.has(listener)) {\n          this._blockListeners.delete(listener);\n\n          if (this._blockListeners.size === 0) {\n            this._stopBlockEvents();\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"getTransactionReceipt\",\n      value: function getTransactionReceipt(transactionHash) {\n        var _a;\n\n        return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.ready) ? this._wsProvider.getTransactionReceipt(transactionHash) : _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"getTransactionReceipt\", this).call(this, transactionHash);\n      }\n    }, {\n      key: \"_blockContainsTx\",\n      value: function () {\n        var _blockContainsTx2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(blockNumber, txHash) {\n          var block;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  block = null;\n\n                case 1:\n                  if (block) {\n                    _context4.next = 9;\n                    break;\n                  }\n\n                  _context4.next = 4;\n                  return delay(loadBalancingGlitchRetryIntervalMs);\n\n                case 4:\n                  _context4.next = 6;\n                  return this.getBlock(blockNumber);\n\n                case 6:\n                  block = _context4.sent;\n                  _context4.next = 1;\n                  break;\n\n                case 9:\n                  return _context4.abrupt(\"return\", block.transactions.some(function (txHashInBlock) {\n                    return txHashInBlock === txHash;\n                  }));\n\n                case 10:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function _blockContainsTx(_x7, _x8) {\n          return _blockContainsTx2.apply(this, arguments);\n        }\n\n        return _blockContainsTx;\n      }()\n    }, {\n      key: \"_getTransactionReceiptFromLatest\",\n      value: function () {\n        var _getTransactionReceiptFromLatest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(txHash, latestBlock) {\n          var retries, receipt;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return txHash;\n\n                case 2:\n                  txHash = _context5.sent;\n                  retries = 0;\n\n                case 4:\n                  _context5.next = 6;\n                  return this.getTransactionReceipt(txHash);\n\n                case 6:\n                  receipt = _context5.sent;\n                  _context5.t1 = latestBlock === undefined;\n\n                  if (_context5.t1) {\n                    _context5.next = 15;\n                    break;\n                  }\n\n                  _context5.t2 = receipt === null;\n\n                  if (!_context5.t2) {\n                    _context5.next = 14;\n                    break;\n                  }\n\n                  _context5.next = 13;\n                  return this._blockContainsTx(latestBlock, txHash);\n\n                case 13:\n                  _context5.t2 = !_context5.sent;\n\n                case 14:\n                  _context5.t1 = _context5.t2;\n\n                case 15:\n                  _context5.t0 = _context5.t1;\n\n                  if (_context5.t0) {\n                    _context5.next = 18;\n                    break;\n                  }\n\n                  _context5.t0 = receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock;\n\n                case 18:\n                  if (!_context5.t0) {\n                    _context5.next = 21;\n                    break;\n                  }\n\n                  if (retries) {// console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                  }\n\n                  return _context5.abrupt(\"return\", receipt);\n\n                case 21:\n                  _context5.next = 23;\n                  return delay(loadBalancingGlitchRetryIntervalMs);\n\n                case 23:\n                  ++retries;\n                  _context5.next = 4;\n                  break;\n\n                case 26:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function _getTransactionReceiptFromLatest(_x9, _x10) {\n          return _getTransactionReceiptFromLatest2.apply(this, arguments);\n        }\n\n        return _getTransactionReceiptFromLatest;\n      }()\n    }, {\n      key: \"waitForTransaction\",\n      value: function () {\n        var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(txHash, confirmations, timeout) {\n          var _this7 = this;\n\n          var latestBlock, receipt;\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (!(timeout !== undefined)) {\n                    _context6.next = 2;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"return\", _get(_getPrototypeOf(webSocketAugmentedProvider.prototype), \"waitForTransaction\", this).call(this, txHash, confirmations, timeout));\n\n                case 2:\n                  latestBlock = undefined;\n\n                case 3:\n                  _context6.next = 5;\n                  return this._getTransactionReceiptFromLatest(txHash, latestBlock);\n\n                case 5:\n                  receipt = _context6.sent;\n\n                  if (!(receipt !== null && (confirmations === undefined || receipt.confirmations >= confirmations))) {\n                    _context6.next = 8;\n                    break;\n                  }\n\n                  return _context6.abrupt(\"return\", receipt);\n\n                case 8:\n                  _context6.next = 10;\n                  return new Promise(function (resolve) {\n                    return _this7.once(\"block\", resolve);\n                  });\n\n                case 10:\n                  latestBlock = _context6.sent;\n\n                case 11:\n                  _context6.next = 3;\n                  break;\n\n                case 13:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function waitForTransaction(_x11, _x12, _x13) {\n          return _waitForTransaction.apply(this, arguments);\n        }\n\n        return waitForTransaction;\n      }()\n    }]);\n\n    return webSocketAugmentedProvider;\n  }(Base);\n\n  webSocketAugmentedProviders.push(webSocketAugmentedProvider);\n  return webSocketAugmentedProvider;\n};\n\nexports.WebSocketAugmented = WebSocketAugmented;\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented(providers_1.Web3Provider);","map":{"version":3,"sources":["../../src/WebSocketAugmentedProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented = exports.isWebSocketAugmentedProvider = void 0;\nconst providers_1 = require(\"@ethersproject/providers\");\nconst WebSocketProvider_1 = require(\"./WebSocketProvider\");\nconst webSocketAugmentedProviders = [];\nconst isWebSocketAugmentedProvider = (provider) => webSocketAugmentedProviders.some(webSocketAugmentedProvider => provider instanceof webSocketAugmentedProvider);\nexports.isWebSocketAugmentedProvider = isWebSocketAugmentedProvider;\nconst isHeaderNotFoundError = (error) => typeof error === \"object\" &&\n    typeof error.message === \"string\" &&\n    error.message.includes(\"header not found\");\nconst loadBalancingGlitchRetryIntervalMs = 200;\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nconst WebSocketAugmented = (Base) => {\n    let webSocketAugmentedProvider = class extends Base {\n        constructor() {\n            super(...arguments);\n            this._seenBlock = 0;\n            this._blockListenerScheduled = false;\n            this._blockListeners = new Set();\n            this._blockListener = this._onBlock.bind(this);\n        }\n        openWebSocket(url, network) {\n            this._wsProvider = new WebSocketProvider_1.WebSocketProvider(url, network);\n            this._wsProvider.onClose = this._onWebSocketClose.bind(this);\n            this._wsParams = [url, network];\n            this._switchover();\n        }\n        _onWebSocketClose() {\n            this.closeWebSocket();\n            console.warn(\"WebSocketProvider disconnected. Retrying in 10 seconds.\");\n            this._reconnectTimerId = setTimeout(() => this.openWebSocket(...this._wsParams), 10000);\n        }\n        closeWebSocket() {\n            if (this._wsProvider) {\n                this._wsProvider.onClose = null;\n                this._wsProvider.close(1000); // normal closure\n                this._wsProvider = undefined;\n                this._switchover();\n                if (this._reconnectTimerId !== undefined) {\n                    clearTimeout(this._reconnectTimerId);\n                    this._reconnectTimerId = undefined;\n                }\n            }\n        }\n        _switchover() {\n            if (this._blockListeners.size > 0) {\n                if (this._wsProvider) {\n                    super.off(\"block\", this._blockListener);\n                }\n                this._startBlockEvents();\n            }\n        }\n        _onBlock(blockNumber) {\n            this._seenBlock = blockNumber;\n            if (!this._blockListenerScheduled) {\n                this._blockListenerScheduled = true;\n                setTimeout(() => {\n                    this._blockListenerScheduled = false;\n                    [...this._blockListeners].forEach(listener => listener(this._seenBlock));\n                }, 50);\n            }\n        }\n        async _retrySeenBlock(perform, startingBlock) {\n            for (let retries = 0;; ++retries) {\n                try {\n                    const ret = await perform();\n                    if (retries) {\n                        // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                    }\n                    return ret;\n                }\n                catch (error) {\n                    if (this._seenBlock !== startingBlock || !isHeaderNotFoundError(error)) {\n                        throw error;\n                    }\n                }\n                // console.warn(\"Load balancing glitch. Retrying...\");\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n        }\n        async call(transaction, blockTag) {\n            const resolvedBlockTag = await blockTag;\n            const perform = () => {\n                var _a;\n                return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.call(transaction, resolvedBlockTag)\n                    : super.call(transaction, resolvedBlockTag);\n            };\n            return resolvedBlockTag === this._seenBlock\n                ? this._retrySeenBlock(perform, this._seenBlock)\n                : perform();\n        }\n        async getBalance(addressOrName, blockTag) {\n            const resolvedBlockTag = await blockTag;\n            const perform = () => {\n                var _a;\n                return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.isReady) ? this._wsProvider.getBalance(addressOrName, resolvedBlockTag)\n                    : super.getBalance(addressOrName, resolvedBlockTag);\n            };\n            return resolvedBlockTag === this._seenBlock\n                ? this._retrySeenBlock(perform, this._seenBlock)\n                : perform();\n        }\n        _startBlockEvents() {\n            if (this._wsProvider) {\n                console.log(\"Listening for new blocks on WebSocketProvider\");\n                this._wsProvider.on(\"block\", this._blockListener);\n            }\n            else {\n                console.log(\"Listening for new blocks on basic Provider\");\n                super.on(\"block\", this._blockListener);\n            }\n        }\n        _stopBlockEvents() {\n            if (this._wsProvider) {\n                this._wsProvider.off(\"block\", this._blockListener);\n            }\n            else {\n                super.off(\"block\", this._blockListener);\n            }\n        }\n        on(eventName, listener) {\n            if (eventName === \"block\") {\n                return this._addBlockListener(listener);\n            }\n            else {\n                return super.on(eventName, listener);\n            }\n        }\n        _addBlockListener(listener) {\n            if (!this._blockListeners.has(listener)) {\n                this._blockListeners.add(listener);\n                if (this._blockListeners.size === 1) {\n                    this._startBlockEvents();\n                }\n            }\n            return this;\n        }\n        once(eventName, listener) {\n            if (eventName === \"block\") {\n                const listenOnce = (blockNumber) => {\n                    listener(blockNumber);\n                    this._removeBlockListener(listenOnce);\n                };\n                return this._addBlockListener(listenOnce);\n            }\n            else {\n                return super.once(eventName, listener);\n            }\n        }\n        off(eventName, listener) {\n            if (eventName === \"block\") {\n                return this._removeBlockListener(listener);\n            }\n            else {\n                return super.off(eventName, listener);\n            }\n        }\n        _removeBlockListener(listener) {\n            if (this._blockListeners.has(listener)) {\n                this._blockListeners.delete(listener);\n                if (this._blockListeners.size === 0) {\n                    this._stopBlockEvents();\n                }\n            }\n            return this;\n        }\n        getTransactionReceipt(transactionHash) {\n            var _a;\n            return ((_a = this._wsProvider) === null || _a === void 0 ? void 0 : _a.ready) ? this._wsProvider.getTransactionReceipt(transactionHash)\n                : super.getTransactionReceipt(transactionHash);\n        }\n        async _blockContainsTx(blockNumber, txHash) {\n            let block;\n            for (block = null; !block; block = await this.getBlock(blockNumber)) {\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n            return block.transactions.some(txHashInBlock => txHashInBlock === txHash);\n        }\n        async _getTransactionReceiptFromLatest(txHash, latestBlock) {\n            txHash = await txHash;\n            for (let retries = 0;; ++retries) {\n                const receipt = (await this.getTransactionReceipt(txHash));\n                if (latestBlock === undefined ||\n                    (receipt === null && !(await this._blockContainsTx(latestBlock, txHash))) ||\n                    (receipt !== null && receipt.blockNumber + receipt.confirmations - 1 >= latestBlock)) {\n                    if (retries) {\n                        // console.log(`Glitch resolved after ${retries} ${retries === 1 ? \"retry\" : \"retries\"}.`);\n                    }\n                    return receipt;\n                }\n                // console.warn(\"Load balancing glitch. Retrying...\");\n                await delay(loadBalancingGlitchRetryIntervalMs);\n            }\n        }\n        async waitForTransaction(txHash, confirmations, timeout) {\n            if (timeout !== undefined) {\n                // We don't use timeout, don't implement it\n                return super.waitForTransaction(txHash, confirmations, timeout);\n            }\n            let latestBlock = undefined;\n            for (;;) {\n                const receipt = await this._getTransactionReceiptFromLatest(txHash, latestBlock);\n                if (receipt !== null &&\n                    (confirmations === undefined || receipt.confirmations >= confirmations)) {\n                    return receipt;\n                }\n                latestBlock = await new Promise(resolve => this.once(\"block\", resolve));\n            }\n        }\n    };\n    webSocketAugmentedProviders.push(webSocketAugmentedProvider);\n    return webSocketAugmentedProvider;\n};\nexports.WebSocketAugmented = WebSocketAugmented;\nexports.WebSocketAugmentedWeb3Provider = exports.WebSocketAugmented(providers_1.Web3Provider);\n//# sourceMappingURL=WebSocketAugmentedProvider.js.map"]},"metadata":{},"sourceType":"script"}