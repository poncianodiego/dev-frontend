{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockPolledLiquityStore = void 0;\n\nconst constants_1 = require(\"@ethersproject/constants\");\n\nconst lib_base_1 = require(\"@liquity/lib-base\");\n\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nconst promiseAllValues = object => {\n  const keys = Object.keys(object);\n  return Promise.all(Object.values(object)).then(values => Object.fromEntries(values.map((value, i) => [keys[i], value])));\n};\n\nconst decimalify = bigNumber => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n/**\n * Ethers-based {@link @liquity/lib-base#LiquityStore} that updates state whenever there's a new\n * block.\n *\n * @public\n */\n\n\nclass BlockPolledLiquityStore extends lib_base_1.LiquityStore {\n  constructor(readable) {\n    super();\n    this.connection = readable.connection;\n    this._readable = readable;\n    this._provider = EthersLiquityConnection_1._getProvider(readable.connection);\n  }\n\n  async _getRiskiestTroveBeforeRedistribution(overrides) {\n    const riskiestTroves = await this._readable.getTroves({\n      first: 1,\n      sortedBy: \"ascendingCollateralRatio\",\n      beforeRedistribution: true\n    }, overrides);\n\n    if (riskiestTroves.length === 0) {\n      return new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\");\n    }\n\n    return riskiestTroves[0];\n  }\n\n  async _get(blockTag) {\n    const {\n      userAddress,\n      frontendTag\n    } = this.connection;\n    const {\n      blockTimestamp,\n      createFees,\n      calculateRemainingLQTY,\n      ...baseState\n    } = await promiseAllValues({\n      blockTimestamp: EthersLiquityConnection_1._getBlockTimestamp(this.connection, blockTag),\n      createFees: this._readable._getFeesFactory({\n        blockTag\n      }),\n      calculateRemainingLQTY: this._readable._getRemainingLiquidityMiningLQTYRewardCalculator({\n        blockTag\n      }),\n      price: this._readable.getPrice({\n        blockTag\n      }),\n      numberOfTroves: this._readable.getNumberOfTroves({\n        blockTag\n      }),\n      totalRedistributed: this._readable.getTotalRedistributed({\n        blockTag\n      }),\n      total: this._readable.getTotal({\n        blockTag\n      }),\n      lusdInStabilityPool: this._readable.getLUSDInStabilityPool({\n        blockTag\n      }),\n      totalStakedLQTY: this._readable.getTotalStakedLQTY({\n        blockTag\n      }),\n      _riskiestTroveBeforeRedistribution: this._getRiskiestTroveBeforeRedistribution({\n        blockTag\n      }),\n      totalStakedUniTokens: this._readable.getTotalStakedUniTokens({\n        blockTag\n      }),\n      remainingStabilityPoolLQTYReward: this._readable.getRemainingStabilityPoolLQTYReward({\n        blockTag\n      }),\n      frontend: frontendTag ? this._readable.getFrontendStatus(frontendTag, {\n        blockTag\n      }) : {\n        status: \"unregistered\"\n      },\n      ...(userAddress ? {\n        accountBalance: this._provider.getBalance(userAddress, blockTag).then(decimalify),\n        lusdBalance: this._readable.getLUSDBalance(userAddress, {\n          blockTag\n        }),\n        lqtyBalance: this._readable.getLQTYBalance(userAddress, {\n          blockTag\n        }),\n        uniTokenBalance: this._readable.getUniTokenBalance(userAddress, {\n          blockTag\n        }),\n        uniTokenAllowance: this._readable.getUniTokenAllowance(userAddress, {\n          blockTag\n        }),\n        liquidityMiningStake: this._readable.getLiquidityMiningStake(userAddress, {\n          blockTag\n        }),\n        liquidityMiningLQTYReward: this._readable.getLiquidityMiningLQTYReward(userAddress, {\n          blockTag\n        }),\n        collateralSurplusBalance: this._readable.getCollateralSurplusBalance(userAddress, {\n          blockTag\n        }),\n        troveBeforeRedistribution: this._readable.getTroveBeforeRedistribution(userAddress, {\n          blockTag\n        }),\n        stabilityDeposit: this._readable.getStabilityDeposit(userAddress, {\n          blockTag\n        }),\n        lqtyStake: this._readable.getLQTYStake(userAddress, {\n          blockTag\n        }),\n        ownFrontend: this._readable.getFrontendStatus(userAddress, {\n          blockTag\n        })\n      } : {\n        accountBalance: lib_base_1.Decimal.ZERO,\n        lusdBalance: lib_base_1.Decimal.ZERO,\n        lqtyBalance: lib_base_1.Decimal.ZERO,\n        uniTokenBalance: lib_base_1.Decimal.ZERO,\n        uniTokenAllowance: lib_base_1.Decimal.ZERO,\n        liquidityMiningStake: lib_base_1.Decimal.ZERO,\n        liquidityMiningLQTYReward: lib_base_1.Decimal.ZERO,\n        collateralSurplusBalance: lib_base_1.Decimal.ZERO,\n        troveBeforeRedistribution: new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\"),\n        stabilityDeposit: new lib_base_1.StabilityDeposit(lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, constants_1.AddressZero),\n        lqtyStake: new lib_base_1.LQTYStake(),\n        ownFrontend: {\n          status: \"unregistered\"\n        }\n      })\n    });\n    return [{ ...baseState,\n      _feesInNormalMode: createFees(blockTimestamp, false),\n      remainingLiquidityMiningLQTYReward: calculateRemainingLQTY(blockTimestamp)\n    }, {\n      blockTag,\n      blockTimestamp\n    }];\n  }\n  /** @internal @override */\n\n\n  _doStart() {\n    this._get().then(state => {\n      if (!this._loaded) {\n        this._load(...state);\n      }\n    });\n\n    const blockListener = async blockTag => {\n      const state = await this._get(blockTag);\n\n      if (this._loaded) {\n        this._update(...state);\n      } else {\n        this._load(...state);\n      }\n    };\n\n    this._provider.on(\"block\", blockListener);\n\n    return () => {\n      this._provider.off(\"block\", blockListener);\n    };\n  }\n  /** @internal @override */\n\n\n  _reduceExtra(oldState, stateUpdate) {\n    var _a, _b;\n\n    return {\n      blockTag: (_a = stateUpdate.blockTag) !== null && _a !== void 0 ? _a : oldState.blockTag,\n      blockTimestamp: (_b = stateUpdate.blockTimestamp) !== null && _b !== void 0 ? _b : oldState.blockTimestamp\n    };\n  }\n\n}\n\nexports.BlockPolledLiquityStore = BlockPolledLiquityStore;","map":{"version":3,"sources":["../../src/BlockPolledLiquityStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockPolledLiquityStore = void 0;\nconst constants_1 = require(\"@ethersproject/constants\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst promiseAllValues = (object) => {\n    const keys = Object.keys(object);\n    return Promise.all(Object.values(object)).then(values => Object.fromEntries(values.map((value, i) => [keys[i], value])));\n};\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n/**\n * Ethers-based {@link @liquity/lib-base#LiquityStore} that updates state whenever there's a new\n * block.\n *\n * @public\n */\nclass BlockPolledLiquityStore extends lib_base_1.LiquityStore {\n    constructor(readable) {\n        super();\n        this.connection = readable.connection;\n        this._readable = readable;\n        this._provider = EthersLiquityConnection_1._getProvider(readable.connection);\n    }\n    async _getRiskiestTroveBeforeRedistribution(overrides) {\n        const riskiestTroves = await this._readable.getTroves({ first: 1, sortedBy: \"ascendingCollateralRatio\", beforeRedistribution: true }, overrides);\n        if (riskiestTroves.length === 0) {\n            return new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\");\n        }\n        return riskiestTroves[0];\n    }\n    async _get(blockTag) {\n        const { userAddress, frontendTag } = this.connection;\n        const { blockTimestamp, createFees, calculateRemainingLQTY, ...baseState } = await promiseAllValues({\n            blockTimestamp: EthersLiquityConnection_1._getBlockTimestamp(this.connection, blockTag),\n            createFees: this._readable._getFeesFactory({ blockTag }),\n            calculateRemainingLQTY: this._readable._getRemainingLiquidityMiningLQTYRewardCalculator({\n                blockTag\n            }),\n            price: this._readable.getPrice({ blockTag }),\n            numberOfTroves: this._readable.getNumberOfTroves({ blockTag }),\n            totalRedistributed: this._readable.getTotalRedistributed({ blockTag }),\n            total: this._readable.getTotal({ blockTag }),\n            lusdInStabilityPool: this._readable.getLUSDInStabilityPool({ blockTag }),\n            totalStakedLQTY: this._readable.getTotalStakedLQTY({ blockTag }),\n            _riskiestTroveBeforeRedistribution: this._getRiskiestTroveBeforeRedistribution({ blockTag }),\n            totalStakedUniTokens: this._readable.getTotalStakedUniTokens({ blockTag }),\n            remainingStabilityPoolLQTYReward: this._readable.getRemainingStabilityPoolLQTYReward({\n                blockTag\n            }),\n            frontend: frontendTag\n                ? this._readable.getFrontendStatus(frontendTag, { blockTag })\n                : { status: \"unregistered\" },\n            ...(userAddress\n                ? {\n                    accountBalance: this._provider.getBalance(userAddress, blockTag).then(decimalify),\n                    lusdBalance: this._readable.getLUSDBalance(userAddress, { blockTag }),\n                    lqtyBalance: this._readable.getLQTYBalance(userAddress, { blockTag }),\n                    uniTokenBalance: this._readable.getUniTokenBalance(userAddress, { blockTag }),\n                    uniTokenAllowance: this._readable.getUniTokenAllowance(userAddress, { blockTag }),\n                    liquidityMiningStake: this._readable.getLiquidityMiningStake(userAddress, { blockTag }),\n                    liquidityMiningLQTYReward: this._readable.getLiquidityMiningLQTYReward(userAddress, {\n                        blockTag\n                    }),\n                    collateralSurplusBalance: this._readable.getCollateralSurplusBalance(userAddress, {\n                        blockTag\n                    }),\n                    troveBeforeRedistribution: this._readable.getTroveBeforeRedistribution(userAddress, {\n                        blockTag\n                    }),\n                    stabilityDeposit: this._readable.getStabilityDeposit(userAddress, { blockTag }),\n                    lqtyStake: this._readable.getLQTYStake(userAddress, { blockTag }),\n                    ownFrontend: this._readable.getFrontendStatus(userAddress, { blockTag })\n                }\n                : {\n                    accountBalance: lib_base_1.Decimal.ZERO,\n                    lusdBalance: lib_base_1.Decimal.ZERO,\n                    lqtyBalance: lib_base_1.Decimal.ZERO,\n                    uniTokenBalance: lib_base_1.Decimal.ZERO,\n                    uniTokenAllowance: lib_base_1.Decimal.ZERO,\n                    liquidityMiningStake: lib_base_1.Decimal.ZERO,\n                    liquidityMiningLQTYReward: lib_base_1.Decimal.ZERO,\n                    collateralSurplusBalance: lib_base_1.Decimal.ZERO,\n                    troveBeforeRedistribution: new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\"),\n                    stabilityDeposit: new lib_base_1.StabilityDeposit(lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, constants_1.AddressZero),\n                    lqtyStake: new lib_base_1.LQTYStake(),\n                    ownFrontend: { status: \"unregistered\" }\n                })\n        });\n        return [\n            {\n                ...baseState,\n                _feesInNormalMode: createFees(blockTimestamp, false),\n                remainingLiquidityMiningLQTYReward: calculateRemainingLQTY(blockTimestamp)\n            },\n            {\n                blockTag,\n                blockTimestamp\n            }\n        ];\n    }\n    /** @internal @override */\n    _doStart() {\n        this._get().then(state => {\n            if (!this._loaded) {\n                this._load(...state);\n            }\n        });\n        const blockListener = async (blockTag) => {\n            const state = await this._get(blockTag);\n            if (this._loaded) {\n                this._update(...state);\n            }\n            else {\n                this._load(...state);\n            }\n        };\n        this._provider.on(\"block\", blockListener);\n        return () => {\n            this._provider.off(\"block\", blockListener);\n        };\n    }\n    /** @internal @override */\n    _reduceExtra(oldState, stateUpdate) {\n        var _a, _b;\n        return {\n            blockTag: (_a = stateUpdate.blockTag) !== null && _a !== void 0 ? _a : oldState.blockTag,\n            blockTimestamp: (_b = stateUpdate.blockTimestamp) !== null && _b !== void 0 ? _b : oldState.blockTimestamp\n        };\n    }\n}\nexports.BlockPolledLiquityStore = BlockPolledLiquityStore;\n//# sourceMappingURL=BlockPolledLiquityStore.js.map"]},"metadata":{},"sourceType":"script"}