{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectWithoutProperties = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _toArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _objectSpread = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _asyncToGenerator = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _regeneratorRuntime = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(generateTrials);\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PopulatableEthersLiquity = exports.PopulatedEthersRedemption = exports.PopulatedEthersLiquityTransaction = exports.SentEthersLiquityTransaction = exports._redeemMaxIterations = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar lib_base_1 = require(\"@liquity/lib-base\");\n\nvar EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nvar contracts_1 = require(\"./contracts\");\n\nvar parseLogs_1 = require(\"./parseLogs\");\n\nvar decimalify = function decimalify(bigNumber) {\n  return lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n}; // With 70 iterations redemption costs about ~10M gas, and each iteration accounts for ~138k more\n\n/** @internal */\n\n\nexports._redeemMaxIterations = 70;\nvar defaultBorrowingRateSlippageTolerance = lib_base_1.Decimal.from(0.005); // 0.5%\n\nvar defaultRedemptionRateSlippageTolerance = lib_base_1.Decimal.from(0.001); // 0.1%\n\nvar noDetails = function noDetails() {\n  return undefined;\n};\n\nvar compose = function compose(f, g) {\n  return function (_) {\n    return f(g(_));\n  };\n};\n\nvar id = function id(t) {\n  return t;\n}; // Takes ~6-7K to update lastFeeOperationTime. Let's be on the safe side.\n\n\nvar addGasForPotentialLastFeeOperationTimeUpdate = function addGasForPotentialLastFeeOperationTimeUpdate(gas) {\n  return gas.add(10000);\n}; // First traversal in ascending direction takes ~50K, then ~13.5K per extra step.\n// 80K should be enough for 3 steps, plus some extra to be safe.\n\n\nvar addGasForPotentialListTraversal = function addGasForPotentialListTraversal(gas) {\n  return gas.add(80000);\n};\n\nvar addGasForLQTYIssuance = function addGasForLQTYIssuance(gas) {\n  return gas.add(50000);\n};\n\nvar addGasForUnipoolRewardUpdate = function addGasForUnipoolRewardUpdate(gas) {\n  return gas.add(20000);\n}; // To get the best entropy available, we'd do something like:\n//\n// const bigRandomNumber = () =>\n//   BigNumber.from(\n//     `0x${Array.from(crypto.getRandomValues(new Uint32Array(8)))\n//       .map(u32 => u32.toString(16).padStart(8, \"0\"))\n//       .join(\"\")}`\n//   );\n//\n// However, Window.crypto is browser-specific. Since we only use this for randomly picking Troves\n// during the search for hints, Math.random() will do fine, too.\n//\n// This returns a random integer between 0 and Number.MAX_SAFE_INTEGER\n\n\nvar randomInteger = function randomInteger() {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n}; // Maximum number of trials to perform in a single getApproxHint() call. If the number of trials\n// required to get a statistically \"good\" hint is larger than this, the search for the hint will\n// be broken up into multiple getApproxHint() calls.\n//\n// This should be low enough to work with popular public Ethereum providers like Infura without\n// triggering any fair use limits.\n\n\nvar maxNumberOfTrialsAtOnce = 2500;\n\nfunction generateTrials(totalNumberOfTrials) {\n  var numberOfTrials;\n  return _regeneratorRuntime.wrap(function generateTrials$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          assert_1.default(Number.isInteger(totalNumberOfTrials) && totalNumberOfTrials > 0);\n\n        case 1:\n          if (!totalNumberOfTrials) {\n            _context.next = 8;\n            break;\n          }\n\n          numberOfTrials = Math.min(totalNumberOfTrials, maxNumberOfTrialsAtOnce);\n          _context.next = 5;\n          return numberOfTrials;\n\n        case 5:\n          totalNumberOfTrials -= numberOfTrials;\n          _context.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * A transaction that has already been sent.\n *\n * @remarks\n * Returned by {@link SendableEthersLiquity} functions.\n *\n * @public\n */\n\n\nvar SentEthersLiquityTransaction = /*#__PURE__*/function () {\n  /** @internal */\n  function SentEthersLiquityTransaction(rawSentTransaction, connection, parse) {\n    _classCallCheck(this, SentEthersLiquityTransaction);\n\n    this.rawSentTransaction = rawSentTransaction;\n    this._connection = connection;\n    this._parse = parse;\n  }\n\n  _createClass(SentEthersLiquityTransaction, [{\n    key: \"_receiptFrom\",\n    value: function _receiptFrom(rawReceipt) {\n      var _this = this;\n\n      return rawReceipt ? rawReceipt.status ? lib_base_1._successfulReceipt(rawReceipt, this._parse(rawReceipt), function () {\n        return parseLogs_1.logsToString(rawReceipt, EthersLiquityConnection_1._getContracts(_this._connection));\n      }) : lib_base_1._failedReceipt(rawReceipt) : lib_base_1._pendingReceipt;\n    }\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.getReceipt} */\n\n  }, {\n    key: \"getReceipt\",\n    value: function () {\n      var _getReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = this;\n                _context2.next = 3;\n                return EthersLiquityConnection_1._getProvider(this._connection).getTransactionReceipt(this.rawSentTransaction.hash);\n\n              case 3:\n                _context2.t1 = _context2.sent;\n                return _context2.abrupt(\"return\", _context2.t0._receiptFrom.call(_context2.t0, _context2.t1));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getReceipt() {\n        return _getReceipt.apply(this, arguments);\n      }\n\n      return getReceipt;\n    }()\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.waitForReceipt} */\n\n  }, {\n    key: \"waitForReceipt\",\n    value: function () {\n      var _waitForReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var receipt;\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = this;\n                _context3.next = 3;\n                return EthersLiquityConnection_1._getProvider(this._connection).waitForTransaction(this.rawSentTransaction.hash);\n\n              case 3:\n                _context3.t1 = _context3.sent;\n                receipt = _context3.t0._receiptFrom.call(_context3.t0, _context3.t1);\n                assert_1.default(receipt.status !== \"pending\");\n                return _context3.abrupt(\"return\", receipt);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function waitForReceipt() {\n        return _waitForReceipt.apply(this, arguments);\n      }\n\n      return waitForReceipt;\n    }()\n  }]);\n\n  return SentEthersLiquityTransaction;\n}();\n\nexports.SentEthersLiquityTransaction = SentEthersLiquityTransaction;\n/**\n * A transaction that has been prepared for sending.\n *\n * @remarks\n * Returned by {@link PopulatableEthersLiquity} functions.\n *\n * @public\n */\n\nvar PopulatedEthersLiquityTransaction = /*#__PURE__*/function () {\n  /** @internal */\n  function PopulatedEthersLiquityTransaction(rawPopulatedTransaction, connection, parse) {\n    _classCallCheck(this, PopulatedEthersLiquityTransaction);\n\n    this.rawPopulatedTransaction = rawPopulatedTransaction;\n    this._connection = connection;\n    this._parse = parse;\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatedLiquityTransaction.send} */\n\n\n  _createClass(PopulatedEthersLiquityTransaction, [{\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.t0 = SentEthersLiquityTransaction;\n                _context4.next = 3;\n                return EthersLiquityConnection_1._requireSigner(this._connection).sendTransaction(this.rawPopulatedTransaction);\n\n              case 3:\n                _context4.t1 = _context4.sent;\n                _context4.t2 = this._connection;\n                _context4.t3 = this._parse;\n                return _context4.abrupt(\"return\", new _context4.t0(_context4.t1, _context4.t2, _context4.t3));\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function send() {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }]);\n\n  return PopulatedEthersLiquityTransaction;\n}();\n\nexports.PopulatedEthersLiquityTransaction = PopulatedEthersLiquityTransaction;\n/**\n * {@inheritDoc @liquity/lib-base#PopulatedRedemption}\n *\n * @public\n */\n\nvar PopulatedEthersRedemption = /*#__PURE__*/function (_PopulatedEthersLiqui) {\n  _inherits(PopulatedEthersRedemption, _PopulatedEthersLiqui);\n\n  var _super = _createSuper(PopulatedEthersRedemption);\n\n  /** @internal */\n  function PopulatedEthersRedemption(rawPopulatedTransaction, connection, attemptedLUSDAmount, redeemableLUSDAmount, increaseAmountByMinimumNetDebt) {\n    var _this2;\n\n    _classCallCheck(this, PopulatedEthersRedemption);\n\n    var _EthersLiquityConnect = EthersLiquityConnection_1._getContracts(connection),\n        troveManager = _EthersLiquityConnect.troveManager;\n\n    _this2 = _super.call(this, rawPopulatedTransaction, connection, function (_ref) {\n      var logs = _ref.logs;\n      return troveManager.extractEvents(logs, \"Redemption\").map(function (_ref2) {\n        var _ref2$args = _ref2.args,\n            _ETHSent = _ref2$args._ETHSent,\n            _ETHFee = _ref2$args._ETHFee,\n            _actualLUSDAmount = _ref2$args._actualLUSDAmount,\n            _attemptedLUSDAmount = _ref2$args._attemptedLUSDAmount;\n        return {\n          attemptedLUSDAmount: decimalify(_attemptedLUSDAmount),\n          actualLUSDAmount: decimalify(_actualLUSDAmount),\n          collateralTaken: decimalify(_ETHSent),\n          fee: decimalify(_ETHFee)\n        };\n      })[0];\n    });\n    _this2.attemptedLUSDAmount = attemptedLUSDAmount;\n    _this2.redeemableLUSDAmount = redeemableLUSDAmount;\n    _this2.isTruncated = redeemableLUSDAmount.lt(attemptedLUSDAmount);\n    _this2._increaseAmountByMinimumNetDebt = increaseAmountByMinimumNetDebt;\n    return _this2;\n  }\n  /** {@inheritDoc @liquity/lib-base#PopulatedRedemption.increaseAmountByMinimumNetDebt} */\n\n\n  _createClass(PopulatedEthersRedemption, [{\n    key: \"increaseAmountByMinimumNetDebt\",\n    value: function increaseAmountByMinimumNetDebt(maxRedemptionRate) {\n      if (!this._increaseAmountByMinimumNetDebt) {\n        throw new Error(\"PopulatedEthersRedemption: increaseAmountByMinimumNetDebt() can \" + \"only be called when amount is truncated\");\n      }\n\n      return this._increaseAmountByMinimumNetDebt(maxRedemptionRate);\n    }\n  }]);\n\n  return PopulatedEthersRedemption;\n}(PopulatedEthersLiquityTransaction);\n\nexports.PopulatedEthersRedemption = PopulatedEthersRedemption;\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#PopulatableLiquity}.\n *\n * @public\n */\n\nvar PopulatableEthersLiquity = /*#__PURE__*/function () {\n  function PopulatableEthersLiquity(readable) {\n    _classCallCheck(this, PopulatableEthersLiquity);\n\n    this._readable = readable;\n  }\n\n  _createClass(PopulatableEthersLiquity, [{\n    key: \"_wrapSimpleTransaction\",\n    value: function _wrapSimpleTransaction(rawPopulatedTransaction) {\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, noDetails);\n    }\n  }, {\n    key: \"_wrapTroveChangeWithFees\",\n    value: function _wrapTroveChangeWithFees(params, rawPopulatedTransaction) {\n      var _EthersLiquityConnect2 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          borrowerOperations = _EthersLiquityConnect2.borrowerOperations;\n\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref3) {\n        var logs = _ref3.logs;\n\n        var _borrowerOperations$e = borrowerOperations.extractEvents(logs, \"TroveUpdated\").map(function (_ref4) {\n          var _ref4$args = _ref4.args,\n              _coll = _ref4$args._coll,\n              _debt = _ref4$args._debt;\n          return new lib_base_1.Trove(decimalify(_coll), decimalify(_debt));\n        }),\n            _borrowerOperations$e2 = _slicedToArray(_borrowerOperations$e, 1),\n            newTrove = _borrowerOperations$e2[0];\n\n        var _borrowerOperations$e3 = borrowerOperations.extractEvents(logs, \"LUSDBorrowingFeePaid\").map(function (_ref5) {\n          var _LUSDFee = _ref5.args._LUSDFee;\n          return decimalify(_LUSDFee);\n        }),\n            _borrowerOperations$e4 = _slicedToArray(_borrowerOperations$e3, 1),\n            fee = _borrowerOperations$e4[0];\n\n        return {\n          params: params,\n          newTrove: newTrove,\n          fee: fee\n        };\n      });\n    }\n  }, {\n    key: \"_wrapTroveClosure\",\n    value: function () {\n      var _wrapTroveClosure2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(rawPopulatedTransaction) {\n        var _EthersLiquityConnect3, activePool, lusdToken;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _EthersLiquityConnect3 = EthersLiquityConnection_1._getContracts(this._readable.connection), activePool = _EthersLiquityConnect3.activePool, lusdToken = _EthersLiquityConnect3.lusdToken;\n                return _context5.abrupt(\"return\", new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref6) {\n                  var logs = _ref6.logs,\n                      userAddress = _ref6.from;\n\n                  var _lusdToken$extractEve = lusdToken.extractEvents(logs, \"Transfer\").filter(function (_ref7) {\n                    var _ref7$args = _ref7.args,\n                        from = _ref7$args.from,\n                        to = _ref7$args.to;\n                    return from === userAddress && to === constants_1.AddressZero;\n                  }).map(function (_ref8) {\n                    var value = _ref8.args.value;\n                    return decimalify(value);\n                  }),\n                      _lusdToken$extractEve2 = _slicedToArray(_lusdToken$extractEve, 1),\n                      repayLUSD = _lusdToken$extractEve2[0];\n\n                  var _activePool$extractEv = activePool.extractEvents(logs, \"EtherSent\").filter(function (_ref9) {\n                    var _to = _ref9.args._to;\n                    return _to === userAddress;\n                  }).map(function (_ref10) {\n                    var _amount = _ref10.args._amount;\n                    return decimalify(_amount);\n                  }),\n                      _activePool$extractEv2 = _slicedToArray(_activePool$extractEv, 1),\n                      withdrawCollateral = _activePool$extractEv2[0];\n\n                  return {\n                    params: repayLUSD.nonZero ? {\n                      withdrawCollateral: withdrawCollateral,\n                      repayLUSD: repayLUSD\n                    } : {\n                      withdrawCollateral: withdrawCollateral\n                    }\n                  };\n                }));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _wrapTroveClosure(_x) {\n        return _wrapTroveClosure2.apply(this, arguments);\n      }\n\n      return _wrapTroveClosure;\n    }()\n  }, {\n    key: \"_wrapLiquidation\",\n    value: function _wrapLiquidation(rawPopulatedTransaction) {\n      var _EthersLiquityConnect4 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          troveManager = _EthersLiquityConnect4.troveManager;\n\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref11) {\n        var logs = _ref11.logs;\n        var liquidatedAddresses = troveManager.extractEvents(logs, \"TroveLiquidated\").map(function (_ref12) {\n          var _borrower = _ref12.args._borrower;\n          return _borrower;\n        });\n\n        var _troveManager$extract = troveManager.extractEvents(logs, \"Liquidation\").map(function (_ref13) {\n          var _ref13$args = _ref13.args,\n              _LUSDGasCompensation = _ref13$args._LUSDGasCompensation,\n              _collGasCompensation = _ref13$args._collGasCompensation,\n              _liquidatedColl = _ref13$args._liquidatedColl,\n              _liquidatedDebt = _ref13$args._liquidatedDebt;\n          return {\n            collateralGasCompensation: decimalify(_collGasCompensation),\n            lusdGasCompensation: decimalify(_LUSDGasCompensation),\n            totalLiquidated: new lib_base_1.Trove(decimalify(_liquidatedColl), decimalify(_liquidatedDebt))\n          };\n        }),\n            _troveManager$extract2 = _slicedToArray(_troveManager$extract, 1),\n            totals = _troveManager$extract2[0];\n\n        return _objectSpread({\n          liquidatedAddresses: liquidatedAddresses\n        }, totals);\n      });\n    }\n  }, {\n    key: \"_extractStabilityPoolGainsWithdrawalDetails\",\n    value: function _extractStabilityPoolGainsWithdrawalDetails(logs) {\n      var _EthersLiquityConnect5 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          stabilityPool = _EthersLiquityConnect5.stabilityPool;\n\n      var _stabilityPool$extrac = stabilityPool.extractEvents(logs, \"UserDepositChanged\").map(function (_ref14) {\n        var _newDeposit = _ref14.args._newDeposit;\n        return decimalify(_newDeposit);\n      }),\n          _stabilityPool$extrac2 = _slicedToArray(_stabilityPool$extrac, 1),\n          newLUSDDeposit = _stabilityPool$extrac2[0];\n\n      var _stabilityPool$extrac3 = stabilityPool.extractEvents(logs, \"ETHGainWithdrawn\").map(function (_ref15) {\n        var _ref15$args = _ref15.args,\n            _ETH = _ref15$args._ETH,\n            _LUSDLoss = _ref15$args._LUSDLoss;\n        return [decimalify(_ETH), decimalify(_LUSDLoss)];\n      }),\n          _stabilityPool$extrac4 = _slicedToArray(_stabilityPool$extrac3, 1),\n          _stabilityPool$extrac5 = _slicedToArray(_stabilityPool$extrac4[0], 2),\n          collateralGain = _stabilityPool$extrac5[0],\n          lusdLoss = _stabilityPool$extrac5[1];\n\n      var _stabilityPool$extrac6 = stabilityPool.extractEvents(logs, \"LQTYPaidToDepositor\").map(function (_ref16) {\n        var _LQTY = _ref16.args._LQTY;\n        return decimalify(_LQTY);\n      }),\n          _stabilityPool$extrac7 = _slicedToArray(_stabilityPool$extrac6, 1),\n          lqtyReward = _stabilityPool$extrac7[0];\n\n      return {\n        lusdLoss: lusdLoss,\n        newLUSDDeposit: newLUSDDeposit,\n        collateralGain: collateralGain,\n        lqtyReward: lqtyReward\n      };\n    }\n  }, {\n    key: \"_wrapStabilityPoolGainsWithdrawal\",\n    value: function _wrapStabilityPoolGainsWithdrawal(rawPopulatedTransaction) {\n      var _this3 = this;\n\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref17) {\n        var logs = _ref17.logs;\n        return _this3._extractStabilityPoolGainsWithdrawalDetails(logs);\n      });\n    }\n  }, {\n    key: \"_wrapStabilityDepositTopup\",\n    value: function _wrapStabilityDepositTopup(change, rawPopulatedTransaction) {\n      var _this4 = this;\n\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref18) {\n        var logs = _ref18.logs;\n        return _objectSpread(_objectSpread({}, _this4._extractStabilityPoolGainsWithdrawalDetails(logs)), {}, {\n          change: change\n        });\n      });\n    }\n  }, {\n    key: \"_wrapStabilityDepositWithdrawal\",\n    value: function () {\n      var _wrapStabilityDepositWithdrawal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(rawPopulatedTransaction) {\n        var _this5 = this;\n\n        var _EthersLiquityConnect6, stabilityPool, lusdToken;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _EthersLiquityConnect6 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect6.stabilityPool, lusdToken = _EthersLiquityConnect6.lusdToken;\n                return _context6.abrupt(\"return\", new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref19) {\n                  var logs = _ref19.logs,\n                      userAddress = _ref19.from;\n\n                  var gainsWithdrawalDetails = _this5._extractStabilityPoolGainsWithdrawalDetails(logs);\n\n                  var _lusdToken$extractEve3 = lusdToken.extractEvents(logs, \"Transfer\").filter(function (_ref20) {\n                    var _ref20$args = _ref20.args,\n                        from = _ref20$args.from,\n                        to = _ref20$args.to;\n                    return from === stabilityPool.address && to === userAddress;\n                  }).map(function (_ref21) {\n                    var value = _ref21.args.value;\n                    return decimalify(value);\n                  }),\n                      _lusdToken$extractEve4 = _slicedToArray(_lusdToken$extractEve3, 1),\n                      withdrawLUSD = _lusdToken$extractEve4[0];\n\n                  return _objectSpread(_objectSpread({}, gainsWithdrawalDetails), {}, {\n                    change: {\n                      withdrawLUSD: withdrawLUSD,\n                      withdrawAllLUSD: gainsWithdrawalDetails.newLUSDDeposit.isZero\n                    }\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _wrapStabilityDepositWithdrawal(_x2) {\n        return _wrapStabilityDepositWithdrawal2.apply(this, arguments);\n      }\n\n      return _wrapStabilityDepositWithdrawal;\n    }()\n  }, {\n    key: \"_wrapCollateralGainTransfer\",\n    value: function _wrapCollateralGainTransfer(rawPopulatedTransaction) {\n      var _this6 = this;\n\n      var _EthersLiquityConnect7 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          borrowerOperations = _EthersLiquityConnect7.borrowerOperations;\n\n      return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, function (_ref22) {\n        var logs = _ref22.logs;\n\n        var _borrowerOperations$e5 = borrowerOperations.extractEvents(logs, \"TroveUpdated\").map(function (_ref23) {\n          var _ref23$args = _ref23.args,\n              _coll = _ref23$args._coll,\n              _debt = _ref23$args._debt;\n          return new lib_base_1.Trove(decimalify(_coll), decimalify(_debt));\n        }),\n            _borrowerOperations$e6 = _slicedToArray(_borrowerOperations$e5, 1),\n            newTrove = _borrowerOperations$e6[0];\n\n        return _objectSpread(_objectSpread({}, _this6._extractStabilityPoolGainsWithdrawalDetails(logs)), {}, {\n          newTrove: newTrove\n        });\n      });\n    }\n  }, {\n    key: \"_findHintsForNominalCollateralRatio\",\n    value: function () {\n      var _findHintsForNominalCollateralRatio2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(nominalCollateralRatio) {\n        var _EthersLiquityConnect8, sortedTroves, hintHelpers, numberOfTroves, totalNumberOfTrials, _generateTrials, _generateTrials2, firstTrials, restOfTrials, collectApproxHint, _yield$restOfTrials$r, results, _results$reduce, hintAddress;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _EthersLiquityConnect8 = EthersLiquityConnection_1._getContracts(this._readable.connection), sortedTroves = _EthersLiquityConnect8.sortedTroves, hintHelpers = _EthersLiquityConnect8.hintHelpers;\n                _context7.next = 3;\n                return this._readable.getNumberOfTroves();\n\n              case 3:\n                numberOfTroves = _context7.sent;\n\n                if (numberOfTroves) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", [constants_1.AddressZero, constants_1.AddressZero]);\n\n              case 6:\n                if (!nominalCollateralRatio.infinite) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                _context7.t0 = constants_1.AddressZero;\n                _context7.next = 10;\n                return sortedTroves.getFirst();\n\n              case 10:\n                _context7.t1 = _context7.sent;\n                return _context7.abrupt(\"return\", [_context7.t0, _context7.t1]);\n\n              case 12:\n                totalNumberOfTrials = Math.ceil(10 * Math.sqrt(numberOfTroves));\n                _generateTrials = generateTrials(totalNumberOfTrials), _generateTrials2 = _toArray(_generateTrials), firstTrials = _generateTrials2[0], restOfTrials = _generateTrials2.slice(1);\n\n                collectApproxHint = function collectApproxHint(_ref24, numberOfTrials) {\n                  var latestRandomSeed = _ref24.latestRandomSeed,\n                      results = _ref24.results;\n                  return hintHelpers.getApproxHint(nominalCollateralRatio.hex, numberOfTrials, latestRandomSeed).then(function (_ref25) {\n                    var latestRandomSeed = _ref25.latestRandomSeed,\n                        result = _objectWithoutProperties(_ref25, [\"latestRandomSeed\"]);\n\n                    return {\n                      latestRandomSeed: latestRandomSeed,\n                      results: [].concat(_toConsumableArray(results), [result])\n                    };\n                  });\n                };\n\n                _context7.next = 17;\n                return restOfTrials.reduce(function (p, numberOfTrials) {\n                  return p.then(function (state) {\n                    return collectApproxHint(state, numberOfTrials);\n                  });\n                }, collectApproxHint({\n                  latestRandomSeed: randomInteger(),\n                  results: []\n                }, firstTrials));\n\n              case 17:\n                _yield$restOfTrials$r = _context7.sent;\n                results = _yield$restOfTrials$r.results;\n                _results$reduce = results.reduce(function (a, b) {\n                  return a.diff.lt(b.diff) ? a : b;\n                }), hintAddress = _results$reduce.hintAddress;\n                return _context7.abrupt(\"return\", sortedTroves.findInsertPosition(nominalCollateralRatio.hex, hintAddress, hintAddress));\n\n              case 21:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _findHintsForNominalCollateralRatio(_x3) {\n        return _findHintsForNominalCollateralRatio2.apply(this, arguments);\n      }\n\n      return _findHintsForNominalCollateralRatio;\n    }()\n  }, {\n    key: \"_findHints\",\n    value: function () {\n      var _findHints2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(trove) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(trove instanceof lib_base_1.TroveWithPendingRedistribution)) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Rewards must be applied to this Trove\");\n\n              case 2:\n                return _context8.abrupt(\"return\", this._findHintsForNominalCollateralRatio(trove._nominalCollateralRatio));\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _findHints(_x4) {\n        return _findHints2.apply(this, arguments);\n      }\n\n      return _findHints;\n    }()\n  }, {\n    key: \"_findRedemptionHints\",\n    value: function () {\n      var _findRedemptionHints2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(amount) {\n        var _EthersLiquityConnect9, hintHelpers, price, _yield$hintHelpers$ge, firstRedemptionHint, partialRedemptionHintNICR, truncatedLUSDamount, _ref26, _ref27, partialRedemptionUpperHint, partialRedemptionLowerHint;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _EthersLiquityConnect9 = EthersLiquityConnection_1._getContracts(this._readable.connection), hintHelpers = _EthersLiquityConnect9.hintHelpers;\n                _context9.next = 3;\n                return this._readable.getPrice();\n\n              case 3:\n                price = _context9.sent;\n                _context9.next = 6;\n                return hintHelpers.getRedemptionHints(amount.hex, price.hex, exports._redeemMaxIterations);\n\n              case 6:\n                _yield$hintHelpers$ge = _context9.sent;\n                firstRedemptionHint = _yield$hintHelpers$ge.firstRedemptionHint;\n                partialRedemptionHintNICR = _yield$hintHelpers$ge.partialRedemptionHintNICR;\n                truncatedLUSDamount = _yield$hintHelpers$ge.truncatedLUSDamount;\n\n                if (!partialRedemptionHintNICR.isZero()) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                _context9.t0 = [constants_1.AddressZero, constants_1.AddressZero];\n                _context9.next = 17;\n                break;\n\n              case 14:\n                _context9.next = 16;\n                return this._findHintsForNominalCollateralRatio(decimalify(partialRedemptionHintNICR));\n\n              case 16:\n                _context9.t0 = _context9.sent;\n\n              case 17:\n                _ref26 = _context9.t0;\n                _ref27 = _slicedToArray(_ref26, 2);\n                partialRedemptionUpperHint = _ref27[0];\n                partialRedemptionLowerHint = _ref27[1];\n                return _context9.abrupt(\"return\", [decimalify(truncatedLUSDamount), firstRedemptionHint, partialRedemptionUpperHint, partialRedemptionLowerHint, partialRedemptionHintNICR]);\n\n              case 22:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _findRedemptionHints(_x5) {\n        return _findRedemptionHints2.apply(this, arguments);\n      }\n\n      return _findRedemptionHints;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.openTrove} */\n\n  }, {\n    key: \"openTrove\",\n    value: function () {\n      var _openTrove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params, maxBorrowingRate, overrides) {\n        var _borrowerOperations$e7;\n\n        var _EthersLiquityConnect10, borrowerOperations, normalized, depositCollateral, borrowLUSD, fees, borrowingRate, newTrove;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _EthersLiquityConnect10 = EthersLiquityConnection_1._getContracts(this._readable.connection), borrowerOperations = _EthersLiquityConnect10.borrowerOperations;\n                normalized = lib_base_1._normalizeTroveCreation(params);\n                depositCollateral = normalized.depositCollateral, borrowLUSD = normalized.borrowLUSD;\n                _context10.next = 5;\n                return this._readable.getFees();\n\n              case 5:\n                fees = _context10.sent;\n                borrowingRate = fees.borrowingRate();\n                newTrove = lib_base_1.Trove.create(normalized, borrowingRate);\n                maxBorrowingRate = maxBorrowingRate !== undefined ? lib_base_1.Decimal.from(maxBorrowingRate) : borrowingRate.add(defaultBorrowingRateSlippageTolerance);\n                _context10.t0 = this;\n                _context10.t1 = normalized;\n                _context10.t2 = (_borrowerOperations$e7 = borrowerOperations.estimateAndPopulate).openTrove;\n                _context10.t3 = _borrowerOperations$e7;\n                _context10.t4 = [_objectSpread({\n                  value: depositCollateral.hex\n                }, overrides), compose(addGasForPotentialLastFeeOperationTimeUpdate, addGasForPotentialListTraversal), maxBorrowingRate.hex, borrowLUSD.hex];\n                _context10.t5 = _toConsumableArray;\n                _context10.next = 17;\n                return this._findHints(newTrove);\n\n              case 17:\n                _context10.t6 = _context10.sent;\n                _context10.t7 = (0, _context10.t5)(_context10.t6);\n                _context10.t8 = _context10.t4.concat.call(_context10.t4, _context10.t7);\n                _context10.next = 22;\n                return _context10.t2.apply.call(_context10.t2, _context10.t3, _context10.t8);\n\n              case 22:\n                _context10.t9 = _context10.sent;\n                return _context10.abrupt(\"return\", _context10.t0._wrapTroveChangeWithFees.call(_context10.t0, _context10.t1, _context10.t9));\n\n              case 24:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function openTrove(_x6, _x7, _x8) {\n        return _openTrove.apply(this, arguments);\n      }\n\n      return openTrove;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.closeTrove} */\n\n  }, {\n    key: \"closeTrove\",\n    value: function () {\n      var _closeTrove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(overrides) {\n        var _EthersLiquityConnect11, borrowerOperations;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _EthersLiquityConnect11 = EthersLiquityConnection_1._getContracts(this._readable.connection), borrowerOperations = _EthersLiquityConnect11.borrowerOperations;\n                _context11.t0 = this;\n                _context11.next = 4;\n                return borrowerOperations.estimateAndPopulate.closeTrove(_objectSpread({}, overrides), id);\n\n              case 4:\n                _context11.t1 = _context11.sent;\n                return _context11.abrupt(\"return\", _context11.t0._wrapTroveClosure.call(_context11.t0, _context11.t1));\n\n              case 6:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function closeTrove(_x9) {\n        return _closeTrove.apply(this, arguments);\n      }\n\n      return closeTrove;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositCollateral} */\n\n  }, {\n    key: \"depositCollateral\",\n    value: function depositCollateral(amount, overrides) {\n      return this.adjustTrove({\n        depositCollateral: amount\n      }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawCollateral} */\n\n  }, {\n    key: \"withdrawCollateral\",\n    value: function withdrawCollateral(amount, overrides) {\n      return this.adjustTrove({\n        withdrawCollateral: amount\n      }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.borrowLUSD} */\n\n  }, {\n    key: \"borrowLUSD\",\n    value: function borrowLUSD(amount, maxBorrowingRate, overrides) {\n      return this.adjustTrove({\n        borrowLUSD: amount\n      }, maxBorrowingRate, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.repayLUSD} */\n\n  }, {\n    key: \"repayLUSD\",\n    value: function repayLUSD(amount, overrides) {\n      return this.adjustTrove({\n        repayLUSD: amount\n      }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.adjustTrove} */\n\n  }, {\n    key: \"adjustTrove\",\n    value: function () {\n      var _adjustTrove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(params, maxBorrowingRate, overrides) {\n        var _borrowerOperations$e8;\n\n        var _a, _b, address, _EthersLiquityConnect12, borrowerOperations, normalized, depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD, _yield$Promise$all, _yield$Promise$all2, trove, fees, borrowingRate, finalTrove;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n                _EthersLiquityConnect12 = EthersLiquityConnection_1._getContracts(this._readable.connection), borrowerOperations = _EthersLiquityConnect12.borrowerOperations;\n                normalized = lib_base_1._normalizeTroveAdjustment(params);\n                depositCollateral = normalized.depositCollateral, withdrawCollateral = normalized.withdrawCollateral, borrowLUSD = normalized.borrowLUSD, repayLUSD = normalized.repayLUSD;\n                _context12.next = 6;\n                return Promise.all([this._readable.getTrove(address), borrowLUSD && this._readable.getFees()]);\n\n              case 6:\n                _yield$Promise$all = _context12.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                trove = _yield$Promise$all2[0];\n                fees = _yield$Promise$all2[1];\n                borrowingRate = fees === null || fees === void 0 ? void 0 : fees.borrowingRate();\n                finalTrove = trove.adjust(normalized, borrowingRate);\n                maxBorrowingRate = maxBorrowingRate !== undefined ? lib_base_1.Decimal.from(maxBorrowingRate) : (_a = borrowingRate === null || borrowingRate === void 0 ? void 0 : borrowingRate.add(defaultBorrowingRateSlippageTolerance)) !== null && _a !== void 0 ? _a : lib_base_1.Decimal.ZERO;\n                _context12.t0 = this;\n                _context12.t1 = normalized;\n                _context12.t2 = (_borrowerOperations$e8 = borrowerOperations.estimateAndPopulate).adjustTrove;\n                _context12.t3 = _borrowerOperations$e8;\n                _context12.t4 = [_objectSpread({\n                  value: depositCollateral === null || depositCollateral === void 0 ? void 0 : depositCollateral.hex\n                }, overrides), compose(borrowLUSD ? addGasForPotentialLastFeeOperationTimeUpdate : id, addGasForPotentialListTraversal), maxBorrowingRate.hex, (withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : lib_base_1.Decimal.ZERO).hex, ((_b = borrowLUSD !== null && borrowLUSD !== void 0 ? borrowLUSD : repayLUSD) !== null && _b !== void 0 ? _b : lib_base_1.Decimal.ZERO).hex, !!borrowLUSD];\n                _context12.t5 = _toConsumableArray;\n                _context12.next = 21;\n                return this._findHints(finalTrove);\n\n              case 21:\n                _context12.t6 = _context12.sent;\n                _context12.t7 = (0, _context12.t5)(_context12.t6);\n                _context12.t8 = _context12.t4.concat.call(_context12.t4, _context12.t7);\n                _context12.next = 26;\n                return _context12.t2.apply.call(_context12.t2, _context12.t3, _context12.t8);\n\n              case 26:\n                _context12.t9 = _context12.sent;\n                return _context12.abrupt(\"return\", _context12.t0._wrapTroveChangeWithFees.call(_context12.t0, _context12.t1, _context12.t9));\n\n              case 28:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function adjustTrove(_x10, _x11, _x12) {\n        return _adjustTrove.apply(this, arguments);\n      }\n\n      return adjustTrove;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.claimCollateralSurplus} */\n\n  }, {\n    key: \"claimCollateralSurplus\",\n    value: function () {\n      var _claimCollateralSurplus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(overrides) {\n        var _EthersLiquityConnect13, borrowerOperations;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _EthersLiquityConnect13 = EthersLiquityConnection_1._getContracts(this._readable.connection), borrowerOperations = _EthersLiquityConnect13.borrowerOperations;\n                _context13.t0 = this;\n                _context13.next = 4;\n                return borrowerOperations.estimateAndPopulate.claimCollateral(_objectSpread({}, overrides), id);\n\n              case 4:\n                _context13.t1 = _context13.sent;\n                return _context13.abrupt(\"return\", _context13.t0._wrapSimpleTransaction.call(_context13.t0, _context13.t1));\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function claimCollateralSurplus(_x13) {\n        return _claimCollateralSurplus.apply(this, arguments);\n      }\n\n      return claimCollateralSurplus;\n    }()\n    /** @internal */\n\n  }, {\n    key: \"setPrice\",\n    value: function () {\n      var _setPrice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(price, overrides) {\n        var _EthersLiquityConnect14, priceFeed;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _EthersLiquityConnect14 = EthersLiquityConnection_1._getContracts(this._readable.connection), priceFeed = _EthersLiquityConnect14.priceFeed;\n\n                if (contracts_1._priceFeedIsTestnet(priceFeed)) {\n                  _context14.next = 3;\n                  break;\n                }\n\n                throw new Error(\"setPrice() unavailable on this deployment of Liquity\");\n\n              case 3:\n                _context14.t0 = this;\n                _context14.next = 6;\n                return priceFeed.estimateAndPopulate.setPrice(_objectSpread({}, overrides), id, lib_base_1.Decimal.from(price).hex);\n\n              case 6:\n                _context14.t1 = _context14.sent;\n                return _context14.abrupt(\"return\", _context14.t0._wrapSimpleTransaction.call(_context14.t0, _context14.t1));\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function setPrice(_x14, _x15) {\n        return _setPrice.apply(this, arguments);\n      }\n\n      return setPrice;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidate} */\n\n  }, {\n    key: \"liquidate\",\n    value: function () {\n      var _liquidate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(address, overrides) {\n        var _EthersLiquityConnect15, troveManager;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _EthersLiquityConnect15 = EthersLiquityConnection_1._getContracts(this._readable.connection), troveManager = _EthersLiquityConnect15.troveManager;\n\n                if (!Array.isArray(address)) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                _context15.t0 = this;\n                _context15.next = 5;\n                return troveManager.estimateAndPopulate.batchLiquidateTroves(_objectSpread({}, overrides), addGasForLQTYIssuance, address);\n\n              case 5:\n                _context15.t1 = _context15.sent;\n                return _context15.abrupt(\"return\", _context15.t0._wrapLiquidation.call(_context15.t0, _context15.t1));\n\n              case 9:\n                _context15.t2 = this;\n                _context15.next = 12;\n                return troveManager.estimateAndPopulate.liquidate(_objectSpread({}, overrides), addGasForLQTYIssuance, address);\n\n              case 12:\n                _context15.t3 = _context15.sent;\n                return _context15.abrupt(\"return\", _context15.t2._wrapLiquidation.call(_context15.t2, _context15.t3));\n\n              case 14:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function liquidate(_x16, _x17) {\n        return _liquidate.apply(this, arguments);\n      }\n\n      return liquidate;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidateUpTo} */\n\n  }, {\n    key: \"liquidateUpTo\",\n    value: function () {\n      var _liquidateUpTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(maximumNumberOfTrovesToLiquidate, overrides) {\n        var _EthersLiquityConnect16, troveManager;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _EthersLiquityConnect16 = EthersLiquityConnection_1._getContracts(this._readable.connection), troveManager = _EthersLiquityConnect16.troveManager;\n                _context16.t0 = this;\n                _context16.next = 4;\n                return troveManager.estimateAndPopulate.liquidateTroves(_objectSpread({}, overrides), addGasForLQTYIssuance, maximumNumberOfTrovesToLiquidate);\n\n              case 4:\n                _context16.t1 = _context16.sent;\n                return _context16.abrupt(\"return\", _context16.t0._wrapLiquidation.call(_context16.t0, _context16.t1));\n\n              case 6:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function liquidateUpTo(_x18, _x19) {\n        return _liquidateUpTo.apply(this, arguments);\n      }\n\n      return liquidateUpTo;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositLUSDInStabilityPool} */\n\n  }, {\n    key: \"depositLUSDInStabilityPool\",\n    value: function () {\n      var _depositLUSDInStabilityPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(amount, frontendTag, overrides) {\n        var _a, _EthersLiquityConnect17, stabilityPool, depositLUSD;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _EthersLiquityConnect17 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect17.stabilityPool;\n                depositLUSD = lib_base_1.Decimal.from(amount);\n                _context17.t0 = this;\n                _context17.t1 = {\n                  depositLUSD: depositLUSD\n                };\n                _context17.next = 6;\n                return stabilityPool.estimateAndPopulate.provideToSP(_objectSpread({}, overrides), addGasForLQTYIssuance, depositLUSD.hex, (_a = frontendTag !== null && frontendTag !== void 0 ? frontendTag : this._readable.connection.frontendTag) !== null && _a !== void 0 ? _a : constants_1.AddressZero);\n\n              case 6:\n                _context17.t2 = _context17.sent;\n                return _context17.abrupt(\"return\", _context17.t0._wrapStabilityDepositTopup.call(_context17.t0, _context17.t1, _context17.t2));\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function depositLUSDInStabilityPool(_x20, _x21, _x22) {\n        return _depositLUSDInStabilityPool.apply(this, arguments);\n      }\n\n      return depositLUSDInStabilityPool;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLUSDFromStabilityPool} */\n\n  }, {\n    key: \"withdrawLUSDFromStabilityPool\",\n    value: function () {\n      var _withdrawLUSDFromStabilityPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(amount, overrides) {\n        var _EthersLiquityConnect18, stabilityPool;\n\n        return _regeneratorRuntime.wrap(function _callee17$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _EthersLiquityConnect18 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect18.stabilityPool;\n                _context18.t0 = this;\n                _context18.next = 4;\n                return stabilityPool.estimateAndPopulate.withdrawFromSP(_objectSpread({}, overrides), addGasForLQTYIssuance, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context18.t1 = _context18.sent;\n                return _context18.abrupt(\"return\", _context18.t0._wrapStabilityDepositWithdrawal.call(_context18.t0, _context18.t1));\n\n              case 6:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function withdrawLUSDFromStabilityPool(_x23, _x24) {\n        return _withdrawLUSDFromStabilityPool.apply(this, arguments);\n      }\n\n      return withdrawLUSDFromStabilityPool;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStabilityPool} */\n\n  }, {\n    key: \"withdrawGainsFromStabilityPool\",\n    value: function () {\n      var _withdrawGainsFromStabilityPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(overrides) {\n        var _EthersLiquityConnect19, stabilityPool;\n\n        return _regeneratorRuntime.wrap(function _callee18$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _EthersLiquityConnect19 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect19.stabilityPool;\n                _context19.t0 = this;\n                _context19.next = 4;\n                return stabilityPool.estimateAndPopulate.withdrawFromSP(_objectSpread({}, overrides), addGasForLQTYIssuance, lib_base_1.Decimal.ZERO.hex);\n\n              case 4:\n                _context19.t1 = _context19.sent;\n                return _context19.abrupt(\"return\", _context19.t0._wrapStabilityPoolGainsWithdrawal.call(_context19.t0, _context19.t1));\n\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function withdrawGainsFromStabilityPool(_x25) {\n        return _withdrawGainsFromStabilityPool.apply(this, arguments);\n      }\n\n      return withdrawGainsFromStabilityPool;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.transferCollateralGainToTrove} */\n\n  }, {\n    key: \"transferCollateralGainToTrove\",\n    value: function () {\n      var _transferCollateralGainToTrove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(overrides) {\n        var _stabilityPool$estima;\n\n        var address, _EthersLiquityConnect20, stabilityPool, _yield$Promise$all3, _yield$Promise$all4, initialTrove, stabilityDeposit, finalTrove;\n\n        return _regeneratorRuntime.wrap(function _callee19$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n                _EthersLiquityConnect20 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect20.stabilityPool;\n                _context20.next = 4;\n                return Promise.all([this._readable.getTrove(address), this._readable.getStabilityDeposit(address)]);\n\n              case 4:\n                _yield$Promise$all3 = _context20.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                initialTrove = _yield$Promise$all4[0];\n                stabilityDeposit = _yield$Promise$all4[1];\n                finalTrove = initialTrove.addCollateral(stabilityDeposit.collateralGain);\n                _context20.t0 = this;\n                _context20.t1 = (_stabilityPool$estima = stabilityPool.estimateAndPopulate).withdrawETHGainToTrove;\n                _context20.t2 = _stabilityPool$estima;\n                _context20.t3 = [_objectSpread({}, overrides), compose(addGasForPotentialListTraversal, addGasForLQTYIssuance)];\n                _context20.t4 = _toConsumableArray;\n                _context20.next = 16;\n                return this._findHints(finalTrove);\n\n              case 16:\n                _context20.t5 = _context20.sent;\n                _context20.t6 = (0, _context20.t4)(_context20.t5);\n                _context20.t7 = _context20.t3.concat.call(_context20.t3, _context20.t6);\n                _context20.next = 21;\n                return _context20.t1.apply.call(_context20.t1, _context20.t2, _context20.t7);\n\n              case 21:\n                _context20.t8 = _context20.sent;\n                return _context20.abrupt(\"return\", _context20.t0._wrapCollateralGainTransfer.call(_context20.t0, _context20.t8));\n\n              case 23:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function transferCollateralGainToTrove(_x26) {\n        return _transferCollateralGainToTrove.apply(this, arguments);\n      }\n\n      return transferCollateralGainToTrove;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLUSD} */\n\n  }, {\n    key: \"sendLUSD\",\n    value: function () {\n      var _sendLUSD = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(toAddress, amount, overrides) {\n        var _EthersLiquityConnect21, lusdToken;\n\n        return _regeneratorRuntime.wrap(function _callee20$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _EthersLiquityConnect21 = EthersLiquityConnection_1._getContracts(this._readable.connection), lusdToken = _EthersLiquityConnect21.lusdToken;\n                _context21.t0 = this;\n                _context21.next = 4;\n                return lusdToken.estimateAndPopulate.transfer(_objectSpread({}, overrides), id, toAddress, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context21.t1 = _context21.sent;\n                return _context21.abrupt(\"return\", _context21.t0._wrapSimpleTransaction.call(_context21.t0, _context21.t1));\n\n              case 6:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function sendLUSD(_x27, _x28, _x29) {\n        return _sendLUSD.apply(this, arguments);\n      }\n\n      return sendLUSD;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLQTY} */\n\n  }, {\n    key: \"sendLQTY\",\n    value: function () {\n      var _sendLQTY = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(toAddress, amount, overrides) {\n        var _EthersLiquityConnect22, lqtyToken;\n\n        return _regeneratorRuntime.wrap(function _callee21$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _EthersLiquityConnect22 = EthersLiquityConnection_1._getContracts(this._readable.connection), lqtyToken = _EthersLiquityConnect22.lqtyToken;\n                _context22.t0 = this;\n                _context22.next = 4;\n                return lqtyToken.estimateAndPopulate.transfer(_objectSpread({}, overrides), id, toAddress, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context22.t1 = _context22.sent;\n                return _context22.abrupt(\"return\", _context22.t0._wrapSimpleTransaction.call(_context22.t0, _context22.t1));\n\n              case 6:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function sendLQTY(_x30, _x31, _x32) {\n        return _sendLQTY.apply(this, arguments);\n      }\n\n      return sendLQTY;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.redeemLUSD} */\n\n  }, {\n    key: \"redeemLUSD\",\n    value: function () {\n      var _redeemLUSD = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(amount, maxRedemptionRate, overrides) {\n        var _this7 = this;\n\n        var _EthersLiquityConnect23, troveManager, attemptedLUSDAmount, _yield$Promise$all5, _yield$Promise$all6, fees, total, _yield$Promise$all6$, truncatedAmount, firstRedemptionHint, partialHints, defaultMaxRedemptionRate, populateRedemption;\n\n        return _regeneratorRuntime.wrap(function _callee23$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _EthersLiquityConnect23 = EthersLiquityConnection_1._getContracts(this._readable.connection), troveManager = _EthersLiquityConnect23.troveManager;\n                attemptedLUSDAmount = lib_base_1.Decimal.from(amount);\n                _context24.next = 4;\n                return Promise.all([this._readable.getFees(), this._readable.getTotal(), this._findRedemptionHints(attemptedLUSDAmount)]);\n\n              case 4:\n                _yield$Promise$all5 = _context24.sent;\n                _yield$Promise$all6 = _slicedToArray(_yield$Promise$all5, 3);\n                fees = _yield$Promise$all6[0];\n                total = _yield$Promise$all6[1];\n                _yield$Promise$all6$ = _toArray(_yield$Promise$all6[2]);\n                truncatedAmount = _yield$Promise$all6$[0];\n                firstRedemptionHint = _yield$Promise$all6$[1];\n                partialHints = _yield$Promise$all6$.slice(2);\n\n                if (!truncatedAmount.isZero) {\n                  _context24.next = 14;\n                  break;\n                }\n\n                throw new Error(\"redeemLUSD: amount too low to redeem (try at least \".concat(lib_base_1.LUSD_MINIMUM_NET_DEBT, \")\"));\n\n              case 14:\n                defaultMaxRedemptionRate = function defaultMaxRedemptionRate(amount) {\n                  return lib_base_1.Decimal.min(fees.redemptionRate(amount.div(total.debt)).add(defaultRedemptionRateSlippageTolerance), lib_base_1.Decimal.ONE);\n                };\n\n                populateRedemption = /*#__PURE__*/function () {\n                  var _ref28 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(attemptedLUSDAmount, maxRedemptionRate) {\n                    var _troveManager$estimat;\n\n                    var truncatedAmount,\n                        partialHints,\n                        maxRedemptionRateOrDefault,\n                        _args23 = arguments;\n                    return _regeneratorRuntime.wrap(function _callee22$(_context23) {\n                      while (1) {\n                        switch (_context23.prev = _context23.next) {\n                          case 0:\n                            truncatedAmount = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : attemptedLUSDAmount;\n                            partialHints = _args23.length > 3 && _args23[3] !== undefined ? _args23[3] : [constants_1.AddressZero, constants_1.AddressZero, 0];\n                            maxRedemptionRateOrDefault = maxRedemptionRate !== undefined ? lib_base_1.Decimal.from(maxRedemptionRate) : defaultMaxRedemptionRate(truncatedAmount);\n                            _context23.t0 = PopulatedEthersRedemption;\n                            _context23.next = 6;\n                            return (_troveManager$estimat = troveManager.estimateAndPopulate).redeemCollateral.apply(_troveManager$estimat, [_objectSpread({}, overrides), addGasForPotentialLastFeeOperationTimeUpdate, truncatedAmount.hex, firstRedemptionHint].concat(_toConsumableArray(partialHints), [exports._redeemMaxIterations, maxRedemptionRateOrDefault.hex]));\n\n                          case 6:\n                            _context23.t1 = _context23.sent;\n                            _context23.t2 = _this7._readable.connection;\n                            _context23.t3 = attemptedLUSDAmount;\n                            _context23.t4 = truncatedAmount;\n                            _context23.t5 = truncatedAmount.lt(attemptedLUSDAmount) ? function (newMaxRedemptionRate) {\n                              return populateRedemption(truncatedAmount.add(lib_base_1.LUSD_MINIMUM_NET_DEBT), newMaxRedemptionRate !== null && newMaxRedemptionRate !== void 0 ? newMaxRedemptionRate : maxRedemptionRate);\n                            } : undefined;\n                            return _context23.abrupt(\"return\", new _context23.t0(_context23.t1, _context23.t2, _context23.t3, _context23.t4, _context23.t5));\n\n                          case 12:\n                          case \"end\":\n                            return _context23.stop();\n                        }\n                      }\n                    }, _callee22);\n                  }));\n\n                  return function populateRedemption(_x36, _x37) {\n                    return _ref28.apply(this, arguments);\n                  };\n                }();\n\n                return _context24.abrupt(\"return\", populateRedemption(attemptedLUSDAmount, maxRedemptionRate, truncatedAmount, partialHints));\n\n              case 17:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function redeemLUSD(_x33, _x34, _x35) {\n        return _redeemLUSD.apply(this, arguments);\n      }\n\n      return redeemLUSD;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeLQTY} */\n\n  }, {\n    key: \"stakeLQTY\",\n    value: function () {\n      var _stakeLQTY = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(amount, overrides) {\n        var _EthersLiquityConnect24, lqtyStaking;\n\n        return _regeneratorRuntime.wrap(function _callee24$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _EthersLiquityConnect24 = EthersLiquityConnection_1._getContracts(this._readable.connection), lqtyStaking = _EthersLiquityConnect24.lqtyStaking;\n                _context25.t0 = this;\n                _context25.next = 4;\n                return lqtyStaking.estimateAndPopulate.stake(_objectSpread({}, overrides), id, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context25.t1 = _context25.sent;\n                return _context25.abrupt(\"return\", _context25.t0._wrapSimpleTransaction.call(_context25.t0, _context25.t1));\n\n              case 6:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function stakeLQTY(_x38, _x39) {\n        return _stakeLQTY.apply(this, arguments);\n      }\n\n      return stakeLQTY;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeLQTY} */\n\n  }, {\n    key: \"unstakeLQTY\",\n    value: function () {\n      var _unstakeLQTY = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(amount, overrides) {\n        var _EthersLiquityConnect25, lqtyStaking;\n\n        return _regeneratorRuntime.wrap(function _callee25$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _EthersLiquityConnect25 = EthersLiquityConnection_1._getContracts(this._readable.connection), lqtyStaking = _EthersLiquityConnect25.lqtyStaking;\n                _context26.t0 = this;\n                _context26.next = 4;\n                return lqtyStaking.estimateAndPopulate.unstake(_objectSpread({}, overrides), id, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context26.t1 = _context26.sent;\n                return _context26.abrupt(\"return\", _context26.t0._wrapSimpleTransaction.call(_context26.t0, _context26.t1));\n\n              case 6:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function unstakeLQTY(_x40, _x41) {\n        return _unstakeLQTY.apply(this, arguments);\n      }\n\n      return unstakeLQTY;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStaking} */\n\n  }, {\n    key: \"withdrawGainsFromStaking\",\n    value: function withdrawGainsFromStaking(overrides) {\n      return this.unstakeLQTY(lib_base_1.Decimal.ZERO, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.registerFrontend} */\n\n  }, {\n    key: \"registerFrontend\",\n    value: function () {\n      var _registerFrontend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(kickbackRate, overrides) {\n        var _EthersLiquityConnect26, stabilityPool;\n\n        return _regeneratorRuntime.wrap(function _callee26$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                _EthersLiquityConnect26 = EthersLiquityConnection_1._getContracts(this._readable.connection), stabilityPool = _EthersLiquityConnect26.stabilityPool;\n                _context27.t0 = this;\n                _context27.next = 4;\n                return stabilityPool.estimateAndPopulate.registerFrontEnd(_objectSpread({}, overrides), id, lib_base_1.Decimal.from(kickbackRate).hex);\n\n              case 4:\n                _context27.t1 = _context27.sent;\n                return _context27.abrupt(\"return\", _context27.t0._wrapSimpleTransaction.call(_context27.t0, _context27.t1));\n\n              case 6:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function registerFrontend(_x42, _x43) {\n        return _registerFrontend.apply(this, arguments);\n      }\n\n      return registerFrontend;\n    }()\n    /** @internal */\n\n  }, {\n    key: \"_mintUniToken\",\n    value: function () {\n      var _mintUniToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(amount, address, overrides) {\n        var _EthersLiquityConnect27, uniToken;\n\n        return _regeneratorRuntime.wrap(function _callee27$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n                _EthersLiquityConnect27 = EthersLiquityConnection_1._getContracts(this._readable.connection), uniToken = _EthersLiquityConnect27.uniToken;\n\n                if (contracts_1._uniTokenIsMock(uniToken)) {\n                  _context28.next = 4;\n                  break;\n                }\n\n                throw new Error(\"_mintUniToken() unavailable on this deployment of Liquity\");\n\n              case 4:\n                _context28.t0 = this;\n                _context28.next = 7;\n                return uniToken.estimateAndPopulate.mint(_objectSpread({}, overrides), id, address, lib_base_1.Decimal.from(amount).hex);\n\n              case 7:\n                _context28.t1 = _context28.sent;\n                return _context28.abrupt(\"return\", _context28.t0._wrapSimpleTransaction.call(_context28.t0, _context28.t1));\n\n              case 9:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function _mintUniToken(_x44, _x45, _x46) {\n        return _mintUniToken2.apply(this, arguments);\n      }\n\n      return _mintUniToken;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.approveUniTokens} */\n\n  }, {\n    key: \"approveUniTokens\",\n    value: function () {\n      var _approveUniTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(allowance, overrides) {\n        var _EthersLiquityConnect28, uniToken, unipool;\n\n        return _regeneratorRuntime.wrap(function _callee28$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _EthersLiquityConnect28 = EthersLiquityConnection_1._getContracts(this._readable.connection), uniToken = _EthersLiquityConnect28.uniToken, unipool = _EthersLiquityConnect28.unipool;\n                _context29.t0 = this;\n                _context29.next = 4;\n                return uniToken.estimateAndPopulate.approve(_objectSpread({}, overrides), id, unipool.address, lib_base_1.Decimal.from(allowance !== null && allowance !== void 0 ? allowance : lib_base_1.Decimal.INFINITY).hex);\n\n              case 4:\n                _context29.t1 = _context29.sent;\n                return _context29.abrupt(\"return\", _context29.t0._wrapSimpleTransaction.call(_context29.t0, _context29.t1));\n\n              case 6:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function approveUniTokens(_x47, _x48) {\n        return _approveUniTokens.apply(this, arguments);\n      }\n\n      return approveUniTokens;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeUniTokens} */\n\n  }, {\n    key: \"stakeUniTokens\",\n    value: function () {\n      var _stakeUniTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(amount, overrides) {\n        var _EthersLiquityConnect29, unipool;\n\n        return _regeneratorRuntime.wrap(function _callee29$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                _EthersLiquityConnect29 = EthersLiquityConnection_1._getContracts(this._readable.connection), unipool = _EthersLiquityConnect29.unipool;\n                _context30.t0 = this;\n                _context30.next = 4;\n                return unipool.estimateAndPopulate.stake(_objectSpread({}, overrides), addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context30.t1 = _context30.sent;\n                return _context30.abrupt(\"return\", _context30.t0._wrapSimpleTransaction.call(_context30.t0, _context30.t1));\n\n              case 6:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee29, this);\n      }));\n\n      function stakeUniTokens(_x49, _x50) {\n        return _stakeUniTokens.apply(this, arguments);\n      }\n\n      return stakeUniTokens;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeUniTokens} */\n\n  }, {\n    key: \"unstakeUniTokens\",\n    value: function () {\n      var _unstakeUniTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee30(amount, overrides) {\n        var _EthersLiquityConnect30, unipool;\n\n        return _regeneratorRuntime.wrap(function _callee30$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                _EthersLiquityConnect30 = EthersLiquityConnection_1._getContracts(this._readable.connection), unipool = _EthersLiquityConnect30.unipool;\n                _context31.t0 = this;\n                _context31.next = 4;\n                return unipool.estimateAndPopulate.withdraw(_objectSpread({}, overrides), addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex);\n\n              case 4:\n                _context31.t1 = _context31.sent;\n                return _context31.abrupt(\"return\", _context31.t0._wrapSimpleTransaction.call(_context31.t0, _context31.t1));\n\n              case 6:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee30, this);\n      }));\n\n      function unstakeUniTokens(_x51, _x52) {\n        return _unstakeUniTokens.apply(this, arguments);\n      }\n\n      return unstakeUniTokens;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLQTYRewardFromLiquidityMining} */\n\n  }, {\n    key: \"withdrawLQTYRewardFromLiquidityMining\",\n    value: function () {\n      var _withdrawLQTYRewardFromLiquidityMining = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee31(overrides) {\n        var _EthersLiquityConnect31, unipool;\n\n        return _regeneratorRuntime.wrap(function _callee31$(_context32) {\n          while (1) {\n            switch (_context32.prev = _context32.next) {\n              case 0:\n                _EthersLiquityConnect31 = EthersLiquityConnection_1._getContracts(this._readable.connection), unipool = _EthersLiquityConnect31.unipool;\n                _context32.t0 = this;\n                _context32.next = 4;\n                return unipool.estimateAndPopulate.claimReward(_objectSpread({}, overrides), addGasForUnipoolRewardUpdate);\n\n              case 4:\n                _context32.t1 = _context32.sent;\n                return _context32.abrupt(\"return\", _context32.t0._wrapSimpleTransaction.call(_context32.t0, _context32.t1));\n\n              case 6:\n              case \"end\":\n                return _context32.stop();\n            }\n          }\n        }, _callee31, this);\n      }));\n\n      function withdrawLQTYRewardFromLiquidityMining(_x53) {\n        return _withdrawLQTYRewardFromLiquidityMining.apply(this, arguments);\n      }\n\n      return withdrawLQTYRewardFromLiquidityMining;\n    }()\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.exitLiquidityMining} */\n\n  }, {\n    key: \"exitLiquidityMining\",\n    value: function () {\n      var _exitLiquidityMining = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee32(overrides) {\n        var _EthersLiquityConnect32, unipool;\n\n        return _regeneratorRuntime.wrap(function _callee32$(_context33) {\n          while (1) {\n            switch (_context33.prev = _context33.next) {\n              case 0:\n                _EthersLiquityConnect32 = EthersLiquityConnection_1._getContracts(this._readable.connection), unipool = _EthersLiquityConnect32.unipool;\n                _context33.t0 = this;\n                _context33.next = 4;\n                return unipool.estimateAndPopulate.withdrawAndClaim(_objectSpread({}, overrides), addGasForUnipoolRewardUpdate);\n\n              case 4:\n                _context33.t1 = _context33.sent;\n                return _context33.abrupt(\"return\", _context33.t0._wrapSimpleTransaction.call(_context33.t0, _context33.t1));\n\n              case 6:\n              case \"end\":\n                return _context33.stop();\n            }\n          }\n        }, _callee32, this);\n      }));\n\n      function exitLiquidityMining(_x54) {\n        return _exitLiquidityMining.apply(this, arguments);\n      }\n\n      return exitLiquidityMining;\n    }()\n  }]);\n\n  return PopulatableEthersLiquity;\n}();\n\nexports.PopulatableEthersLiquity = PopulatableEthersLiquity;","map":{"version":3,"sources":["../../src/PopulatableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PopulatableEthersLiquity = exports.PopulatedEthersRedemption = exports.PopulatedEthersLiquityTransaction = exports.SentEthersLiquityTransaction = exports._redeemMaxIterations = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst constants_1 = require(\"@ethersproject/constants\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst contracts_1 = require(\"./contracts\");\nconst parseLogs_1 = require(\"./parseLogs\");\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n// With 70 iterations redemption costs about ~10M gas, and each iteration accounts for ~138k more\n/** @internal */\nexports._redeemMaxIterations = 70;\nconst defaultBorrowingRateSlippageTolerance = lib_base_1.Decimal.from(0.005); // 0.5%\nconst defaultRedemptionRateSlippageTolerance = lib_base_1.Decimal.from(0.001); // 0.1%\nconst noDetails = () => undefined;\nconst compose = (f, g) => (_) => f(g(_));\nconst id = (t) => t;\n// Takes ~6-7K to update lastFeeOperationTime. Let's be on the safe side.\nconst addGasForPotentialLastFeeOperationTimeUpdate = (gas) => gas.add(10000);\n// First traversal in ascending direction takes ~50K, then ~13.5K per extra step.\n// 80K should be enough for 3 steps, plus some extra to be safe.\nconst addGasForPotentialListTraversal = (gas) => gas.add(80000);\nconst addGasForLQTYIssuance = (gas) => gas.add(50000);\nconst addGasForUnipoolRewardUpdate = (gas) => gas.add(20000);\n// To get the best entropy available, we'd do something like:\n//\n// const bigRandomNumber = () =>\n//   BigNumber.from(\n//     `0x${Array.from(crypto.getRandomValues(new Uint32Array(8)))\n//       .map(u32 => u32.toString(16).padStart(8, \"0\"))\n//       .join(\"\")}`\n//   );\n//\n// However, Window.crypto is browser-specific. Since we only use this for randomly picking Troves\n// during the search for hints, Math.random() will do fine, too.\n//\n// This returns a random integer between 0 and Number.MAX_SAFE_INTEGER\nconst randomInteger = () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n// Maximum number of trials to perform in a single getApproxHint() call. If the number of trials\n// required to get a statistically \"good\" hint is larger than this, the search for the hint will\n// be broken up into multiple getApproxHint() calls.\n//\n// This should be low enough to work with popular public Ethereum providers like Infura without\n// triggering any fair use limits.\nconst maxNumberOfTrialsAtOnce = 2500;\nfunction* generateTrials(totalNumberOfTrials) {\n    assert_1.default(Number.isInteger(totalNumberOfTrials) && totalNumberOfTrials > 0);\n    while (totalNumberOfTrials) {\n        const numberOfTrials = Math.min(totalNumberOfTrials, maxNumberOfTrialsAtOnce);\n        yield numberOfTrials;\n        totalNumberOfTrials -= numberOfTrials;\n    }\n}\n/**\n * A transaction that has already been sent.\n *\n * @remarks\n * Returned by {@link SendableEthersLiquity} functions.\n *\n * @public\n */\nclass SentEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawSentTransaction, connection, parse) {\n        this.rawSentTransaction = rawSentTransaction;\n        this._connection = connection;\n        this._parse = parse;\n    }\n    _receiptFrom(rawReceipt) {\n        return rawReceipt\n            ? rawReceipt.status\n                ? lib_base_1._successfulReceipt(rawReceipt, this._parse(rawReceipt), () => parseLogs_1.logsToString(rawReceipt, EthersLiquityConnection_1._getContracts(this._connection)))\n                : lib_base_1._failedReceipt(rawReceipt)\n            : lib_base_1._pendingReceipt;\n    }\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.getReceipt} */\n    async getReceipt() {\n        return this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).getTransactionReceipt(this.rawSentTransaction.hash));\n    }\n    /** {@inheritDoc @liquity/lib-base#SentLiquityTransaction.waitForReceipt} */\n    async waitForReceipt() {\n        const receipt = this._receiptFrom(await EthersLiquityConnection_1._getProvider(this._connection).waitForTransaction(this.rawSentTransaction.hash));\n        assert_1.default(receipt.status !== \"pending\");\n        return receipt;\n    }\n}\nexports.SentEthersLiquityTransaction = SentEthersLiquityTransaction;\n/**\n * A transaction that has been prepared for sending.\n *\n * @remarks\n * Returned by {@link PopulatableEthersLiquity} functions.\n *\n * @public\n */\nclass PopulatedEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawPopulatedTransaction, connection, parse) {\n        this.rawPopulatedTransaction = rawPopulatedTransaction;\n        this._connection = connection;\n        this._parse = parse;\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatedLiquityTransaction.send} */\n    async send() {\n        return new SentEthersLiquityTransaction(await EthersLiquityConnection_1._requireSigner(this._connection).sendTransaction(this.rawPopulatedTransaction), this._connection, this._parse);\n    }\n}\nexports.PopulatedEthersLiquityTransaction = PopulatedEthersLiquityTransaction;\n/**\n * {@inheritDoc @liquity/lib-base#PopulatedRedemption}\n *\n * @public\n */\nclass PopulatedEthersRedemption extends PopulatedEthersLiquityTransaction {\n    /** @internal */\n    constructor(rawPopulatedTransaction, connection, attemptedLUSDAmount, redeemableLUSDAmount, increaseAmountByMinimumNetDebt) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(connection);\n        super(rawPopulatedTransaction, connection, ({ logs }) => troveManager\n            .extractEvents(logs, \"Redemption\")\n            .map(({ args: { _ETHSent, _ETHFee, _actualLUSDAmount, _attemptedLUSDAmount } }) => ({\n            attemptedLUSDAmount: decimalify(_attemptedLUSDAmount),\n            actualLUSDAmount: decimalify(_actualLUSDAmount),\n            collateralTaken: decimalify(_ETHSent),\n            fee: decimalify(_ETHFee)\n        }))[0]);\n        this.attemptedLUSDAmount = attemptedLUSDAmount;\n        this.redeemableLUSDAmount = redeemableLUSDAmount;\n        this.isTruncated = redeemableLUSDAmount.lt(attemptedLUSDAmount);\n        this._increaseAmountByMinimumNetDebt = increaseAmountByMinimumNetDebt;\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatedRedemption.increaseAmountByMinimumNetDebt} */\n    increaseAmountByMinimumNetDebt(maxRedemptionRate) {\n        if (!this._increaseAmountByMinimumNetDebt) {\n            throw new Error(\"PopulatedEthersRedemption: increaseAmountByMinimumNetDebt() can \" +\n                \"only be called when amount is truncated\");\n        }\n        return this._increaseAmountByMinimumNetDebt(maxRedemptionRate);\n    }\n}\nexports.PopulatedEthersRedemption = PopulatedEthersRedemption;\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#PopulatableLiquity}.\n *\n * @public\n */\nclass PopulatableEthersLiquity {\n    constructor(readable) {\n        this._readable = readable;\n    }\n    _wrapSimpleTransaction(rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, noDetails);\n    }\n    _wrapTroveChangeWithFees(params, rawPopulatedTransaction) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const [newTrove] = borrowerOperations\n                .extractEvents(logs, \"TroveUpdated\")\n                .map(({ args: { _coll, _debt } }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n            const [fee] = borrowerOperations\n                .extractEvents(logs, \"LUSDBorrowingFeePaid\")\n                .map(({ args: { _LUSDFee } }) => decimalify(_LUSDFee));\n            return {\n                params,\n                newTrove,\n                fee\n            };\n        });\n    }\n    async _wrapTroveClosure(rawPopulatedTransaction) {\n        const { activePool, lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs, from: userAddress }) => {\n            const [repayLUSD] = lusdToken\n                .extractEvents(logs, \"Transfer\")\n                .filter(({ args: { from, to } }) => from === userAddress && to === constants_1.AddressZero)\n                .map(({ args: { value } }) => decimalify(value));\n            const [withdrawCollateral] = activePool\n                .extractEvents(logs, \"EtherSent\")\n                .filter(({ args: { _to } }) => _to === userAddress)\n                .map(({ args: { _amount } }) => decimalify(_amount));\n            return {\n                params: repayLUSD.nonZero ? { withdrawCollateral, repayLUSD } : { withdrawCollateral }\n            };\n        });\n    }\n    _wrapLiquidation(rawPopulatedTransaction) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const liquidatedAddresses = troveManager\n                .extractEvents(logs, \"TroveLiquidated\")\n                .map(({ args: { _borrower } }) => _borrower);\n            const [totals] = troveManager\n                .extractEvents(logs, \"Liquidation\")\n                .map(({ args: { _LUSDGasCompensation, _collGasCompensation, _liquidatedColl, _liquidatedDebt } }) => ({\n                collateralGasCompensation: decimalify(_collGasCompensation),\n                lusdGasCompensation: decimalify(_LUSDGasCompensation),\n                totalLiquidated: new lib_base_1.Trove(decimalify(_liquidatedColl), decimalify(_liquidatedDebt))\n            }));\n            return {\n                liquidatedAddresses,\n                ...totals\n            };\n        });\n    }\n    _extractStabilityPoolGainsWithdrawalDetails(logs) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const [newLUSDDeposit] = stabilityPool\n            .extractEvents(logs, \"UserDepositChanged\")\n            .map(({ args: { _newDeposit } }) => decimalify(_newDeposit));\n        const [[collateralGain, lusdLoss]] = stabilityPool\n            .extractEvents(logs, \"ETHGainWithdrawn\")\n            .map(({ args: { _ETH, _LUSDLoss } }) => [decimalify(_ETH), decimalify(_LUSDLoss)]);\n        const [lqtyReward] = stabilityPool\n            .extractEvents(logs, \"LQTYPaidToDepositor\")\n            .map(({ args: { _LQTY } }) => decimalify(_LQTY));\n        return {\n            lusdLoss,\n            newLUSDDeposit,\n            collateralGain,\n            lqtyReward\n        };\n    }\n    _wrapStabilityPoolGainsWithdrawal(rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => this._extractStabilityPoolGainsWithdrawalDetails(logs));\n    }\n    _wrapStabilityDepositTopup(change, rawPopulatedTransaction) {\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => ({\n            ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n            change\n        }));\n    }\n    async _wrapStabilityDepositWithdrawal(rawPopulatedTransaction) {\n        const { stabilityPool, lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs, from: userAddress }) => {\n            const gainsWithdrawalDetails = this._extractStabilityPoolGainsWithdrawalDetails(logs);\n            const [withdrawLUSD] = lusdToken\n                .extractEvents(logs, \"Transfer\")\n                .filter(({ args: { from, to } }) => from === stabilityPool.address && to === userAddress)\n                .map(({ args: { value } }) => decimalify(value));\n            return {\n                ...gainsWithdrawalDetails,\n                change: { withdrawLUSD, withdrawAllLUSD: gainsWithdrawalDetails.newLUSDDeposit.isZero }\n            };\n        });\n    }\n    _wrapCollateralGainTransfer(rawPopulatedTransaction) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return new PopulatedEthersLiquityTransaction(rawPopulatedTransaction, this._readable.connection, ({ logs }) => {\n            const [newTrove] = borrowerOperations\n                .extractEvents(logs, \"TroveUpdated\")\n                .map(({ args: { _coll, _debt } }) => new lib_base_1.Trove(decimalify(_coll), decimalify(_debt)));\n            return {\n                ...this._extractStabilityPoolGainsWithdrawalDetails(logs),\n                newTrove\n            };\n        });\n    }\n    async _findHintsForNominalCollateralRatio(nominalCollateralRatio) {\n        const { sortedTroves, hintHelpers } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const numberOfTroves = await this._readable.getNumberOfTroves();\n        if (!numberOfTroves) {\n            return [constants_1.AddressZero, constants_1.AddressZero];\n        }\n        if (nominalCollateralRatio.infinite) {\n            return [constants_1.AddressZero, await sortedTroves.getFirst()];\n        }\n        const totalNumberOfTrials = Math.ceil(10 * Math.sqrt(numberOfTroves));\n        const [firstTrials, ...restOfTrials] = generateTrials(totalNumberOfTrials);\n        const collectApproxHint = ({ latestRandomSeed, results }, numberOfTrials) => hintHelpers\n            .getApproxHint(nominalCollateralRatio.hex, numberOfTrials, latestRandomSeed)\n            .then(({ latestRandomSeed, ...result }) => ({\n            latestRandomSeed,\n            results: [...results, result]\n        }));\n        const { results } = await restOfTrials.reduce((p, numberOfTrials) => p.then(state => collectApproxHint(state, numberOfTrials)), collectApproxHint({ latestRandomSeed: randomInteger(), results: [] }, firstTrials));\n        const { hintAddress } = results.reduce((a, b) => (a.diff.lt(b.diff) ? a : b));\n        return sortedTroves.findInsertPosition(nominalCollateralRatio.hex, hintAddress, hintAddress);\n    }\n    async _findHints(trove) {\n        if (trove instanceof lib_base_1.TroveWithPendingRedistribution) {\n            throw new Error(\"Rewards must be applied to this Trove\");\n        }\n        return this._findHintsForNominalCollateralRatio(trove._nominalCollateralRatio);\n    }\n    async _findRedemptionHints(amount) {\n        const { hintHelpers } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const price = await this._readable.getPrice();\n        const { firstRedemptionHint, partialRedemptionHintNICR, truncatedLUSDamount } = await hintHelpers.getRedemptionHints(amount.hex, price.hex, exports._redeemMaxIterations);\n        const [partialRedemptionUpperHint, partialRedemptionLowerHint] = partialRedemptionHintNICR.isZero()\n            ? [constants_1.AddressZero, constants_1.AddressZero]\n            : await this._findHintsForNominalCollateralRatio(decimalify(partialRedemptionHintNICR));\n        return [\n            decimalify(truncatedLUSDamount),\n            firstRedemptionHint,\n            partialRedemptionUpperHint,\n            partialRedemptionLowerHint,\n            partialRedemptionHintNICR\n        ];\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.openTrove} */\n    async openTrove(params, maxBorrowingRate, overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const normalized = lib_base_1._normalizeTroveCreation(params);\n        const { depositCollateral, borrowLUSD } = normalized;\n        const fees = await this._readable.getFees();\n        const borrowingRate = fees.borrowingRate();\n        const newTrove = lib_base_1.Trove.create(normalized, borrowingRate);\n        maxBorrowingRate =\n            maxBorrowingRate !== undefined\n                ? lib_base_1.Decimal.from(maxBorrowingRate)\n                : borrowingRate.add(defaultBorrowingRateSlippageTolerance);\n        return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.openTrove({ value: depositCollateral.hex, ...overrides }, compose(addGasForPotentialLastFeeOperationTimeUpdate, addGasForPotentialListTraversal), maxBorrowingRate.hex, borrowLUSD.hex, ...(await this._findHints(newTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.closeTrove} */\n    async closeTrove(overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapTroveClosure(await borrowerOperations.estimateAndPopulate.closeTrove({ ...overrides }, id));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositCollateral} */\n    depositCollateral(amount, overrides) {\n        return this.adjustTrove({ depositCollateral: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawCollateral} */\n    withdrawCollateral(amount, overrides) {\n        return this.adjustTrove({ withdrawCollateral: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.borrowLUSD} */\n    borrowLUSD(amount, maxBorrowingRate, overrides) {\n        return this.adjustTrove({ borrowLUSD: amount }, maxBorrowingRate, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.repayLUSD} */\n    repayLUSD(amount, overrides) {\n        return this.adjustTrove({ repayLUSD: amount }, undefined, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.adjustTrove} */\n    async adjustTrove(params, maxBorrowingRate, overrides) {\n        var _a, _b;\n        const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const normalized = lib_base_1._normalizeTroveAdjustment(params);\n        const { depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD } = normalized;\n        const [trove, fees] = await Promise.all([\n            this._readable.getTrove(address),\n            borrowLUSD && this._readable.getFees()\n        ]);\n        const borrowingRate = fees === null || fees === void 0 ? void 0 : fees.borrowingRate();\n        const finalTrove = trove.adjust(normalized, borrowingRate);\n        maxBorrowingRate =\n            maxBorrowingRate !== undefined\n                ? lib_base_1.Decimal.from(maxBorrowingRate)\n                : (_a = borrowingRate === null || borrowingRate === void 0 ? void 0 : borrowingRate.add(defaultBorrowingRateSlippageTolerance)) !== null && _a !== void 0 ? _a : lib_base_1.Decimal.ZERO;\n        return this._wrapTroveChangeWithFees(normalized, await borrowerOperations.estimateAndPopulate.adjustTrove({ value: depositCollateral === null || depositCollateral === void 0 ? void 0 : depositCollateral.hex, ...overrides }, compose(borrowLUSD ? addGasForPotentialLastFeeOperationTimeUpdate : id, addGasForPotentialListTraversal), maxBorrowingRate.hex, (withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : lib_base_1.Decimal.ZERO).hex, ((_b = borrowLUSD !== null && borrowLUSD !== void 0 ? borrowLUSD : repayLUSD) !== null && _b !== void 0 ? _b : lib_base_1.Decimal.ZERO).hex, !!borrowLUSD, ...(await this._findHints(finalTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.claimCollateralSurplus} */\n    async claimCollateralSurplus(overrides) {\n        const { borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await borrowerOperations.estimateAndPopulate.claimCollateral({ ...overrides }, id));\n    }\n    /** @internal */\n    async setPrice(price, overrides) {\n        const { priceFeed } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (!contracts_1._priceFeedIsTestnet(priceFeed)) {\n            throw new Error(\"setPrice() unavailable on this deployment of Liquity\");\n        }\n        return this._wrapSimpleTransaction(await priceFeed.estimateAndPopulate.setPrice({ ...overrides }, id, lib_base_1.Decimal.from(price).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidate} */\n    async liquidate(address, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (Array.isArray(address)) {\n            return this._wrapLiquidation(await troveManager.estimateAndPopulate.batchLiquidateTroves({ ...overrides }, addGasForLQTYIssuance, address));\n        }\n        else {\n            return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidate({ ...overrides }, addGasForLQTYIssuance, address));\n        }\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.liquidateUpTo} */\n    async liquidateUpTo(maximumNumberOfTrovesToLiquidate, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapLiquidation(await troveManager.estimateAndPopulate.liquidateTroves({ ...overrides }, addGasForLQTYIssuance, maximumNumberOfTrovesToLiquidate));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.depositLUSDInStabilityPool} */\n    async depositLUSDInStabilityPool(amount, frontendTag, overrides) {\n        var _a;\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const depositLUSD = lib_base_1.Decimal.from(amount);\n        return this._wrapStabilityDepositTopup({ depositLUSD }, await stabilityPool.estimateAndPopulate.provideToSP({ ...overrides }, addGasForLQTYIssuance, depositLUSD.hex, (_a = frontendTag !== null && frontendTag !== void 0 ? frontendTag : this._readable.connection.frontendTag) !== null && _a !== void 0 ? _a : constants_1.AddressZero));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLUSDFromStabilityPool} */\n    async withdrawLUSDFromStabilityPool(amount, overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapStabilityDepositWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides }, addGasForLQTYIssuance, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStabilityPool} */\n    async withdrawGainsFromStabilityPool(overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapStabilityPoolGainsWithdrawal(await stabilityPool.estimateAndPopulate.withdrawFromSP({ ...overrides }, addGasForLQTYIssuance, lib_base_1.Decimal.ZERO.hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.transferCollateralGainToTrove} */\n    async transferCollateralGainToTrove(overrides) {\n        const address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides);\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const [initialTrove, stabilityDeposit] = await Promise.all([\n            this._readable.getTrove(address),\n            this._readable.getStabilityDeposit(address)\n        ]);\n        const finalTrove = initialTrove.addCollateral(stabilityDeposit.collateralGain);\n        return this._wrapCollateralGainTransfer(await stabilityPool.estimateAndPopulate.withdrawETHGainToTrove({ ...overrides }, compose(addGasForPotentialListTraversal, addGasForLQTYIssuance), ...(await this._findHints(finalTrove))));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLUSD} */\n    async sendLUSD(toAddress, amount, overrides) {\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lusdToken.estimateAndPopulate.transfer({ ...overrides }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.sendLQTY} */\n    async sendLQTY(toAddress, amount, overrides) {\n        const { lqtyToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyToken.estimateAndPopulate.transfer({ ...overrides }, id, toAddress, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.redeemLUSD} */\n    async redeemLUSD(amount, maxRedemptionRate, overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const attemptedLUSDAmount = lib_base_1.Decimal.from(amount);\n        const [fees, total, [truncatedAmount, firstRedemptionHint, ...partialHints]] = await Promise.all([\n            this._readable.getFees(),\n            this._readable.getTotal(),\n            this._findRedemptionHints(attemptedLUSDAmount)\n        ]);\n        if (truncatedAmount.isZero) {\n            throw new Error(`redeemLUSD: amount too low to redeem (try at least ${lib_base_1.LUSD_MINIMUM_NET_DEBT})`);\n        }\n        const defaultMaxRedemptionRate = (amount) => lib_base_1.Decimal.min(fees.redemptionRate(amount.div(total.debt)).add(defaultRedemptionRateSlippageTolerance), lib_base_1.Decimal.ONE);\n        const populateRedemption = async (attemptedLUSDAmount, maxRedemptionRate, truncatedAmount = attemptedLUSDAmount, partialHints = [constants_1.AddressZero, constants_1.AddressZero, 0]) => {\n            const maxRedemptionRateOrDefault = maxRedemptionRate !== undefined\n                ? lib_base_1.Decimal.from(maxRedemptionRate)\n                : defaultMaxRedemptionRate(truncatedAmount);\n            return new PopulatedEthersRedemption(await troveManager.estimateAndPopulate.redeemCollateral({ ...overrides }, addGasForPotentialLastFeeOperationTimeUpdate, truncatedAmount.hex, firstRedemptionHint, ...partialHints, exports._redeemMaxIterations, maxRedemptionRateOrDefault.hex), this._readable.connection, attemptedLUSDAmount, truncatedAmount, truncatedAmount.lt(attemptedLUSDAmount)\n                ? newMaxRedemptionRate => populateRedemption(truncatedAmount.add(lib_base_1.LUSD_MINIMUM_NET_DEBT), newMaxRedemptionRate !== null && newMaxRedemptionRate !== void 0 ? newMaxRedemptionRate : maxRedemptionRate)\n                : undefined);\n        };\n        return populateRedemption(attemptedLUSDAmount, maxRedemptionRate, truncatedAmount, partialHints);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeLQTY} */\n    async stakeLQTY(amount, overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.stake({ ...overrides }, id, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeLQTY} */\n    async unstakeLQTY(amount, overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await lqtyStaking.estimateAndPopulate.unstake({ ...overrides }, id, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawGainsFromStaking} */\n    withdrawGainsFromStaking(overrides) {\n        return this.unstakeLQTY(lib_base_1.Decimal.ZERO, overrides);\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.registerFrontend} */\n    async registerFrontend(kickbackRate, overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await stabilityPool.estimateAndPopulate.registerFrontEnd({ ...overrides }, id, lib_base_1.Decimal.from(kickbackRate).hex));\n    }\n    /** @internal */\n    async _mintUniToken(amount, address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection, overrides));\n        const { uniToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        if (!contracts_1._uniTokenIsMock(uniToken)) {\n            throw new Error(\"_mintUniToken() unavailable on this deployment of Liquity\");\n        }\n        return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.mint({ ...overrides }, id, address, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.approveUniTokens} */\n    async approveUniTokens(allowance, overrides) {\n        const { uniToken, unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await uniToken.estimateAndPopulate.approve({ ...overrides }, id, unipool.address, lib_base_1.Decimal.from(allowance !== null && allowance !== void 0 ? allowance : lib_base_1.Decimal.INFINITY).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.stakeUniTokens} */\n    async stakeUniTokens(amount, overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.stake({ ...overrides }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.unstakeUniTokens} */\n    async unstakeUniTokens(amount, overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdraw({ ...overrides }, addGasForUnipoolRewardUpdate, lib_base_1.Decimal.from(amount).hex));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.withdrawLQTYRewardFromLiquidityMining} */\n    async withdrawLQTYRewardFromLiquidityMining(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.claimReward({ ...overrides }, addGasForUnipoolRewardUpdate));\n    }\n    /** {@inheritDoc @liquity/lib-base#PopulatableLiquity.exitLiquidityMining} */\n    async exitLiquidityMining(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        return this._wrapSimpleTransaction(await unipool.estimateAndPopulate.withdrawAndClaim({ ...overrides }, addGasForUnipoolRewardUpdate));\n    }\n}\nexports.PopulatableEthersLiquity = PopulatableEthersLiquity;\n//# sourceMappingURL=PopulatableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}