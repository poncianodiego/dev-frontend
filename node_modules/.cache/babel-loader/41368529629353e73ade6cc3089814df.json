{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadableEthersLiquity = void 0;\n\nconst lib_base_1 = require(\"@liquity/lib-base\");\n\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nconst BlockPolledLiquityStore_1 = require(\"./BlockPolledLiquityStore\"); // TODO: these are constant in the contracts, so it doesn't make sense to make a call for them,\n// but to avoid having to update them here when we change them in the contracts, we could read\n// them once after deployment and save them to LiquityDeployment.\n\n\nconst MINUTE_DECAY_FACTOR = lib_base_1.Decimal.from(\"0.999037758833783000\");\nconst BETA = lib_base_1.Decimal.from(2);\nvar BackendTroveStatus;\n\n(function (BackendTroveStatus) {\n  BackendTroveStatus[BackendTroveStatus[\"nonExistent\"] = 0] = \"nonExistent\";\n  BackendTroveStatus[BackendTroveStatus[\"active\"] = 1] = \"active\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByOwner\"] = 2] = \"closedByOwner\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByLiquidation\"] = 3] = \"closedByLiquidation\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByRedemption\"] = 4] = \"closedByRedemption\";\n})(BackendTroveStatus || (BackendTroveStatus = {}));\n\nconst panic = error => {\n  throw error;\n};\n\nconst userTroveStatusFrom = backendStatus => backendStatus === BackendTroveStatus.nonExistent ? \"nonExistent\" : backendStatus === BackendTroveStatus.active ? \"open\" : backendStatus === BackendTroveStatus.closedByOwner ? \"closedByOwner\" : backendStatus === BackendTroveStatus.closedByLiquidation ? \"closedByLiquidation\" : backendStatus === BackendTroveStatus.closedByRedemption ? \"closedByRedemption\" : panic(new Error(`invalid backendStatus ${backendStatus}`));\n\nconst decimalify = bigNumber => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n\nconst numberify = bigNumber => bigNumber.toNumber();\n\nconst convertToDate = timestamp => new Date(timestamp * 1000);\n\nconst validSortingOptions = [\"ascendingCollateralRatio\", \"descendingCollateralRatio\"];\n\nconst expectPositiveInt = (obj, key) => {\n  if (obj[key] !== undefined) {\n    if (!Number.isInteger(obj[key])) {\n      throw new Error(`${key} must be an integer`);\n    }\n\n    if (obj[key] < 0) {\n      throw new Error(`${key} must not be negative`);\n    }\n  }\n};\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#ReadableLiquity}.\n *\n * @public\n */\n\n\nclass ReadableEthersLiquity {\n  /** @internal */\n  constructor(connection) {\n    this.connection = connection;\n  }\n  /** @internal */\n\n\n  static _from(connection) {\n    const readable = new ReadableEthersLiquity(connection);\n    return connection.useStore === \"blockPolled\" ? new _BlockPolledReadableEthersLiquity(readable) : readable;\n  }\n  /**\n   * Connect to the Liquity protocol and create a `ReadableEthersLiquity` object.\n   *\n   * @param signerOrProvider - Ethers `Signer` or `Provider` to use for connecting to the Ethereum\n   *                           network.\n   * @param optionalParams - Optional parameters that can be used to customize the connection.\n   */\n\n\n  static async connect(signerOrProvider, optionalParams) {\n    return ReadableEthersLiquity._from(await EthersLiquityConnection_1._connect(signerOrProvider, optionalParams));\n  }\n\n  hasStore() {\n    return false;\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalRedistributed} */\n\n\n  async getTotalRedistributed(overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [collateral, debt] = await Promise.all([troveManager.L_ETH({ ...overrides\n    }).then(decimalify), troveManager.L_LUSDDebt({ ...overrides\n    }).then(decimalify)]);\n    return new lib_base_1.Trove(collateral, debt);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTroveBeforeRedistribution} */\n\n\n  async getTroveBeforeRedistribution(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [trove, snapshot] = await Promise.all([troveManager.Troves(address, { ...overrides\n    }), troveManager.rewardSnapshots(address, { ...overrides\n    })]);\n\n    if (trove.status === BackendTroveStatus.active) {\n      return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status), decimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(snapshot.ETH), decimalify(snapshot.LUSDDebt)));\n    } else {\n      return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status));\n    }\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTrove} */\n\n\n  async getTrove(address, overrides) {\n    const [trove, totalRedistributed] = await Promise.all([this.getTroveBeforeRedistribution(address, overrides), this.getTotalRedistributed(overrides)]);\n    return trove.applyRedistribution(totalRedistributed);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getNumberOfTroves} */\n\n\n  async getNumberOfTroves(overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return (await troveManager.getTroveOwnersCount({ ...overrides\n    })).toNumber();\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getPrice} */\n\n\n  getPrice(overrides) {\n    const {\n      priceFeed\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return priceFeed.callStatic.fetchPrice({ ...overrides\n    }).then(decimalify);\n  }\n  /** @internal */\n\n\n  async _getActivePool(overrides) {\n    const {\n      activePool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [activeCollateral, activeDebt] = await Promise.all([activePool.getETH({ ...overrides\n    }), activePool.getLUSDDebt({ ...overrides\n    })].map(getBigNumber => getBigNumber.then(decimalify)));\n    return new lib_base_1.Trove(activeCollateral, activeDebt);\n  }\n  /** @internal */\n\n\n  async _getDefaultPool(overrides) {\n    const {\n      defaultPool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [liquidatedCollateral, closedDebt] = await Promise.all([defaultPool.getETH({ ...overrides\n    }), defaultPool.getLUSDDebt({ ...overrides\n    })].map(getBigNumber => getBigNumber.then(decimalify)));\n    return new lib_base_1.Trove(liquidatedCollateral, closedDebt);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotal} */\n\n\n  async getTotal(overrides) {\n    const [activePool, defaultPool] = await Promise.all([this._getActivePool(overrides), this._getDefaultPool(overrides)]);\n    return activePool.add(defaultPool);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getStabilityDeposit} */\n\n\n  async getStabilityDeposit(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [{\n      frontEndTag,\n      initialValue\n    }, currentLUSD, collateralGain, lqtyReward] = await Promise.all([stabilityPool.deposits(address, { ...overrides\n    }), stabilityPool.getCompoundedLUSDDeposit(address, { ...overrides\n    }), stabilityPool.getDepositorETHGain(address, { ...overrides\n    }), stabilityPool.getDepositorLQTYGain(address, { ...overrides\n    })]);\n    return new lib_base_1.StabilityDeposit(decimalify(initialValue), decimalify(currentLUSD), decimalify(collateralGain), decimalify(lqtyReward), frontEndTag);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingStabilityPoolLQTYReward} */\n\n\n  async getRemainingStabilityPoolLQTYReward(overrides) {\n    const {\n      communityIssuance\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const issuanceCap = this.connection.totalStabilityPoolLQTYReward;\n    const totalLQTYIssued = decimalify(await communityIssuance.totalLQTYIssued({ ...overrides\n    })); // totalLQTYIssued approaches but never reaches issuanceCap\n\n    return issuanceCap.sub(totalLQTYIssued);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDInStabilityPool} */\n\n\n  getLUSDInStabilityPool(overrides) {\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return stabilityPool.getTotalLUSDDeposits({ ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDBalance} */\n\n\n  getLUSDBalance(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      lusdToken\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return lusdToken.balanceOf(address, { ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYBalance} */\n\n\n  getLQTYBalance(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      lqtyToken\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return lqtyToken.balanceOf(address, { ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenBalance} */\n\n\n  getUniTokenBalance(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      uniToken\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return uniToken.balanceOf(address, { ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenAllowance} */\n\n\n  getUniTokenAllowance(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      uniToken,\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return uniToken.allowance(address, unipool.address, { ...overrides\n    }).then(decimalify);\n  }\n  /** @internal */\n\n\n  async _getRemainingLiquidityMiningLQTYRewardCalculator(overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [totalSupply, rewardRate, periodFinish, lastUpdateTime] = await Promise.all([unipool.totalSupply({ ...overrides\n    }), unipool.rewardRate({ ...overrides\n    }).then(decimalify), unipool.periodFinish({ ...overrides\n    }).then(numberify), unipool.lastUpdateTime({ ...overrides\n    }).then(numberify)]);\n    return blockTimestamp => rewardRate.mul(Math.max(0, periodFinish - (totalSupply.isZero() ? lastUpdateTime : blockTimestamp)));\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingLiquidityMiningLQTYReward} */\n\n\n  async getRemainingLiquidityMiningLQTYReward(overrides) {\n    const [calculateRemainingLQTY, blockTimestamp] = await Promise.all([this._getRemainingLiquidityMiningLQTYRewardCalculator(overrides), EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)]);\n    return calculateRemainingLQTY(blockTimestamp);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningStake} */\n\n\n  getLiquidityMiningStake(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return unipool.balanceOf(address, { ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedUniTokens} */\n\n\n  getTotalStakedUniTokens(overrides) {\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return unipool.totalSupply({ ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningLQTYReward} */\n\n\n  getLiquidityMiningLQTYReward(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      unipool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return unipool.earned(address, { ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getCollateralSurplusBalance} */\n\n\n  getCollateralSurplusBalance(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      collSurplusPool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return collSurplusPool.getCollateral(address, { ...overrides\n    }).then(decimalify);\n  }\n\n  async getTroves(params, overrides) {\n    var _a, _b;\n\n    const {\n      multiTroveGetter\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    expectPositiveInt(params, \"first\");\n    expectPositiveInt(params, \"startingAt\");\n\n    if (!validSortingOptions.includes(params.sortedBy)) {\n      throw new Error(`sortedBy must be one of: ${validSortingOptions.map(x => `\"${x}\"`).join(\", \")}`);\n    }\n\n    const [totalRedistributed, backendTroves] = await Promise.all([params.beforeRedistribution ? undefined : this.getTotalRedistributed({ ...overrides\n    }), multiTroveGetter.getMultipleSortedTroves(params.sortedBy === \"descendingCollateralRatio\" ? (_a = params.startingAt) !== null && _a !== void 0 ? _a : 0 : -(((_b = params.startingAt) !== null && _b !== void 0 ? _b : 0) + 1), params.first, { ...overrides\n    })]);\n    const troves = mapBackendTroves(backendTroves);\n\n    if (totalRedistributed) {\n      return troves.map(trove => trove.applyRedistribution(totalRedistributed));\n    } else {\n      return troves;\n    }\n  }\n  /** @internal */\n\n\n  async _getFeesFactory(overrides) {\n    const {\n      troveManager\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [lastFeeOperationTime, baseRateWithoutDecay] = await Promise.all([troveManager.lastFeeOperationTime({ ...overrides\n    }), troveManager.baseRate({ ...overrides\n    }).then(decimalify)]);\n    return (blockTimestamp, recoveryMode) => new lib_base_1.Fees(baseRateWithoutDecay, MINUTE_DECAY_FACTOR, BETA, convertToDate(lastFeeOperationTime.toNumber()), convertToDate(blockTimestamp), recoveryMode);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFees} */\n\n\n  async getFees(overrides) {\n    const [createFees, total, price, blockTimestamp] = await Promise.all([this._getFeesFactory(overrides), this.getTotal(overrides), this.getPrice(overrides), EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)]);\n    return createFees(blockTimestamp, total.collateralRatioIsBelowCritical(price));\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYStake} */\n\n\n  async getLQTYStake(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n    const {\n      lqtyStaking\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const [stakedLQTY, collateralGain, lusdGain] = await Promise.all([lqtyStaking.stakes(address, { ...overrides\n    }), lqtyStaking.getPendingETHGain(address, { ...overrides\n    }), lqtyStaking.getPendingLUSDGain(address, { ...overrides\n    })].map(getBigNumber => getBigNumber.then(decimalify)));\n    return new lib_base_1.LQTYStake(stakedLQTY, collateralGain, lusdGain);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedLQTY} */\n\n\n  async getTotalStakedLQTY(overrides) {\n    const {\n      lqtyStaking\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    return lqtyStaking.totalLQTYStaked({ ...overrides\n    }).then(decimalify);\n  }\n  /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFrontendStatus} */\n\n\n  async getFrontendStatus(address, overrides) {\n    address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireFrontendAddress(this.connection);\n\n    const {\n      stabilityPool\n    } = EthersLiquityConnection_1._getContracts(this.connection);\n\n    const {\n      registered,\n      kickbackRate\n    } = await stabilityPool.frontEnds(address, { ...overrides\n    });\n    return registered ? {\n      status: \"registered\",\n      kickbackRate: decimalify(kickbackRate)\n    } : {\n      status: \"unregistered\"\n    };\n  }\n\n}\n\nexports.ReadableEthersLiquity = ReadableEthersLiquity;\n\nconst mapBackendTroves = troves => troves.map(trove => new lib_base_1.TroveWithPendingRedistribution(trove.owner, \"open\", // These Troves are coming from the SortedTroves list, so they must be open\ndecimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(trove.snapshotETH), decimalify(trove.snapshotLUSDDebt))));\n\nclass BlockPolledLiquityStoreBasedCache {\n  constructor(store) {\n    this._store = store;\n  }\n\n  _blockHit(overrides) {\n    return !overrides || overrides.blockTag === undefined || overrides.blockTag === this._store.state.blockTag;\n  }\n\n  _userHit(address, overrides) {\n    return this._blockHit(overrides) && (address === undefined || address === this._store.connection.userAddress);\n  }\n\n  _frontendHit(address, overrides) {\n    return this._blockHit(overrides) && (address === undefined || address === this._store.connection.frontendTag);\n  }\n\n  getTotalRedistributed(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.totalRedistributed;\n    }\n  }\n\n  getTroveBeforeRedistribution(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.troveBeforeRedistribution;\n    }\n  }\n\n  getTrove(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.trove;\n    }\n  }\n\n  getNumberOfTroves(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.numberOfTroves;\n    }\n  }\n\n  getPrice(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.price;\n    }\n  }\n\n  getTotal(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.total;\n    }\n  }\n\n  getStabilityDeposit(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.stabilityDeposit;\n    }\n  }\n\n  getRemainingStabilityPoolLQTYReward(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.remainingStabilityPoolLQTYReward;\n    }\n  }\n\n  getLUSDInStabilityPool(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.lusdInStabilityPool;\n    }\n  }\n\n  getLUSDBalance(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.lusdBalance;\n    }\n  }\n\n  getLQTYBalance(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.lqtyBalance;\n    }\n  }\n\n  getUniTokenBalance(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.uniTokenBalance;\n    }\n  }\n\n  getUniTokenAllowance(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.uniTokenAllowance;\n    }\n  }\n\n  getRemainingLiquidityMiningLQTYReward(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.remainingLiquidityMiningLQTYReward;\n    }\n  }\n\n  getLiquidityMiningStake(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.liquidityMiningStake;\n    }\n  }\n\n  getTotalStakedUniTokens(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.totalStakedUniTokens;\n    }\n  }\n\n  getLiquidityMiningLQTYReward(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.liquidityMiningLQTYReward;\n    }\n  }\n\n  getCollateralSurplusBalance(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.collateralSurplusBalance;\n    }\n  }\n\n  getFees(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.fees;\n    }\n  }\n\n  getLQTYStake(address, overrides) {\n    if (this._userHit(address, overrides)) {\n      return this._store.state.lqtyStake;\n    }\n  }\n\n  getTotalStakedLQTY(overrides) {\n    if (this._blockHit(overrides)) {\n      return this._store.state.totalStakedLQTY;\n    }\n  }\n\n  getFrontendStatus(address, overrides) {\n    if (this._frontendHit(address, overrides)) {\n      return this._store.state.frontend;\n    }\n  }\n\n  getTroves() {\n    return undefined;\n  }\n\n}\n\nclass _BlockPolledReadableEthersLiquity extends lib_base_1._CachedReadableLiquity {\n  constructor(readable) {\n    const store = new BlockPolledLiquityStore_1.BlockPolledLiquityStore(readable);\n    super(readable, new BlockPolledLiquityStoreBasedCache(store));\n    this.store = store;\n    this.connection = readable.connection;\n  }\n\n  hasStore(store) {\n    return store === undefined || store === \"blockPolled\";\n  }\n\n  _getActivePool() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  _getDefaultPool() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  _getFeesFactory() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  _getRemainingLiquidityMiningLQTYRewardCalculator() {\n    throw new Error(\"Method not implemented.\");\n  }\n\n}","map":{"version":3,"sources":["../../src/ReadableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableEthersLiquity = void 0;\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst BlockPolledLiquityStore_1 = require(\"./BlockPolledLiquityStore\");\n// TODO: these are constant in the contracts, so it doesn't make sense to make a call for them,\n// but to avoid having to update them here when we change them in the contracts, we could read\n// them once after deployment and save them to LiquityDeployment.\nconst MINUTE_DECAY_FACTOR = lib_base_1.Decimal.from(\"0.999037758833783000\");\nconst BETA = lib_base_1.Decimal.from(2);\nvar BackendTroveStatus;\n(function (BackendTroveStatus) {\n    BackendTroveStatus[BackendTroveStatus[\"nonExistent\"] = 0] = \"nonExistent\";\n    BackendTroveStatus[BackendTroveStatus[\"active\"] = 1] = \"active\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByOwner\"] = 2] = \"closedByOwner\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByLiquidation\"] = 3] = \"closedByLiquidation\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByRedemption\"] = 4] = \"closedByRedemption\";\n})(BackendTroveStatus || (BackendTroveStatus = {}));\nconst panic = (error) => {\n    throw error;\n};\nconst userTroveStatusFrom = (backendStatus) => backendStatus === BackendTroveStatus.nonExistent\n    ? \"nonExistent\"\n    : backendStatus === BackendTroveStatus.active\n        ? \"open\"\n        : backendStatus === BackendTroveStatus.closedByOwner\n            ? \"closedByOwner\"\n            : backendStatus === BackendTroveStatus.closedByLiquidation\n                ? \"closedByLiquidation\"\n                : backendStatus === BackendTroveStatus.closedByRedemption\n                    ? \"closedByRedemption\"\n                    : panic(new Error(`invalid backendStatus ${backendStatus}`));\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\nconst numberify = (bigNumber) => bigNumber.toNumber();\nconst convertToDate = (timestamp) => new Date(timestamp * 1000);\nconst validSortingOptions = [\"ascendingCollateralRatio\", \"descendingCollateralRatio\"];\nconst expectPositiveInt = (obj, key) => {\n    if (obj[key] !== undefined) {\n        if (!Number.isInteger(obj[key])) {\n            throw new Error(`${key} must be an integer`);\n        }\n        if (obj[key] < 0) {\n            throw new Error(`${key} must not be negative`);\n        }\n    }\n};\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#ReadableLiquity}.\n *\n * @public\n */\nclass ReadableEthersLiquity {\n    /** @internal */\n    constructor(connection) {\n        this.connection = connection;\n    }\n    /** @internal */\n    static _from(connection) {\n        const readable = new ReadableEthersLiquity(connection);\n        return connection.useStore === \"blockPolled\"\n            ? new _BlockPolledReadableEthersLiquity(readable)\n            : readable;\n    }\n    /**\n     * Connect to the Liquity protocol and create a `ReadableEthersLiquity` object.\n     *\n     * @param signerOrProvider - Ethers `Signer` or `Provider` to use for connecting to the Ethereum\n     *                           network.\n     * @param optionalParams - Optional parameters that can be used to customize the connection.\n     */\n    static async connect(signerOrProvider, optionalParams) {\n        return ReadableEthersLiquity._from(await EthersLiquityConnection_1._connect(signerOrProvider, optionalParams));\n    }\n    hasStore() {\n        return false;\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalRedistributed} */\n    async getTotalRedistributed(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [collateral, debt] = await Promise.all([\n            troveManager.L_ETH({ ...overrides }).then(decimalify),\n            troveManager.L_LUSDDebt({ ...overrides }).then(decimalify)\n        ]);\n        return new lib_base_1.Trove(collateral, debt);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTroveBeforeRedistribution} */\n    async getTroveBeforeRedistribution(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [trove, snapshot] = await Promise.all([\n            troveManager.Troves(address, { ...overrides }),\n            troveManager.rewardSnapshots(address, { ...overrides })\n        ]);\n        if (trove.status === BackendTroveStatus.active) {\n            return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status), decimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(snapshot.ETH), decimalify(snapshot.LUSDDebt)));\n        }\n        else {\n            return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status));\n        }\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTrove} */\n    async getTrove(address, overrides) {\n        const [trove, totalRedistributed] = await Promise.all([\n            this.getTroveBeforeRedistribution(address, overrides),\n            this.getTotalRedistributed(overrides)\n        ]);\n        return trove.applyRedistribution(totalRedistributed);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getNumberOfTroves} */\n    async getNumberOfTroves(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        return (await troveManager.getTroveOwnersCount({ ...overrides })).toNumber();\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getPrice} */\n    getPrice(overrides) {\n        const { priceFeed } = EthersLiquityConnection_1._getContracts(this.connection);\n        return priceFeed.callStatic.fetchPrice({ ...overrides }).then(decimalify);\n    }\n    /** @internal */\n    async _getActivePool(overrides) {\n        const { activePool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [activeCollateral, activeDebt] = await Promise.all([\n            activePool.getETH({ ...overrides }),\n            activePool.getLUSDDebt({ ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.Trove(activeCollateral, activeDebt);\n    }\n    /** @internal */\n    async _getDefaultPool(overrides) {\n        const { defaultPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [liquidatedCollateral, closedDebt] = await Promise.all([\n            defaultPool.getETH({ ...overrides }),\n            defaultPool.getLUSDDebt({ ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.Trove(liquidatedCollateral, closedDebt);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotal} */\n    async getTotal(overrides) {\n        const [activePool, defaultPool] = await Promise.all([\n            this._getActivePool(overrides),\n            this._getDefaultPool(overrides)\n        ]);\n        return activePool.add(defaultPool);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getStabilityDeposit} */\n    async getStabilityDeposit(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [{ frontEndTag, initialValue }, currentLUSD, collateralGain, lqtyReward] = await Promise.all([\n            stabilityPool.deposits(address, { ...overrides }),\n            stabilityPool.getCompoundedLUSDDeposit(address, { ...overrides }),\n            stabilityPool.getDepositorETHGain(address, { ...overrides }),\n            stabilityPool.getDepositorLQTYGain(address, { ...overrides })\n        ]);\n        return new lib_base_1.StabilityDeposit(decimalify(initialValue), decimalify(currentLUSD), decimalify(collateralGain), decimalify(lqtyReward), frontEndTag);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingStabilityPoolLQTYReward} */\n    async getRemainingStabilityPoolLQTYReward(overrides) {\n        const { communityIssuance } = EthersLiquityConnection_1._getContracts(this.connection);\n        const issuanceCap = this.connection.totalStabilityPoolLQTYReward;\n        const totalLQTYIssued = decimalify(await communityIssuance.totalLQTYIssued({ ...overrides }));\n        // totalLQTYIssued approaches but never reaches issuanceCap\n        return issuanceCap.sub(totalLQTYIssued);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDInStabilityPool} */\n    getLUSDInStabilityPool(overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return stabilityPool.getTotalLUSDDeposits({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDBalance} */\n    getLUSDBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lusdToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYBalance} */\n    getLQTYBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lqtyToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lqtyToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenBalance} */\n    getUniTokenBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { uniToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return uniToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenAllowance} */\n    getUniTokenAllowance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { uniToken, unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return uniToken.allowance(address, unipool.address, { ...overrides }).then(decimalify);\n    }\n    /** @internal */\n    async _getRemainingLiquidityMiningLQTYRewardCalculator(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [totalSupply, rewardRate, periodFinish, lastUpdateTime] = await Promise.all([\n            unipool.totalSupply({ ...overrides }),\n            unipool.rewardRate({ ...overrides }).then(decimalify),\n            unipool.periodFinish({ ...overrides }).then(numberify),\n            unipool.lastUpdateTime({ ...overrides }).then(numberify)\n        ]);\n        return (blockTimestamp) => rewardRate.mul(Math.max(0, periodFinish - (totalSupply.isZero() ? lastUpdateTime : blockTimestamp)));\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingLiquidityMiningLQTYReward} */\n    async getRemainingLiquidityMiningLQTYReward(overrides) {\n        const [calculateRemainingLQTY, blockTimestamp] = await Promise.all([\n            this._getRemainingLiquidityMiningLQTYRewardCalculator(overrides),\n            EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)\n        ]);\n        return calculateRemainingLQTY(blockTimestamp);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningStake} */\n    getLiquidityMiningStake(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedUniTokens} */\n    getTotalStakedUniTokens(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.totalSupply({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningLQTYReward} */\n    getLiquidityMiningLQTYReward(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.earned(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getCollateralSurplusBalance} */\n    getCollateralSurplusBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { collSurplusPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return collSurplusPool.getCollateral(address, { ...overrides }).then(decimalify);\n    }\n    async getTroves(params, overrides) {\n        var _a, _b;\n        const { multiTroveGetter } = EthersLiquityConnection_1._getContracts(this.connection);\n        expectPositiveInt(params, \"first\");\n        expectPositiveInt(params, \"startingAt\");\n        if (!validSortingOptions.includes(params.sortedBy)) {\n            throw new Error(`sortedBy must be one of: ${validSortingOptions.map(x => `\"${x}\"`).join(\", \")}`);\n        }\n        const [totalRedistributed, backendTroves] = await Promise.all([\n            params.beforeRedistribution ? undefined : this.getTotalRedistributed({ ...overrides }),\n            multiTroveGetter.getMultipleSortedTroves(params.sortedBy === \"descendingCollateralRatio\"\n                ? (_a = params.startingAt) !== null && _a !== void 0 ? _a : 0 : -(((_b = params.startingAt) !== null && _b !== void 0 ? _b : 0) + 1), params.first, { ...overrides })\n        ]);\n        const troves = mapBackendTroves(backendTroves);\n        if (totalRedistributed) {\n            return troves.map(trove => trove.applyRedistribution(totalRedistributed));\n        }\n        else {\n            return troves;\n        }\n    }\n    /** @internal */\n    async _getFeesFactory(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [lastFeeOperationTime, baseRateWithoutDecay] = await Promise.all([\n            troveManager.lastFeeOperationTime({ ...overrides }),\n            troveManager.baseRate({ ...overrides }).then(decimalify)\n        ]);\n        return (blockTimestamp, recoveryMode) => new lib_base_1.Fees(baseRateWithoutDecay, MINUTE_DECAY_FACTOR, BETA, convertToDate(lastFeeOperationTime.toNumber()), convertToDate(blockTimestamp), recoveryMode);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFees} */\n    async getFees(overrides) {\n        const [createFees, total, price, blockTimestamp] = await Promise.all([\n            this._getFeesFactory(overrides),\n            this.getTotal(overrides),\n            this.getPrice(overrides),\n            EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)\n        ]);\n        return createFees(blockTimestamp, total.collateralRatioIsBelowCritical(price));\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYStake} */\n    async getLQTYStake(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [stakedLQTY, collateralGain, lusdGain] = await Promise.all([\n            lqtyStaking.stakes(address, { ...overrides }),\n            lqtyStaking.getPendingETHGain(address, { ...overrides }),\n            lqtyStaking.getPendingLUSDGain(address, { ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.LQTYStake(stakedLQTY, collateralGain, lusdGain);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedLQTY} */\n    async getTotalStakedLQTY(overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lqtyStaking.totalLQTYStaked({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFrontendStatus} */\n    async getFrontendStatus(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireFrontendAddress(this.connection));\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const { registered, kickbackRate } = await stabilityPool.frontEnds(address, { ...overrides });\n        return registered\n            ? { status: \"registered\", kickbackRate: decimalify(kickbackRate) }\n            : { status: \"unregistered\" };\n    }\n}\nexports.ReadableEthersLiquity = ReadableEthersLiquity;\nconst mapBackendTroves = (troves) => troves.map(trove => new lib_base_1.TroveWithPendingRedistribution(trove.owner, \"open\", // These Troves are coming from the SortedTroves list, so they must be open\ndecimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(trove.snapshotETH), decimalify(trove.snapshotLUSDDebt))));\nclass BlockPolledLiquityStoreBasedCache {\n    constructor(store) {\n        this._store = store;\n    }\n    _blockHit(overrides) {\n        return (!overrides ||\n            overrides.blockTag === undefined ||\n            overrides.blockTag === this._store.state.blockTag);\n    }\n    _userHit(address, overrides) {\n        return (this._blockHit(overrides) &&\n            (address === undefined || address === this._store.connection.userAddress));\n    }\n    _frontendHit(address, overrides) {\n        return (this._blockHit(overrides) &&\n            (address === undefined || address === this._store.connection.frontendTag));\n    }\n    getTotalRedistributed(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalRedistributed;\n        }\n    }\n    getTroveBeforeRedistribution(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.troveBeforeRedistribution;\n        }\n    }\n    getTrove(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.trove;\n        }\n    }\n    getNumberOfTroves(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.numberOfTroves;\n        }\n    }\n    getPrice(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.price;\n        }\n    }\n    getTotal(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.total;\n        }\n    }\n    getStabilityDeposit(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.stabilityDeposit;\n        }\n    }\n    getRemainingStabilityPoolLQTYReward(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.remainingStabilityPoolLQTYReward;\n        }\n    }\n    getLUSDInStabilityPool(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.lusdInStabilityPool;\n        }\n    }\n    getLUSDBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lusdBalance;\n        }\n    }\n    getLQTYBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lqtyBalance;\n        }\n    }\n    getUniTokenBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.uniTokenBalance;\n        }\n    }\n    getUniTokenAllowance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.uniTokenAllowance;\n        }\n    }\n    getRemainingLiquidityMiningLQTYReward(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.remainingLiquidityMiningLQTYReward;\n        }\n    }\n    getLiquidityMiningStake(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.liquidityMiningStake;\n        }\n    }\n    getTotalStakedUniTokens(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalStakedUniTokens;\n        }\n    }\n    getLiquidityMiningLQTYReward(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.liquidityMiningLQTYReward;\n        }\n    }\n    getCollateralSurplusBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.collateralSurplusBalance;\n        }\n    }\n    getFees(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.fees;\n        }\n    }\n    getLQTYStake(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lqtyStake;\n        }\n    }\n    getTotalStakedLQTY(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalStakedLQTY;\n        }\n    }\n    getFrontendStatus(address, overrides) {\n        if (this._frontendHit(address, overrides)) {\n            return this._store.state.frontend;\n        }\n    }\n    getTroves() {\n        return undefined;\n    }\n}\nclass _BlockPolledReadableEthersLiquity extends lib_base_1._CachedReadableLiquity {\n    constructor(readable) {\n        const store = new BlockPolledLiquityStore_1.BlockPolledLiquityStore(readable);\n        super(readable, new BlockPolledLiquityStoreBasedCache(store));\n        this.store = store;\n        this.connection = readable.connection;\n    }\n    hasStore(store) {\n        return store === undefined || store === \"blockPolled\";\n    }\n    _getActivePool() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getDefaultPool() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getFeesFactory() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getRemainingLiquidityMiningLQTYRewardCalculator() {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n//# sourceMappingURL=ReadableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}