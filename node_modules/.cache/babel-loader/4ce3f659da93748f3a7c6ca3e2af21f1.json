{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadableEthersLiquity = void 0;\n\nvar lib_base_1 = require(\"@liquity/lib-base\");\n\nvar EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nvar BlockPolledLiquityStore_1 = require(\"./BlockPolledLiquityStore\"); // TODO: these are constant in the contracts, so it doesn't make sense to make a call for them,\n// but to avoid having to update them here when we change them in the contracts, we could read\n// them once after deployment and save them to LiquityDeployment.\n\n\nvar MINUTE_DECAY_FACTOR = lib_base_1.Decimal.from(\"0.999037758833783000\");\nvar BETA = lib_base_1.Decimal.from(2);\nvar BackendTroveStatus;\n\n(function (BackendTroveStatus) {\n  BackendTroveStatus[BackendTroveStatus[\"nonExistent\"] = 0] = \"nonExistent\";\n  BackendTroveStatus[BackendTroveStatus[\"active\"] = 1] = \"active\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByOwner\"] = 2] = \"closedByOwner\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByLiquidation\"] = 3] = \"closedByLiquidation\";\n  BackendTroveStatus[BackendTroveStatus[\"closedByRedemption\"] = 4] = \"closedByRedemption\";\n})(BackendTroveStatus || (BackendTroveStatus = {}));\n\nvar panic = function panic(error) {\n  throw error;\n};\n\nvar userTroveStatusFrom = function userTroveStatusFrom(backendStatus) {\n  return backendStatus === BackendTroveStatus.nonExistent ? \"nonExistent\" : backendStatus === BackendTroveStatus.active ? \"open\" : backendStatus === BackendTroveStatus.closedByOwner ? \"closedByOwner\" : backendStatus === BackendTroveStatus.closedByLiquidation ? \"closedByLiquidation\" : backendStatus === BackendTroveStatus.closedByRedemption ? \"closedByRedemption\" : panic(new Error(\"invalid backendStatus \".concat(backendStatus)));\n};\n\nvar decimalify = function decimalify(bigNumber) {\n  return lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n};\n\nvar numberify = function numberify(bigNumber) {\n  return bigNumber.toNumber();\n};\n\nvar convertToDate = function convertToDate(timestamp) {\n  return new Date(timestamp * 1000);\n};\n\nvar validSortingOptions = [\"ascendingCollateralRatio\", \"descendingCollateralRatio\"];\n\nvar expectPositiveInt = function expectPositiveInt(obj, key) {\n  if (obj[key] !== undefined) {\n    if (!Number.isInteger(obj[key])) {\n      throw new Error(\"\".concat(key, \" must be an integer\"));\n    }\n\n    if (obj[key] < 0) {\n      throw new Error(\"\".concat(key, \" must not be negative\"));\n    }\n  }\n};\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#ReadableLiquity}.\n *\n * @public\n */\n\n\nvar ReadableEthersLiquity = /*#__PURE__*/function () {\n  /** @internal */\n  function ReadableEthersLiquity(connection) {\n    _classCallCheck(this, ReadableEthersLiquity);\n\n    this.connection = connection;\n  }\n  /** @internal */\n\n\n  _createClass(ReadableEthersLiquity, [{\n    key: \"hasStore\",\n    value: function hasStore() {\n      return false;\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalRedistributed} */\n\n  }, {\n    key: \"getTotalRedistributed\",\n    value: function () {\n      var _getTotalRedistributed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(overrides) {\n        var _EthersLiquityConnect, troveManager, _yield$Promise$all, _yield$Promise$all2, collateral, debt;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _EthersLiquityConnect = EthersLiquityConnection_1._getContracts(this.connection), troveManager = _EthersLiquityConnect.troveManager;\n                _context.next = 3;\n                return Promise.all([troveManager.L_ETH(_objectSpread({}, overrides)).then(decimalify), troveManager.L_LUSDDebt(_objectSpread({}, overrides)).then(decimalify)]);\n\n              case 3:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                collateral = _yield$Promise$all2[0];\n                debt = _yield$Promise$all2[1];\n                return _context.abrupt(\"return\", new lib_base_1.Trove(collateral, debt));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getTotalRedistributed(_x) {\n        return _getTotalRedistributed.apply(this, arguments);\n      }\n\n      return getTotalRedistributed;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTroveBeforeRedistribution} */\n\n  }, {\n    key: \"getTroveBeforeRedistribution\",\n    value: function () {\n      var _getTroveBeforeRedistribution = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address, overrides) {\n        var _EthersLiquityConnect2, troveManager, _yield$Promise$all3, _yield$Promise$all4, trove, snapshot;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n                _EthersLiquityConnect2 = EthersLiquityConnection_1._getContracts(this.connection), troveManager = _EthersLiquityConnect2.troveManager;\n                _context2.next = 4;\n                return Promise.all([troveManager.Troves(address, _objectSpread({}, overrides)), troveManager.rewardSnapshots(address, _objectSpread({}, overrides))]);\n\n              case 4:\n                _yield$Promise$all3 = _context2.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                trove = _yield$Promise$all4[0];\n                snapshot = _yield$Promise$all4[1];\n\n                if (!(trove.status === BackendTroveStatus.active)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status), decimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(snapshot.ETH), decimalify(snapshot.LUSDDebt))));\n\n              case 12:\n                return _context2.abrupt(\"return\", new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status)));\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getTroveBeforeRedistribution(_x2, _x3) {\n        return _getTroveBeforeRedistribution.apply(this, arguments);\n      }\n\n      return getTroveBeforeRedistribution;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTrove} */\n\n  }, {\n    key: \"getTrove\",\n    value: function () {\n      var _getTrove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(address, overrides) {\n        var _yield$Promise$all5, _yield$Promise$all6, trove, totalRedistributed;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return Promise.all([this.getTroveBeforeRedistribution(address, overrides), this.getTotalRedistributed(overrides)]);\n\n              case 2:\n                _yield$Promise$all5 = _context3.sent;\n                _yield$Promise$all6 = _slicedToArray(_yield$Promise$all5, 2);\n                trove = _yield$Promise$all6[0];\n                totalRedistributed = _yield$Promise$all6[1];\n                return _context3.abrupt(\"return\", trove.applyRedistribution(totalRedistributed));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getTrove(_x4, _x5) {\n        return _getTrove.apply(this, arguments);\n      }\n\n      return getTrove;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getNumberOfTroves} */\n\n  }, {\n    key: \"getNumberOfTroves\",\n    value: function () {\n      var _getNumberOfTroves = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(overrides) {\n        var _EthersLiquityConnect3, troveManager;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _EthersLiquityConnect3 = EthersLiquityConnection_1._getContracts(this.connection), troveManager = _EthersLiquityConnect3.troveManager;\n                _context4.next = 3;\n                return troveManager.getTroveOwnersCount(_objectSpread({}, overrides));\n\n              case 3:\n                return _context4.abrupt(\"return\", _context4.sent.toNumber());\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getNumberOfTroves(_x6) {\n        return _getNumberOfTroves.apply(this, arguments);\n      }\n\n      return getNumberOfTroves;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getPrice} */\n\n  }, {\n    key: \"getPrice\",\n    value: function getPrice(overrides) {\n      var _EthersLiquityConnect4 = EthersLiquityConnection_1._getContracts(this.connection),\n          priceFeed = _EthersLiquityConnect4.priceFeed;\n\n      return priceFeed.callStatic.fetchPrice(_objectSpread({}, overrides)).then(decimalify);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getActivePool\",\n    value: function () {\n      var _getActivePool2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(overrides) {\n        var _EthersLiquityConnect5, activePool, _yield$Promise$all7, _yield$Promise$all8, activeCollateral, activeDebt;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _EthersLiquityConnect5 = EthersLiquityConnection_1._getContracts(this.connection), activePool = _EthersLiquityConnect5.activePool;\n                _context5.next = 3;\n                return Promise.all([activePool.getETH(_objectSpread({}, overrides)), activePool.getLUSDDebt(_objectSpread({}, overrides))].map(function (getBigNumber) {\n                  return getBigNumber.then(decimalify);\n                }));\n\n              case 3:\n                _yield$Promise$all7 = _context5.sent;\n                _yield$Promise$all8 = _slicedToArray(_yield$Promise$all7, 2);\n                activeCollateral = _yield$Promise$all8[0];\n                activeDebt = _yield$Promise$all8[1];\n                return _context5.abrupt(\"return\", new lib_base_1.Trove(activeCollateral, activeDebt));\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _getActivePool(_x7) {\n        return _getActivePool2.apply(this, arguments);\n      }\n\n      return _getActivePool;\n    }()\n    /** @internal */\n\n  }, {\n    key: \"_getDefaultPool\",\n    value: function () {\n      var _getDefaultPool2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(overrides) {\n        var _EthersLiquityConnect6, defaultPool, _yield$Promise$all9, _yield$Promise$all10, liquidatedCollateral, closedDebt;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _EthersLiquityConnect6 = EthersLiquityConnection_1._getContracts(this.connection), defaultPool = _EthersLiquityConnect6.defaultPool;\n                _context6.next = 3;\n                return Promise.all([defaultPool.getETH(_objectSpread({}, overrides)), defaultPool.getLUSDDebt(_objectSpread({}, overrides))].map(function (getBigNumber) {\n                  return getBigNumber.then(decimalify);\n                }));\n\n              case 3:\n                _yield$Promise$all9 = _context6.sent;\n                _yield$Promise$all10 = _slicedToArray(_yield$Promise$all9, 2);\n                liquidatedCollateral = _yield$Promise$all10[0];\n                closedDebt = _yield$Promise$all10[1];\n                return _context6.abrupt(\"return\", new lib_base_1.Trove(liquidatedCollateral, closedDebt));\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _getDefaultPool(_x8) {\n        return _getDefaultPool2.apply(this, arguments);\n      }\n\n      return _getDefaultPool;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotal} */\n\n  }, {\n    key: \"getTotal\",\n    value: function () {\n      var _getTotal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(overrides) {\n        var _yield$Promise$all11, _yield$Promise$all12, activePool, defaultPool;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return Promise.all([this._getActivePool(overrides), this._getDefaultPool(overrides)]);\n\n              case 2:\n                _yield$Promise$all11 = _context7.sent;\n                _yield$Promise$all12 = _slicedToArray(_yield$Promise$all11, 2);\n                activePool = _yield$Promise$all12[0];\n                defaultPool = _yield$Promise$all12[1];\n                return _context7.abrupt(\"return\", activePool.add(defaultPool));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getTotal(_x9) {\n        return _getTotal.apply(this, arguments);\n      }\n\n      return getTotal;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getStabilityDeposit} */\n\n  }, {\n    key: \"getStabilityDeposit\",\n    value: function () {\n      var _getStabilityDeposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(address, overrides) {\n        var _EthersLiquityConnect7, stabilityPool, _yield$Promise$all13, _yield$Promise$all14, _yield$Promise$all14$, frontEndTag, initialValue, currentLUSD, collateralGain, lqtyReward;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n                _EthersLiquityConnect7 = EthersLiquityConnection_1._getContracts(this.connection), stabilityPool = _EthersLiquityConnect7.stabilityPool;\n                _context8.next = 4;\n                return Promise.all([stabilityPool.deposits(address, _objectSpread({}, overrides)), stabilityPool.getCompoundedLUSDDeposit(address, _objectSpread({}, overrides)), stabilityPool.getDepositorETHGain(address, _objectSpread({}, overrides)), stabilityPool.getDepositorLQTYGain(address, _objectSpread({}, overrides))]);\n\n              case 4:\n                _yield$Promise$all13 = _context8.sent;\n                _yield$Promise$all14 = _slicedToArray(_yield$Promise$all13, 4);\n                _yield$Promise$all14$ = _yield$Promise$all14[0];\n                frontEndTag = _yield$Promise$all14$.frontEndTag;\n                initialValue = _yield$Promise$all14$.initialValue;\n                currentLUSD = _yield$Promise$all14[1];\n                collateralGain = _yield$Promise$all14[2];\n                lqtyReward = _yield$Promise$all14[3];\n                return _context8.abrupt(\"return\", new lib_base_1.StabilityDeposit(decimalify(initialValue), decimalify(currentLUSD), decimalify(collateralGain), decimalify(lqtyReward), frontEndTag));\n\n              case 13:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getStabilityDeposit(_x10, _x11) {\n        return _getStabilityDeposit.apply(this, arguments);\n      }\n\n      return getStabilityDeposit;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingStabilityPoolLQTYReward} */\n\n  }, {\n    key: \"getRemainingStabilityPoolLQTYReward\",\n    value: function () {\n      var _getRemainingStabilityPoolLQTYReward = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(overrides) {\n        var _EthersLiquityConnect8, communityIssuance, issuanceCap, totalLQTYIssued;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _EthersLiquityConnect8 = EthersLiquityConnection_1._getContracts(this.connection), communityIssuance = _EthersLiquityConnect8.communityIssuance;\n                issuanceCap = this.connection.totalStabilityPoolLQTYReward;\n                _context9.t0 = decimalify;\n                _context9.next = 5;\n                return communityIssuance.totalLQTYIssued(_objectSpread({}, overrides));\n\n              case 5:\n                _context9.t1 = _context9.sent;\n                totalLQTYIssued = (0, _context9.t0)(_context9.t1);\n                return _context9.abrupt(\"return\", issuanceCap.sub(totalLQTYIssued));\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getRemainingStabilityPoolLQTYReward(_x12) {\n        return _getRemainingStabilityPoolLQTYReward.apply(this, arguments);\n      }\n\n      return getRemainingStabilityPoolLQTYReward;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDInStabilityPool} */\n\n  }, {\n    key: \"getLUSDInStabilityPool\",\n    value: function getLUSDInStabilityPool(overrides) {\n      var _EthersLiquityConnect9 = EthersLiquityConnection_1._getContracts(this.connection),\n          stabilityPool = _EthersLiquityConnect9.stabilityPool;\n\n      return stabilityPool.getTotalLUSDDeposits(_objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDBalance} */\n\n  }, {\n    key: \"getLUSDBalance\",\n    value: function getLUSDBalance(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect10 = EthersLiquityConnection_1._getContracts(this.connection),\n          lusdToken = _EthersLiquityConnect10.lusdToken;\n\n      return lusdToken.balanceOf(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYBalance} */\n\n  }, {\n    key: \"getLQTYBalance\",\n    value: function getLQTYBalance(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect11 = EthersLiquityConnection_1._getContracts(this.connection),\n          lqtyToken = _EthersLiquityConnect11.lqtyToken;\n\n      return lqtyToken.balanceOf(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenBalance} */\n\n  }, {\n    key: \"getUniTokenBalance\",\n    value: function getUniTokenBalance(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect12 = EthersLiquityConnection_1._getContracts(this.connection),\n          uniToken = _EthersLiquityConnect12.uniToken;\n\n      return uniToken.balanceOf(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenAllowance} */\n\n  }, {\n    key: \"getUniTokenAllowance\",\n    value: function getUniTokenAllowance(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect13 = EthersLiquityConnection_1._getContracts(this.connection),\n          uniToken = _EthersLiquityConnect13.uniToken,\n          unipool = _EthersLiquityConnect13.unipool;\n\n      return uniToken.allowance(address, unipool.address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_getRemainingLiquidityMiningLQTYRewardCalculator\",\n    value: function () {\n      var _getRemainingLiquidityMiningLQTYRewardCalculator2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(overrides) {\n        var _EthersLiquityConnect14, unipool, _yield$Promise$all15, _yield$Promise$all16, totalSupply, rewardRate, periodFinish, lastUpdateTime;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _EthersLiquityConnect14 = EthersLiquityConnection_1._getContracts(this.connection), unipool = _EthersLiquityConnect14.unipool;\n                _context10.next = 3;\n                return Promise.all([unipool.totalSupply(_objectSpread({}, overrides)), unipool.rewardRate(_objectSpread({}, overrides)).then(decimalify), unipool.periodFinish(_objectSpread({}, overrides)).then(numberify), unipool.lastUpdateTime(_objectSpread({}, overrides)).then(numberify)]);\n\n              case 3:\n                _yield$Promise$all15 = _context10.sent;\n                _yield$Promise$all16 = _slicedToArray(_yield$Promise$all15, 4);\n                totalSupply = _yield$Promise$all16[0];\n                rewardRate = _yield$Promise$all16[1];\n                periodFinish = _yield$Promise$all16[2];\n                lastUpdateTime = _yield$Promise$all16[3];\n                return _context10.abrupt(\"return\", function (blockTimestamp) {\n                  return rewardRate.mul(Math.max(0, periodFinish - (totalSupply.isZero() ? lastUpdateTime : blockTimestamp)));\n                });\n\n              case 10:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _getRemainingLiquidityMiningLQTYRewardCalculator(_x13) {\n        return _getRemainingLiquidityMiningLQTYRewardCalculator2.apply(this, arguments);\n      }\n\n      return _getRemainingLiquidityMiningLQTYRewardCalculator;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingLiquidityMiningLQTYReward} */\n\n  }, {\n    key: \"getRemainingLiquidityMiningLQTYReward\",\n    value: function () {\n      var _getRemainingLiquidityMiningLQTYReward = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(overrides) {\n        var _yield$Promise$all17, _yield$Promise$all18, calculateRemainingLQTY, blockTimestamp;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return Promise.all([this._getRemainingLiquidityMiningLQTYRewardCalculator(overrides), EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)]);\n\n              case 2:\n                _yield$Promise$all17 = _context11.sent;\n                _yield$Promise$all18 = _slicedToArray(_yield$Promise$all17, 2);\n                calculateRemainingLQTY = _yield$Promise$all18[0];\n                blockTimestamp = _yield$Promise$all18[1];\n                return _context11.abrupt(\"return\", calculateRemainingLQTY(blockTimestamp));\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getRemainingLiquidityMiningLQTYReward(_x14) {\n        return _getRemainingLiquidityMiningLQTYReward.apply(this, arguments);\n      }\n\n      return getRemainingLiquidityMiningLQTYReward;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningStake} */\n\n  }, {\n    key: \"getLiquidityMiningStake\",\n    value: function getLiquidityMiningStake(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect15 = EthersLiquityConnection_1._getContracts(this.connection),\n          unipool = _EthersLiquityConnect15.unipool;\n\n      return unipool.balanceOf(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedUniTokens} */\n\n  }, {\n    key: \"getTotalStakedUniTokens\",\n    value: function getTotalStakedUniTokens(overrides) {\n      var _EthersLiquityConnect16 = EthersLiquityConnection_1._getContracts(this.connection),\n          unipool = _EthersLiquityConnect16.unipool;\n\n      return unipool.totalSupply(_objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningLQTYReward} */\n\n  }, {\n    key: \"getLiquidityMiningLQTYReward\",\n    value: function getLiquidityMiningLQTYReward(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect17 = EthersLiquityConnection_1._getContracts(this.connection),\n          unipool = _EthersLiquityConnect17.unipool;\n\n      return unipool.earned(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getCollateralSurplusBalance} */\n\n  }, {\n    key: \"getCollateralSurplusBalance\",\n    value: function getCollateralSurplusBalance(address, overrides) {\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n\n      var _EthersLiquityConnect18 = EthersLiquityConnection_1._getContracts(this.connection),\n          collSurplusPool = _EthersLiquityConnect18.collSurplusPool;\n\n      return collSurplusPool.getCollateral(address, _objectSpread({}, overrides)).then(decimalify);\n    }\n  }, {\n    key: \"getTroves\",\n    value: function () {\n      var _getTroves = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(params, overrides) {\n        var _a, _b, _EthersLiquityConnect19, multiTroveGetter, _yield$Promise$all19, _yield$Promise$all20, totalRedistributed, backendTroves, troves;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _EthersLiquityConnect19 = EthersLiquityConnection_1._getContracts(this.connection), multiTroveGetter = _EthersLiquityConnect19.multiTroveGetter;\n                expectPositiveInt(params, \"first\");\n                expectPositiveInt(params, \"startingAt\");\n\n                if (validSortingOptions.includes(params.sortedBy)) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw new Error(\"sortedBy must be one of: \".concat(validSortingOptions.map(function (x) {\n                  return \"\\\"\".concat(x, \"\\\"\");\n                }).join(\", \")));\n\n              case 5:\n                _context12.next = 7;\n                return Promise.all([params.beforeRedistribution ? undefined : this.getTotalRedistributed(_objectSpread({}, overrides)), multiTroveGetter.getMultipleSortedTroves(params.sortedBy === \"descendingCollateralRatio\" ? (_a = params.startingAt) !== null && _a !== void 0 ? _a : 0 : -(((_b = params.startingAt) !== null && _b !== void 0 ? _b : 0) + 1), params.first, _objectSpread({}, overrides))]);\n\n              case 7:\n                _yield$Promise$all19 = _context12.sent;\n                _yield$Promise$all20 = _slicedToArray(_yield$Promise$all19, 2);\n                totalRedistributed = _yield$Promise$all20[0];\n                backendTroves = _yield$Promise$all20[1];\n                troves = mapBackendTroves(backendTroves);\n\n                if (!totalRedistributed) {\n                  _context12.next = 16;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", troves.map(function (trove) {\n                  return trove.applyRedistribution(totalRedistributed);\n                }));\n\n              case 16:\n                return _context12.abrupt(\"return\", troves);\n\n              case 17:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getTroves(_x15, _x16) {\n        return _getTroves.apply(this, arguments);\n      }\n\n      return getTroves;\n    }()\n    /** @internal */\n\n  }, {\n    key: \"_getFeesFactory\",\n    value: function () {\n      var _getFeesFactory2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(overrides) {\n        var _EthersLiquityConnect20, troveManager, _yield$Promise$all21, _yield$Promise$all22, lastFeeOperationTime, baseRateWithoutDecay;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _EthersLiquityConnect20 = EthersLiquityConnection_1._getContracts(this.connection), troveManager = _EthersLiquityConnect20.troveManager;\n                _context13.next = 3;\n                return Promise.all([troveManager.lastFeeOperationTime(_objectSpread({}, overrides)), troveManager.baseRate(_objectSpread({}, overrides)).then(decimalify)]);\n\n              case 3:\n                _yield$Promise$all21 = _context13.sent;\n                _yield$Promise$all22 = _slicedToArray(_yield$Promise$all21, 2);\n                lastFeeOperationTime = _yield$Promise$all22[0];\n                baseRateWithoutDecay = _yield$Promise$all22[1];\n                return _context13.abrupt(\"return\", function (blockTimestamp, recoveryMode) {\n                  return new lib_base_1.Fees(baseRateWithoutDecay, MINUTE_DECAY_FACTOR, BETA, convertToDate(lastFeeOperationTime.toNumber()), convertToDate(blockTimestamp), recoveryMode);\n                });\n\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _getFeesFactory(_x17) {\n        return _getFeesFactory2.apply(this, arguments);\n      }\n\n      return _getFeesFactory;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFees} */\n\n  }, {\n    key: \"getFees\",\n    value: function () {\n      var _getFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(overrides) {\n        var _yield$Promise$all23, _yield$Promise$all24, createFees, total, price, blockTimestamp;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return Promise.all([this._getFeesFactory(overrides), this.getTotal(overrides), this.getPrice(overrides), EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)]);\n\n              case 2:\n                _yield$Promise$all23 = _context14.sent;\n                _yield$Promise$all24 = _slicedToArray(_yield$Promise$all23, 4);\n                createFees = _yield$Promise$all24[0];\n                total = _yield$Promise$all24[1];\n                price = _yield$Promise$all24[2];\n                blockTimestamp = _yield$Promise$all24[3];\n                return _context14.abrupt(\"return\", createFees(blockTimestamp, total.collateralRatioIsBelowCritical(price)));\n\n              case 9:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getFees(_x18) {\n        return _getFees.apply(this, arguments);\n      }\n\n      return getFees;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYStake} */\n\n  }, {\n    key: \"getLQTYStake\",\n    value: function () {\n      var _getLQTYStake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(address, overrides) {\n        var _EthersLiquityConnect21, lqtyStaking, _yield$Promise$all25, _yield$Promise$all26, stakedLQTY, collateralGain, lusdGain;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this.connection);\n                _EthersLiquityConnect21 = EthersLiquityConnection_1._getContracts(this.connection), lqtyStaking = _EthersLiquityConnect21.lqtyStaking;\n                _context15.next = 4;\n                return Promise.all([lqtyStaking.stakes(address, _objectSpread({}, overrides)), lqtyStaking.getPendingETHGain(address, _objectSpread({}, overrides)), lqtyStaking.getPendingLUSDGain(address, _objectSpread({}, overrides))].map(function (getBigNumber) {\n                  return getBigNumber.then(decimalify);\n                }));\n\n              case 4:\n                _yield$Promise$all25 = _context15.sent;\n                _yield$Promise$all26 = _slicedToArray(_yield$Promise$all25, 3);\n                stakedLQTY = _yield$Promise$all26[0];\n                collateralGain = _yield$Promise$all26[1];\n                lusdGain = _yield$Promise$all26[2];\n                return _context15.abrupt(\"return\", new lib_base_1.LQTYStake(stakedLQTY, collateralGain, lusdGain));\n\n              case 10:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getLQTYStake(_x19, _x20) {\n        return _getLQTYStake.apply(this, arguments);\n      }\n\n      return getLQTYStake;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedLQTY} */\n\n  }, {\n    key: \"getTotalStakedLQTY\",\n    value: function () {\n      var _getTotalStakedLQTY = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(overrides) {\n        var _EthersLiquityConnect22, lqtyStaking;\n\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _EthersLiquityConnect22 = EthersLiquityConnection_1._getContracts(this.connection), lqtyStaking = _EthersLiquityConnect22.lqtyStaking;\n                return _context16.abrupt(\"return\", lqtyStaking.totalLQTYStaked(_objectSpread({}, overrides)).then(decimalify));\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function getTotalStakedLQTY(_x21) {\n        return _getTotalStakedLQTY.apply(this, arguments);\n      }\n\n      return getTotalStakedLQTY;\n    }()\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFrontendStatus} */\n\n  }, {\n    key: \"getFrontendStatus\",\n    value: function () {\n      var _getFrontendStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(address, overrides) {\n        var _EthersLiquityConnect23, stabilityPool, _yield$stabilityPool$, registered, kickbackRate;\n\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireFrontendAddress(this.connection);\n                _EthersLiquityConnect23 = EthersLiquityConnection_1._getContracts(this.connection), stabilityPool = _EthersLiquityConnect23.stabilityPool;\n                _context17.next = 4;\n                return stabilityPool.frontEnds(address, _objectSpread({}, overrides));\n\n              case 4:\n                _yield$stabilityPool$ = _context17.sent;\n                registered = _yield$stabilityPool$.registered;\n                kickbackRate = _yield$stabilityPool$.kickbackRate;\n                return _context17.abrupt(\"return\", registered ? {\n                  status: \"registered\",\n                  kickbackRate: decimalify(kickbackRate)\n                } : {\n                  status: \"unregistered\"\n                });\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function getFrontendStatus(_x22, _x23) {\n        return _getFrontendStatus.apply(this, arguments);\n      }\n\n      return getFrontendStatus;\n    }()\n  }], [{\n    key: \"_from\",\n    value: function _from(connection) {\n      var readable = new ReadableEthersLiquity(connection);\n      return connection.useStore === \"blockPolled\" ? new _BlockPolledReadableEthersLiquity(readable) : readable;\n    }\n    /**\n     * Connect to the Liquity protocol and create a `ReadableEthersLiquity` object.\n     *\n     * @param signerOrProvider - Ethers `Signer` or `Provider` to use for connecting to the Ethereum\n     *                           network.\n     * @param optionalParams - Optional parameters that can be used to customize the connection.\n     */\n\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(signerOrProvider, optionalParams) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.t0 = ReadableEthersLiquity;\n                _context18.next = 3;\n                return EthersLiquityConnection_1._connect(signerOrProvider, optionalParams);\n\n              case 3:\n                _context18.t1 = _context18.sent;\n                return _context18.abrupt(\"return\", _context18.t0._from.call(_context18.t0, _context18.t1));\n\n              case 5:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18);\n      }));\n\n      function connect(_x24, _x25) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }]);\n\n  return ReadableEthersLiquity;\n}();\n\nexports.ReadableEthersLiquity = ReadableEthersLiquity;\n\nvar mapBackendTroves = function mapBackendTroves(troves) {\n  return troves.map(function (trove) {\n    return new lib_base_1.TroveWithPendingRedistribution(trove.owner, \"open\", // These Troves are coming from the SortedTroves list, so they must be open\n    decimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(trove.snapshotETH), decimalify(trove.snapshotLUSDDebt)));\n  });\n};\n\nvar BlockPolledLiquityStoreBasedCache = /*#__PURE__*/function () {\n  function BlockPolledLiquityStoreBasedCache(store) {\n    _classCallCheck(this, BlockPolledLiquityStoreBasedCache);\n\n    this._store = store;\n  }\n\n  _createClass(BlockPolledLiquityStoreBasedCache, [{\n    key: \"_blockHit\",\n    value: function _blockHit(overrides) {\n      return !overrides || overrides.blockTag === undefined || overrides.blockTag === this._store.state.blockTag;\n    }\n  }, {\n    key: \"_userHit\",\n    value: function _userHit(address, overrides) {\n      return this._blockHit(overrides) && (address === undefined || address === this._store.connection.userAddress);\n    }\n  }, {\n    key: \"_frontendHit\",\n    value: function _frontendHit(address, overrides) {\n      return this._blockHit(overrides) && (address === undefined || address === this._store.connection.frontendTag);\n    }\n  }, {\n    key: \"getTotalRedistributed\",\n    value: function getTotalRedistributed(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.totalRedistributed;\n      }\n    }\n  }, {\n    key: \"getTroveBeforeRedistribution\",\n    value: function getTroveBeforeRedistribution(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.troveBeforeRedistribution;\n      }\n    }\n  }, {\n    key: \"getTrove\",\n    value: function getTrove(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.trove;\n      }\n    }\n  }, {\n    key: \"getNumberOfTroves\",\n    value: function getNumberOfTroves(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.numberOfTroves;\n      }\n    }\n  }, {\n    key: \"getPrice\",\n    value: function getPrice(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.price;\n      }\n    }\n  }, {\n    key: \"getTotal\",\n    value: function getTotal(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.total;\n      }\n    }\n  }, {\n    key: \"getStabilityDeposit\",\n    value: function getStabilityDeposit(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.stabilityDeposit;\n      }\n    }\n  }, {\n    key: \"getRemainingStabilityPoolLQTYReward\",\n    value: function getRemainingStabilityPoolLQTYReward(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.remainingStabilityPoolLQTYReward;\n      }\n    }\n  }, {\n    key: \"getLUSDInStabilityPool\",\n    value: function getLUSDInStabilityPool(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.lusdInStabilityPool;\n      }\n    }\n  }, {\n    key: \"getLUSDBalance\",\n    value: function getLUSDBalance(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.lusdBalance;\n      }\n    }\n  }, {\n    key: \"getLQTYBalance\",\n    value: function getLQTYBalance(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.lqtyBalance;\n      }\n    }\n  }, {\n    key: \"getUniTokenBalance\",\n    value: function getUniTokenBalance(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.uniTokenBalance;\n      }\n    }\n  }, {\n    key: \"getUniTokenAllowance\",\n    value: function getUniTokenAllowance(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.uniTokenAllowance;\n      }\n    }\n  }, {\n    key: \"getRemainingLiquidityMiningLQTYReward\",\n    value: function getRemainingLiquidityMiningLQTYReward(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.remainingLiquidityMiningLQTYReward;\n      }\n    }\n  }, {\n    key: \"getLiquidityMiningStake\",\n    value: function getLiquidityMiningStake(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.liquidityMiningStake;\n      }\n    }\n  }, {\n    key: \"getTotalStakedUniTokens\",\n    value: function getTotalStakedUniTokens(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.totalStakedUniTokens;\n      }\n    }\n  }, {\n    key: \"getLiquidityMiningLQTYReward\",\n    value: function getLiquidityMiningLQTYReward(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.liquidityMiningLQTYReward;\n      }\n    }\n  }, {\n    key: \"getCollateralSurplusBalance\",\n    value: function getCollateralSurplusBalance(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.collateralSurplusBalance;\n      }\n    }\n  }, {\n    key: \"getFees\",\n    value: function getFees(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.fees;\n      }\n    }\n  }, {\n    key: \"getLQTYStake\",\n    value: function getLQTYStake(address, overrides) {\n      if (this._userHit(address, overrides)) {\n        return this._store.state.lqtyStake;\n      }\n    }\n  }, {\n    key: \"getTotalStakedLQTY\",\n    value: function getTotalStakedLQTY(overrides) {\n      if (this._blockHit(overrides)) {\n        return this._store.state.totalStakedLQTY;\n      }\n    }\n  }, {\n    key: \"getFrontendStatus\",\n    value: function getFrontendStatus(address, overrides) {\n      if (this._frontendHit(address, overrides)) {\n        return this._store.state.frontend;\n      }\n    }\n  }, {\n    key: \"getTroves\",\n    value: function getTroves() {\n      return undefined;\n    }\n  }]);\n\n  return BlockPolledLiquityStoreBasedCache;\n}();\n\nvar _BlockPolledReadableEthersLiquity = /*#__PURE__*/function (_lib_base_1$_CachedRe) {\n  _inherits(_BlockPolledReadableEthersLiquity, _lib_base_1$_CachedRe);\n\n  var _super = _createSuper(_BlockPolledReadableEthersLiquity);\n\n  function _BlockPolledReadableEthersLiquity(readable) {\n    var _this;\n\n    _classCallCheck(this, _BlockPolledReadableEthersLiquity);\n\n    var store = new BlockPolledLiquityStore_1.BlockPolledLiquityStore(readable);\n    _this = _super.call(this, readable, new BlockPolledLiquityStoreBasedCache(store));\n    _this.store = store;\n    _this.connection = readable.connection;\n    return _this;\n  }\n\n  _createClass(_BlockPolledReadableEthersLiquity, [{\n    key: \"hasStore\",\n    value: function hasStore(store) {\n      return store === undefined || store === \"blockPolled\";\n    }\n  }, {\n    key: \"_getActivePool\",\n    value: function _getActivePool() {\n      throw new Error(\"Method not implemented.\");\n    }\n  }, {\n    key: \"_getDefaultPool\",\n    value: function _getDefaultPool() {\n      throw new Error(\"Method not implemented.\");\n    }\n  }, {\n    key: \"_getFeesFactory\",\n    value: function _getFeesFactory() {\n      throw new Error(\"Method not implemented.\");\n    }\n  }, {\n    key: \"_getRemainingLiquidityMiningLQTYRewardCalculator\",\n    value: function _getRemainingLiquidityMiningLQTYRewardCalculator() {\n      throw new Error(\"Method not implemented.\");\n    }\n  }]);\n\n  return _BlockPolledReadableEthersLiquity;\n}(lib_base_1._CachedReadableLiquity);","map":{"version":3,"sources":["../../src/ReadableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableEthersLiquity = void 0;\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst BlockPolledLiquityStore_1 = require(\"./BlockPolledLiquityStore\");\n// TODO: these are constant in the contracts, so it doesn't make sense to make a call for them,\n// but to avoid having to update them here when we change them in the contracts, we could read\n// them once after deployment and save them to LiquityDeployment.\nconst MINUTE_DECAY_FACTOR = lib_base_1.Decimal.from(\"0.999037758833783000\");\nconst BETA = lib_base_1.Decimal.from(2);\nvar BackendTroveStatus;\n(function (BackendTroveStatus) {\n    BackendTroveStatus[BackendTroveStatus[\"nonExistent\"] = 0] = \"nonExistent\";\n    BackendTroveStatus[BackendTroveStatus[\"active\"] = 1] = \"active\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByOwner\"] = 2] = \"closedByOwner\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByLiquidation\"] = 3] = \"closedByLiquidation\";\n    BackendTroveStatus[BackendTroveStatus[\"closedByRedemption\"] = 4] = \"closedByRedemption\";\n})(BackendTroveStatus || (BackendTroveStatus = {}));\nconst panic = (error) => {\n    throw error;\n};\nconst userTroveStatusFrom = (backendStatus) => backendStatus === BackendTroveStatus.nonExistent\n    ? \"nonExistent\"\n    : backendStatus === BackendTroveStatus.active\n        ? \"open\"\n        : backendStatus === BackendTroveStatus.closedByOwner\n            ? \"closedByOwner\"\n            : backendStatus === BackendTroveStatus.closedByLiquidation\n                ? \"closedByLiquidation\"\n                : backendStatus === BackendTroveStatus.closedByRedemption\n                    ? \"closedByRedemption\"\n                    : panic(new Error(`invalid backendStatus ${backendStatus}`));\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\nconst numberify = (bigNumber) => bigNumber.toNumber();\nconst convertToDate = (timestamp) => new Date(timestamp * 1000);\nconst validSortingOptions = [\"ascendingCollateralRatio\", \"descendingCollateralRatio\"];\nconst expectPositiveInt = (obj, key) => {\n    if (obj[key] !== undefined) {\n        if (!Number.isInteger(obj[key])) {\n            throw new Error(`${key} must be an integer`);\n        }\n        if (obj[key] < 0) {\n            throw new Error(`${key} must not be negative`);\n        }\n    }\n};\n/**\n * Ethers-based implementation of {@link @liquity/lib-base#ReadableLiquity}.\n *\n * @public\n */\nclass ReadableEthersLiquity {\n    /** @internal */\n    constructor(connection) {\n        this.connection = connection;\n    }\n    /** @internal */\n    static _from(connection) {\n        const readable = new ReadableEthersLiquity(connection);\n        return connection.useStore === \"blockPolled\"\n            ? new _BlockPolledReadableEthersLiquity(readable)\n            : readable;\n    }\n    /**\n     * Connect to the Liquity protocol and create a `ReadableEthersLiquity` object.\n     *\n     * @param signerOrProvider - Ethers `Signer` or `Provider` to use for connecting to the Ethereum\n     *                           network.\n     * @param optionalParams - Optional parameters that can be used to customize the connection.\n     */\n    static async connect(signerOrProvider, optionalParams) {\n        return ReadableEthersLiquity._from(await EthersLiquityConnection_1._connect(signerOrProvider, optionalParams));\n    }\n    hasStore() {\n        return false;\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalRedistributed} */\n    async getTotalRedistributed(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [collateral, debt] = await Promise.all([\n            troveManager.L_ETH({ ...overrides }).then(decimalify),\n            troveManager.L_LUSDDebt({ ...overrides }).then(decimalify)\n        ]);\n        return new lib_base_1.Trove(collateral, debt);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTroveBeforeRedistribution} */\n    async getTroveBeforeRedistribution(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [trove, snapshot] = await Promise.all([\n            troveManager.Troves(address, { ...overrides }),\n            troveManager.rewardSnapshots(address, { ...overrides })\n        ]);\n        if (trove.status === BackendTroveStatus.active) {\n            return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status), decimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(snapshot.ETH), decimalify(snapshot.LUSDDebt)));\n        }\n        else {\n            return new lib_base_1.TroveWithPendingRedistribution(address, userTroveStatusFrom(trove.status));\n        }\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTrove} */\n    async getTrove(address, overrides) {\n        const [trove, totalRedistributed] = await Promise.all([\n            this.getTroveBeforeRedistribution(address, overrides),\n            this.getTotalRedistributed(overrides)\n        ]);\n        return trove.applyRedistribution(totalRedistributed);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getNumberOfTroves} */\n    async getNumberOfTroves(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        return (await troveManager.getTroveOwnersCount({ ...overrides })).toNumber();\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getPrice} */\n    getPrice(overrides) {\n        const { priceFeed } = EthersLiquityConnection_1._getContracts(this.connection);\n        return priceFeed.callStatic.fetchPrice({ ...overrides }).then(decimalify);\n    }\n    /** @internal */\n    async _getActivePool(overrides) {\n        const { activePool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [activeCollateral, activeDebt] = await Promise.all([\n            activePool.getETH({ ...overrides }),\n            activePool.getLUSDDebt({ ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.Trove(activeCollateral, activeDebt);\n    }\n    /** @internal */\n    async _getDefaultPool(overrides) {\n        const { defaultPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [liquidatedCollateral, closedDebt] = await Promise.all([\n            defaultPool.getETH({ ...overrides }),\n            defaultPool.getLUSDDebt({ ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.Trove(liquidatedCollateral, closedDebt);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotal} */\n    async getTotal(overrides) {\n        const [activePool, defaultPool] = await Promise.all([\n            this._getActivePool(overrides),\n            this._getDefaultPool(overrides)\n        ]);\n        return activePool.add(defaultPool);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getStabilityDeposit} */\n    async getStabilityDeposit(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [{ frontEndTag, initialValue }, currentLUSD, collateralGain, lqtyReward] = await Promise.all([\n            stabilityPool.deposits(address, { ...overrides }),\n            stabilityPool.getCompoundedLUSDDeposit(address, { ...overrides }),\n            stabilityPool.getDepositorETHGain(address, { ...overrides }),\n            stabilityPool.getDepositorLQTYGain(address, { ...overrides })\n        ]);\n        return new lib_base_1.StabilityDeposit(decimalify(initialValue), decimalify(currentLUSD), decimalify(collateralGain), decimalify(lqtyReward), frontEndTag);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingStabilityPoolLQTYReward} */\n    async getRemainingStabilityPoolLQTYReward(overrides) {\n        const { communityIssuance } = EthersLiquityConnection_1._getContracts(this.connection);\n        const issuanceCap = this.connection.totalStabilityPoolLQTYReward;\n        const totalLQTYIssued = decimalify(await communityIssuance.totalLQTYIssued({ ...overrides }));\n        // totalLQTYIssued approaches but never reaches issuanceCap\n        return issuanceCap.sub(totalLQTYIssued);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDInStabilityPool} */\n    getLUSDInStabilityPool(overrides) {\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return stabilityPool.getTotalLUSDDeposits({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLUSDBalance} */\n    getLUSDBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lusdToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYBalance} */\n    getLQTYBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lqtyToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lqtyToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenBalance} */\n    getUniTokenBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { uniToken } = EthersLiquityConnection_1._getContracts(this.connection);\n        return uniToken.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getUniTokenAllowance} */\n    getUniTokenAllowance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { uniToken, unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return uniToken.allowance(address, unipool.address, { ...overrides }).then(decimalify);\n    }\n    /** @internal */\n    async _getRemainingLiquidityMiningLQTYRewardCalculator(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [totalSupply, rewardRate, periodFinish, lastUpdateTime] = await Promise.all([\n            unipool.totalSupply({ ...overrides }),\n            unipool.rewardRate({ ...overrides }).then(decimalify),\n            unipool.periodFinish({ ...overrides }).then(numberify),\n            unipool.lastUpdateTime({ ...overrides }).then(numberify)\n        ]);\n        return (blockTimestamp) => rewardRate.mul(Math.max(0, periodFinish - (totalSupply.isZero() ? lastUpdateTime : blockTimestamp)));\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getRemainingLiquidityMiningLQTYReward} */\n    async getRemainingLiquidityMiningLQTYReward(overrides) {\n        const [calculateRemainingLQTY, blockTimestamp] = await Promise.all([\n            this._getRemainingLiquidityMiningLQTYRewardCalculator(overrides),\n            EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)\n        ]);\n        return calculateRemainingLQTY(blockTimestamp);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningStake} */\n    getLiquidityMiningStake(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.balanceOf(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedUniTokens} */\n    getTotalStakedUniTokens(overrides) {\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.totalSupply({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLiquidityMiningLQTYReward} */\n    getLiquidityMiningLQTYReward(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { unipool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return unipool.earned(address, { ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getCollateralSurplusBalance} */\n    getCollateralSurplusBalance(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { collSurplusPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        return collSurplusPool.getCollateral(address, { ...overrides }).then(decimalify);\n    }\n    async getTroves(params, overrides) {\n        var _a, _b;\n        const { multiTroveGetter } = EthersLiquityConnection_1._getContracts(this.connection);\n        expectPositiveInt(params, \"first\");\n        expectPositiveInt(params, \"startingAt\");\n        if (!validSortingOptions.includes(params.sortedBy)) {\n            throw new Error(`sortedBy must be one of: ${validSortingOptions.map(x => `\"${x}\"`).join(\", \")}`);\n        }\n        const [totalRedistributed, backendTroves] = await Promise.all([\n            params.beforeRedistribution ? undefined : this.getTotalRedistributed({ ...overrides }),\n            multiTroveGetter.getMultipleSortedTroves(params.sortedBy === \"descendingCollateralRatio\"\n                ? (_a = params.startingAt) !== null && _a !== void 0 ? _a : 0 : -(((_b = params.startingAt) !== null && _b !== void 0 ? _b : 0) + 1), params.first, { ...overrides })\n        ]);\n        const troves = mapBackendTroves(backendTroves);\n        if (totalRedistributed) {\n            return troves.map(trove => trove.applyRedistribution(totalRedistributed));\n        }\n        else {\n            return troves;\n        }\n    }\n    /** @internal */\n    async _getFeesFactory(overrides) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [lastFeeOperationTime, baseRateWithoutDecay] = await Promise.all([\n            troveManager.lastFeeOperationTime({ ...overrides }),\n            troveManager.baseRate({ ...overrides }).then(decimalify)\n        ]);\n        return (blockTimestamp, recoveryMode) => new lib_base_1.Fees(baseRateWithoutDecay, MINUTE_DECAY_FACTOR, BETA, convertToDate(lastFeeOperationTime.toNumber()), convertToDate(blockTimestamp), recoveryMode);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFees} */\n    async getFees(overrides) {\n        const [createFees, total, price, blockTimestamp] = await Promise.all([\n            this._getFeesFactory(overrides),\n            this.getTotal(overrides),\n            this.getPrice(overrides),\n            EthersLiquityConnection_1._getBlockTimestamp(this.connection, overrides === null || overrides === void 0 ? void 0 : overrides.blockTag)\n        ]);\n        return createFees(blockTimestamp, total.collateralRatioIsBelowCritical(price));\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getLQTYStake} */\n    async getLQTYStake(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this.connection));\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this.connection);\n        const [stakedLQTY, collateralGain, lusdGain] = await Promise.all([\n            lqtyStaking.stakes(address, { ...overrides }),\n            lqtyStaking.getPendingETHGain(address, { ...overrides }),\n            lqtyStaking.getPendingLUSDGain(address, { ...overrides })\n        ].map(getBigNumber => getBigNumber.then(decimalify)));\n        return new lib_base_1.LQTYStake(stakedLQTY, collateralGain, lusdGain);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getTotalStakedLQTY} */\n    async getTotalStakedLQTY(overrides) {\n        const { lqtyStaking } = EthersLiquityConnection_1._getContracts(this.connection);\n        return lqtyStaking.totalLQTYStaked({ ...overrides }).then(decimalify);\n    }\n    /** {@inheritDoc @liquity/lib-base#ReadableLiquity.getFrontendStatus} */\n    async getFrontendStatus(address, overrides) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireFrontendAddress(this.connection));\n        const { stabilityPool } = EthersLiquityConnection_1._getContracts(this.connection);\n        const { registered, kickbackRate } = await stabilityPool.frontEnds(address, { ...overrides });\n        return registered\n            ? { status: \"registered\", kickbackRate: decimalify(kickbackRate) }\n            : { status: \"unregistered\" };\n    }\n}\nexports.ReadableEthersLiquity = ReadableEthersLiquity;\nconst mapBackendTroves = (troves) => troves.map(trove => new lib_base_1.TroveWithPendingRedistribution(trove.owner, \"open\", // These Troves are coming from the SortedTroves list, so they must be open\ndecimalify(trove.coll), decimalify(trove.debt), decimalify(trove.stake), new lib_base_1.Trove(decimalify(trove.snapshotETH), decimalify(trove.snapshotLUSDDebt))));\nclass BlockPolledLiquityStoreBasedCache {\n    constructor(store) {\n        this._store = store;\n    }\n    _blockHit(overrides) {\n        return (!overrides ||\n            overrides.blockTag === undefined ||\n            overrides.blockTag === this._store.state.blockTag);\n    }\n    _userHit(address, overrides) {\n        return (this._blockHit(overrides) &&\n            (address === undefined || address === this._store.connection.userAddress));\n    }\n    _frontendHit(address, overrides) {\n        return (this._blockHit(overrides) &&\n            (address === undefined || address === this._store.connection.frontendTag));\n    }\n    getTotalRedistributed(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalRedistributed;\n        }\n    }\n    getTroveBeforeRedistribution(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.troveBeforeRedistribution;\n        }\n    }\n    getTrove(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.trove;\n        }\n    }\n    getNumberOfTroves(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.numberOfTroves;\n        }\n    }\n    getPrice(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.price;\n        }\n    }\n    getTotal(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.total;\n        }\n    }\n    getStabilityDeposit(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.stabilityDeposit;\n        }\n    }\n    getRemainingStabilityPoolLQTYReward(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.remainingStabilityPoolLQTYReward;\n        }\n    }\n    getLUSDInStabilityPool(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.lusdInStabilityPool;\n        }\n    }\n    getLUSDBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lusdBalance;\n        }\n    }\n    getLQTYBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lqtyBalance;\n        }\n    }\n    getUniTokenBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.uniTokenBalance;\n        }\n    }\n    getUniTokenAllowance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.uniTokenAllowance;\n        }\n    }\n    getRemainingLiquidityMiningLQTYReward(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.remainingLiquidityMiningLQTYReward;\n        }\n    }\n    getLiquidityMiningStake(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.liquidityMiningStake;\n        }\n    }\n    getTotalStakedUniTokens(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalStakedUniTokens;\n        }\n    }\n    getLiquidityMiningLQTYReward(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.liquidityMiningLQTYReward;\n        }\n    }\n    getCollateralSurplusBalance(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.collateralSurplusBalance;\n        }\n    }\n    getFees(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.fees;\n        }\n    }\n    getLQTYStake(address, overrides) {\n        if (this._userHit(address, overrides)) {\n            return this._store.state.lqtyStake;\n        }\n    }\n    getTotalStakedLQTY(overrides) {\n        if (this._blockHit(overrides)) {\n            return this._store.state.totalStakedLQTY;\n        }\n    }\n    getFrontendStatus(address, overrides) {\n        if (this._frontendHit(address, overrides)) {\n            return this._store.state.frontend;\n        }\n    }\n    getTroves() {\n        return undefined;\n    }\n}\nclass _BlockPolledReadableEthersLiquity extends lib_base_1._CachedReadableLiquity {\n    constructor(readable) {\n        const store = new BlockPolledLiquityStore_1.BlockPolledLiquityStore(readable);\n        super(readable, new BlockPolledLiquityStoreBasedCache(store));\n        this.store = store;\n        this.connection = readable.connection;\n    }\n    hasStore(store) {\n        return store === undefined || store === \"blockPolled\";\n    }\n    _getActivePool() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getDefaultPool() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getFeesFactory() {\n        throw new Error(\"Method not implemented.\");\n    }\n    _getRemainingLiquidityMiningLQTYRewardCalculator() {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n//# sourceMappingURL=ReadableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}