{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservableEthersLiquity = void 0;\n\nvar EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nvar debouncingDelayMs = 50;\n\nvar debounce = function debounce(listener) {\n  var timeoutId = undefined;\n  var latestBlock = 0;\n  return function () {\n    var _ref;\n\n    var event = (_ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);\n\n    if (event.blockNumber !== undefined && event.blockNumber > latestBlock) {\n      latestBlock = event.blockNumber;\n    }\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(function () {\n      listener(latestBlock);\n      timeoutId = undefined;\n    }, debouncingDelayMs);\n  };\n};\n/** @alpha */\n\n\nvar ObservableEthersLiquity = /*#__PURE__*/function () {\n  function ObservableEthersLiquity(readable) {\n    _classCallCheck(this, ObservableEthersLiquity);\n\n    this._readable = readable;\n  }\n\n  _createClass(ObservableEthersLiquity, [{\n    key: \"watchTotalRedistributed\",\n    value: function watchTotalRedistributed(onTotalRedistributedChanged) {\n      var _this = this;\n\n      var _EthersLiquityConnect = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          activePool = _EthersLiquityConnect.activePool,\n          defaultPool = _EthersLiquityConnect.defaultPool;\n\n      var etherSent = activePool.filters.EtherSent();\n      var redistributionListener = debounce(function (blockTag) {\n        _this._readable.getTotalRedistributed({\n          blockTag: blockTag\n        }).then(onTotalRedistributedChanged);\n      });\n\n      var etherSentListener = function etherSentListener(toAddress, _amount, event) {\n        if (toAddress === defaultPool.address) {\n          redistributionListener(event);\n        }\n      };\n\n      activePool.on(etherSent, etherSentListener);\n      return function () {\n        activePool.removeListener(etherSent, etherSentListener);\n      };\n    }\n  }, {\n    key: \"watchTroveWithoutRewards\",\n    value: function watchTroveWithoutRewards(onTroveChanged, address) {\n      var _this2 = this;\n\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n      var _EthersLiquityConnect2 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          troveManager = _EthersLiquityConnect2.troveManager,\n          borrowerOperations = _EthersLiquityConnect2.borrowerOperations;\n\n      var troveUpdatedByTroveManager = troveManager.filters.TroveUpdated(address);\n      var troveUpdatedByBorrowerOperations = borrowerOperations.filters.TroveUpdated(address);\n      var troveListener = debounce(function (blockTag) {\n        _this2._readable.getTroveBeforeRedistribution(address, {\n          blockTag: blockTag\n        }).then(onTroveChanged);\n      });\n      troveManager.on(troveUpdatedByTroveManager, troveListener);\n      borrowerOperations.on(troveUpdatedByBorrowerOperations, troveListener);\n      return function () {\n        troveManager.removeListener(troveUpdatedByTroveManager, troveListener);\n        borrowerOperations.removeListener(troveUpdatedByBorrowerOperations, troveListener);\n      };\n    }\n  }, {\n    key: \"watchNumberOfTroves\",\n    value: function watchNumberOfTroves(onNumberOfTrovesChanged) {\n      var _this3 = this;\n\n      var _EthersLiquityConnect3 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          troveManager = _EthersLiquityConnect3.troveManager;\n\n      var TroveUpdated = troveManager.filters.TroveUpdated;\n      var troveUpdated = TroveUpdated();\n      var troveUpdatedListener = debounce(function (blockTag) {\n        _this3._readable.getNumberOfTroves({\n          blockTag: blockTag\n        }).then(onNumberOfTrovesChanged);\n      });\n      troveManager.on(troveUpdated, troveUpdatedListener);\n      return function () {\n        troveManager.removeListener(troveUpdated, troveUpdatedListener);\n      };\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"watchPrice\",\n    value: function watchPrice(onPriceChanged) {\n      // TODO revisit\n      // We no longer have our own PriceUpdated events. If we want to implement this in an event-based\n      // manner, we'll need to listen to aggregator events directly. Or we could do polling.\n      throw new Error(\"Method not implemented.\");\n    }\n  }, {\n    key: \"watchTotal\",\n    value: function watchTotal(onTotalChanged) {\n      var _this4 = this;\n\n      var _EthersLiquityConnect4 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          troveManager = _EthersLiquityConnect4.troveManager;\n\n      var TroveUpdated = troveManager.filters.TroveUpdated;\n      var troveUpdated = TroveUpdated();\n      var totalListener = debounce(function (blockTag) {\n        _this4._readable.getTotal({\n          blockTag: blockTag\n        }).then(onTotalChanged);\n      });\n      troveManager.on(troveUpdated, totalListener);\n      return function () {\n        troveManager.removeListener(troveUpdated, totalListener);\n      };\n    }\n  }, {\n    key: \"watchStabilityDeposit\",\n    value: function watchStabilityDeposit(onStabilityDepositChanged, address) {\n      var _this5 = this;\n\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n      var _EthersLiquityConnect5 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          activePool = _EthersLiquityConnect5.activePool,\n          stabilityPool = _EthersLiquityConnect5.stabilityPool;\n\n      var UserDepositChanged = stabilityPool.filters.UserDepositChanged;\n      var EtherSent = activePool.filters.EtherSent;\n      var userDepositChanged = UserDepositChanged(address);\n      var etherSent = EtherSent();\n      var depositListener = debounce(function (blockTag) {\n        _this5._readable.getStabilityDeposit(address, {\n          blockTag: blockTag\n        }).then(onStabilityDepositChanged);\n      });\n\n      var etherSentListener = function etherSentListener(toAddress, _amount, event) {\n        if (toAddress === stabilityPool.address) {\n          // Liquidation while Stability Pool has some deposits\n          // There may be new gains\n          depositListener(event);\n        }\n      };\n\n      stabilityPool.on(userDepositChanged, depositListener);\n      activePool.on(etherSent, etherSentListener);\n      return function () {\n        stabilityPool.removeListener(userDepositChanged, depositListener);\n        activePool.removeListener(etherSent, etherSentListener);\n      };\n    }\n  }, {\n    key: \"watchLUSDInStabilityPool\",\n    value: function watchLUSDInStabilityPool(onLUSDInStabilityPoolChanged) {\n      var _this6 = this;\n\n      var _EthersLiquityConnect6 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          lusdToken = _EthersLiquityConnect6.lusdToken,\n          stabilityPool = _EthersLiquityConnect6.stabilityPool;\n\n      var Transfer = lusdToken.filters.Transfer;\n      var transferLUSDFromStabilityPool = Transfer(stabilityPool.address);\n      var transferLUSDToStabilityPool = Transfer(null, stabilityPool.address);\n      var stabilityPoolLUSDFilters = [transferLUSDFromStabilityPool, transferLUSDToStabilityPool];\n      var stabilityPoolLUSDListener = debounce(function (blockTag) {\n        _this6._readable.getLUSDInStabilityPool({\n          blockTag: blockTag\n        }).then(onLUSDInStabilityPoolChanged);\n      });\n      stabilityPoolLUSDFilters.forEach(function (filter) {\n        return lusdToken.on(filter, stabilityPoolLUSDListener);\n      });\n      return function () {\n        return stabilityPoolLUSDFilters.forEach(function (filter) {\n          return lusdToken.removeListener(filter, stabilityPoolLUSDListener);\n        });\n      };\n    }\n  }, {\n    key: \"watchLUSDBalance\",\n    value: function watchLUSDBalance(onLUSDBalanceChanged, address) {\n      var _this7 = this;\n\n      address !== null && address !== void 0 ? address : address = EthersLiquityConnection_1._requireAddress(this._readable.connection);\n\n      var _EthersLiquityConnect7 = EthersLiquityConnection_1._getContracts(this._readable.connection),\n          lusdToken = _EthersLiquityConnect7.lusdToken;\n\n      var Transfer = lusdToken.filters.Transfer;\n      var transferLUSDFromUser = Transfer(address);\n      var transferLUSDToUser = Transfer(null, address);\n      var lusdTransferFilters = [transferLUSDFromUser, transferLUSDToUser];\n      var lusdTransferListener = debounce(function (blockTag) {\n        _this7._readable.getLUSDBalance(address, {\n          blockTag: blockTag\n        }).then(onLUSDBalanceChanged);\n      });\n      lusdTransferFilters.forEach(function (filter) {\n        return lusdToken.on(filter, lusdTransferListener);\n      });\n      return function () {\n        return lusdTransferFilters.forEach(function (filter) {\n          return lusdToken.removeListener(filter, lusdTransferListener);\n        });\n      };\n    }\n  }]);\n\n  return ObservableEthersLiquity;\n}();\n\nexports.ObservableEthersLiquity = ObservableEthersLiquity;","map":{"version":3,"sources":["../../src/ObservableEthersLiquity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservableEthersLiquity = void 0;\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst debouncingDelayMs = 50;\nconst debounce = (listener) => {\n    let timeoutId = undefined;\n    let latestBlock = 0;\n    return (...args) => {\n        const event = args[args.length - 1];\n        if (event.blockNumber !== undefined && event.blockNumber > latestBlock) {\n            latestBlock = event.blockNumber;\n        }\n        if (timeoutId !== undefined) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            listener(latestBlock);\n            timeoutId = undefined;\n        }, debouncingDelayMs);\n    };\n};\n/** @alpha */\nclass ObservableEthersLiquity {\n    constructor(readable) {\n        this._readable = readable;\n    }\n    watchTotalRedistributed(onTotalRedistributedChanged) {\n        const { activePool, defaultPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const etherSent = activePool.filters.EtherSent();\n        const redistributionListener = debounce((blockTag) => {\n            this._readable.getTotalRedistributed({ blockTag }).then(onTotalRedistributedChanged);\n        });\n        const etherSentListener = (toAddress, _amount, event) => {\n            if (toAddress === defaultPool.address) {\n                redistributionListener(event);\n            }\n        };\n        activePool.on(etherSent, etherSentListener);\n        return () => {\n            activePool.removeListener(etherSent, etherSentListener);\n        };\n    }\n    watchTroveWithoutRewards(onTroveChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { troveManager, borrowerOperations } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const troveUpdatedByTroveManager = troveManager.filters.TroveUpdated(address);\n        const troveUpdatedByBorrowerOperations = borrowerOperations.filters.TroveUpdated(address);\n        const troveListener = debounce((blockTag) => {\n            this._readable.getTroveBeforeRedistribution(address, { blockTag }).then(onTroveChanged);\n        });\n        troveManager.on(troveUpdatedByTroveManager, troveListener);\n        borrowerOperations.on(troveUpdatedByBorrowerOperations, troveListener);\n        return () => {\n            troveManager.removeListener(troveUpdatedByTroveManager, troveListener);\n            borrowerOperations.removeListener(troveUpdatedByBorrowerOperations, troveListener);\n        };\n    }\n    watchNumberOfTroves(onNumberOfTrovesChanged) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { TroveUpdated } = troveManager.filters;\n        const troveUpdated = TroveUpdated();\n        const troveUpdatedListener = debounce((blockTag) => {\n            this._readable.getNumberOfTroves({ blockTag }).then(onNumberOfTrovesChanged);\n        });\n        troveManager.on(troveUpdated, troveUpdatedListener);\n        return () => {\n            troveManager.removeListener(troveUpdated, troveUpdatedListener);\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    watchPrice(onPriceChanged) {\n        // TODO revisit\n        // We no longer have our own PriceUpdated events. If we want to implement this in an event-based\n        // manner, we'll need to listen to aggregator events directly. Or we could do polling.\n        throw new Error(\"Method not implemented.\");\n    }\n    watchTotal(onTotalChanged) {\n        const { troveManager } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { TroveUpdated } = troveManager.filters;\n        const troveUpdated = TroveUpdated();\n        const totalListener = debounce((blockTag) => {\n            this._readable.getTotal({ blockTag }).then(onTotalChanged);\n        });\n        troveManager.on(troveUpdated, totalListener);\n        return () => {\n            troveManager.removeListener(troveUpdated, totalListener);\n        };\n    }\n    watchStabilityDeposit(onStabilityDepositChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { activePool, stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { UserDepositChanged } = stabilityPool.filters;\n        const { EtherSent } = activePool.filters;\n        const userDepositChanged = UserDepositChanged(address);\n        const etherSent = EtherSent();\n        const depositListener = debounce((blockTag) => {\n            this._readable.getStabilityDeposit(address, { blockTag }).then(onStabilityDepositChanged);\n        });\n        const etherSentListener = (toAddress, _amount, event) => {\n            if (toAddress === stabilityPool.address) {\n                // Liquidation while Stability Pool has some deposits\n                // There may be new gains\n                depositListener(event);\n            }\n        };\n        stabilityPool.on(userDepositChanged, depositListener);\n        activePool.on(etherSent, etherSentListener);\n        return () => {\n            stabilityPool.removeListener(userDepositChanged, depositListener);\n            activePool.removeListener(etherSent, etherSentListener);\n        };\n    }\n    watchLUSDInStabilityPool(onLUSDInStabilityPoolChanged) {\n        const { lusdToken, stabilityPool } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { Transfer } = lusdToken.filters;\n        const transferLUSDFromStabilityPool = Transfer(stabilityPool.address);\n        const transferLUSDToStabilityPool = Transfer(null, stabilityPool.address);\n        const stabilityPoolLUSDFilters = [transferLUSDFromStabilityPool, transferLUSDToStabilityPool];\n        const stabilityPoolLUSDListener = debounce((blockTag) => {\n            this._readable.getLUSDInStabilityPool({ blockTag }).then(onLUSDInStabilityPoolChanged);\n        });\n        stabilityPoolLUSDFilters.forEach(filter => lusdToken.on(filter, stabilityPoolLUSDListener));\n        return () => stabilityPoolLUSDFilters.forEach(filter => lusdToken.removeListener(filter, stabilityPoolLUSDListener));\n    }\n    watchLUSDBalance(onLUSDBalanceChanged, address) {\n        address !== null && address !== void 0 ? address : (address = EthersLiquityConnection_1._requireAddress(this._readable.connection));\n        const { lusdToken } = EthersLiquityConnection_1._getContracts(this._readable.connection);\n        const { Transfer } = lusdToken.filters;\n        const transferLUSDFromUser = Transfer(address);\n        const transferLUSDToUser = Transfer(null, address);\n        const lusdTransferFilters = [transferLUSDFromUser, transferLUSDToUser];\n        const lusdTransferListener = debounce((blockTag) => {\n            this._readable.getLUSDBalance(address, { blockTag }).then(onLUSDBalanceChanged);\n        });\n        lusdTransferFilters.forEach(filter => lusdToken.on(filter, lusdTransferListener));\n        return () => lusdTransferFilters.forEach(filter => lusdToken.removeListener(filter, lusdTransferListener));\n    }\n}\nexports.ObservableEthersLiquity = ObservableEthersLiquity;\n//# sourceMappingURL=ObservableEthersLiquity.js.map"]},"metadata":{},"sourceType":"script"}