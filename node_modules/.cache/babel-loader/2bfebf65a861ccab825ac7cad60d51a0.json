{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockPolledLiquityStore = void 0;\n\nvar constants_1 = require(\"@ethersproject/constants\");\n\nvar lib_base_1 = require(\"@liquity/lib-base\");\n\nvar EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\n\nvar promiseAllValues = function promiseAllValues(object) {\n  var keys = Object.keys(object);\n  return Promise.all(Object.values(object)).then(function (values) {\n    return Object.fromEntries(values.map(function (value, i) {\n      return [keys[i], value];\n    }));\n  });\n};\n\nvar decimalify = function decimalify(bigNumber) {\n  return lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n};\n/**\n * Ethers-based {@link @liquity/lib-base#LiquityStore} that updates state whenever there's a new\n * block.\n *\n * @public\n */\n\n\nvar BlockPolledLiquityStore = /*#__PURE__*/function (_lib_base_1$LiquitySt) {\n  _inherits(BlockPolledLiquityStore, _lib_base_1$LiquitySt);\n\n  var _super = _createSuper(BlockPolledLiquityStore);\n\n  function BlockPolledLiquityStore(readable) {\n    var _this;\n\n    _classCallCheck(this, BlockPolledLiquityStore);\n\n    _this = _super.call(this);\n    _this.connection = readable.connection;\n    _this._readable = readable;\n    _this._provider = EthersLiquityConnection_1._getProvider(readable.connection);\n    return _this;\n  }\n\n  _createClass(BlockPolledLiquityStore, [{\n    key: \"_getRiskiestTroveBeforeRedistribution\",\n    value: function () {\n      var _getRiskiestTroveBeforeRedistribution2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(overrides) {\n        var riskiestTroves;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._readable.getTroves({\n                  first: 1,\n                  sortedBy: \"ascendingCollateralRatio\",\n                  beforeRedistribution: true\n                }, overrides);\n\n              case 2:\n                riskiestTroves = _context.sent;\n\n                if (!(riskiestTroves.length === 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\"));\n\n              case 5:\n                return _context.abrupt(\"return\", riskiestTroves[0]);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _getRiskiestTroveBeforeRedistribution(_x) {\n        return _getRiskiestTroveBeforeRedistribution2.apply(this, arguments);\n      }\n\n      return _getRiskiestTroveBeforeRedistribution;\n    }()\n  }, {\n    key: \"_get\",\n    value: function () {\n      var _get2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blockTag) {\n        var _this$connection, userAddress, frontendTag, _yield$promiseAllValu, blockTimestamp, createFees, calculateRemainingLQTY, baseState;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$connection = this.connection, userAddress = _this$connection.userAddress, frontendTag = _this$connection.frontendTag;\n                _context2.next = 3;\n                return promiseAllValues(_objectSpread({\n                  blockTimestamp: EthersLiquityConnection_1._getBlockTimestamp(this.connection, blockTag),\n                  createFees: this._readable._getFeesFactory({\n                    blockTag: blockTag\n                  }),\n                  calculateRemainingLQTY: this._readable._getRemainingLiquidityMiningLQTYRewardCalculator({\n                    blockTag: blockTag\n                  }),\n                  price: this._readable.getPrice({\n                    blockTag: blockTag\n                  }),\n                  numberOfTroves: this._readable.getNumberOfTroves({\n                    blockTag: blockTag\n                  }),\n                  totalRedistributed: this._readable.getTotalRedistributed({\n                    blockTag: blockTag\n                  }),\n                  total: this._readable.getTotal({\n                    blockTag: blockTag\n                  }),\n                  lusdInStabilityPool: this._readable.getLUSDInStabilityPool({\n                    blockTag: blockTag\n                  }),\n                  totalStakedLQTY: this._readable.getTotalStakedLQTY({\n                    blockTag: blockTag\n                  }),\n                  _riskiestTroveBeforeRedistribution: this._getRiskiestTroveBeforeRedistribution({\n                    blockTag: blockTag\n                  }),\n                  totalStakedUniTokens: this._readable.getTotalStakedUniTokens({\n                    blockTag: blockTag\n                  }),\n                  remainingStabilityPoolLQTYReward: this._readable.getRemainingStabilityPoolLQTYReward({\n                    blockTag: blockTag\n                  }),\n                  frontend: frontendTag ? this._readable.getFrontendStatus(frontendTag, {\n                    blockTag: blockTag\n                  }) : {\n                    status: \"unregistered\"\n                  }\n                }, userAddress ? {\n                  accountBalance: this._provider.getBalance(userAddress, blockTag).then(decimalify),\n                  lusdBalance: this._readable.getLUSDBalance(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  lqtyBalance: this._readable.getLQTYBalance(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  uniTokenBalance: this._readable.getUniTokenBalance(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  uniTokenAllowance: this._readable.getUniTokenAllowance(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  liquidityMiningStake: this._readable.getLiquidityMiningStake(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  liquidityMiningLQTYReward: this._readable.getLiquidityMiningLQTYReward(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  collateralSurplusBalance: this._readable.getCollateralSurplusBalance(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  troveBeforeRedistribution: this._readable.getTroveBeforeRedistribution(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  stabilityDeposit: this._readable.getStabilityDeposit(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  lqtyStake: this._readable.getLQTYStake(userAddress, {\n                    blockTag: blockTag\n                  }),\n                  ownFrontend: this._readable.getFrontendStatus(userAddress, {\n                    blockTag: blockTag\n                  })\n                } : {\n                  accountBalance: lib_base_1.Decimal.ZERO,\n                  lusdBalance: lib_base_1.Decimal.ZERO,\n                  lqtyBalance: lib_base_1.Decimal.ZERO,\n                  uniTokenBalance: lib_base_1.Decimal.ZERO,\n                  uniTokenAllowance: lib_base_1.Decimal.ZERO,\n                  liquidityMiningStake: lib_base_1.Decimal.ZERO,\n                  liquidityMiningLQTYReward: lib_base_1.Decimal.ZERO,\n                  collateralSurplusBalance: lib_base_1.Decimal.ZERO,\n                  troveBeforeRedistribution: new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\"),\n                  stabilityDeposit: new lib_base_1.StabilityDeposit(lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, constants_1.AddressZero),\n                  lqtyStake: new lib_base_1.LQTYStake(),\n                  ownFrontend: {\n                    status: \"unregistered\"\n                  }\n                }));\n\n              case 3:\n                _yield$promiseAllValu = _context2.sent;\n                blockTimestamp = _yield$promiseAllValu.blockTimestamp;\n                createFees = _yield$promiseAllValu.createFees;\n                calculateRemainingLQTY = _yield$promiseAllValu.calculateRemainingLQTY;\n                baseState = _objectWithoutProperties(_yield$promiseAllValu, [\"blockTimestamp\", \"createFees\", \"calculateRemainingLQTY\"]);\n                return _context2.abrupt(\"return\", [_objectSpread(_objectSpread({}, baseState), {}, {\n                  _feesInNormalMode: createFees(blockTimestamp, false),\n                  remainingLiquidityMiningLQTYReward: calculateRemainingLQTY(blockTimestamp)\n                }), {\n                  blockTag: blockTag,\n                  blockTimestamp: blockTimestamp\n                }]);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _get(_x2) {\n        return _get2.apply(this, arguments);\n      }\n\n      return _get;\n    }()\n    /** @internal @override */\n\n  }, {\n    key: \"_doStart\",\n    value: function _doStart() {\n      var _this2 = this;\n\n      this._get().then(function (state) {\n        if (!_this2._loaded) {\n          _this2._load.apply(_this2, _toConsumableArray(state));\n        }\n      });\n\n      var blockListener = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(blockTag) {\n          var state;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return _this2._get(blockTag);\n\n                case 2:\n                  state = _context3.sent;\n\n                  if (_this2._loaded) {\n                    _this2._update.apply(_this2, _toConsumableArray(state));\n                  } else {\n                    _this2._load.apply(_this2, _toConsumableArray(state));\n                  }\n\n                case 4:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function blockListener(_x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this._provider.on(\"block\", blockListener);\n\n      return function () {\n        _this2._provider.off(\"block\", blockListener);\n      };\n    }\n    /** @internal @override */\n\n  }, {\n    key: \"_reduceExtra\",\n    value: function _reduceExtra(oldState, stateUpdate) {\n      var _a, _b;\n\n      return {\n        blockTag: (_a = stateUpdate.blockTag) !== null && _a !== void 0 ? _a : oldState.blockTag,\n        blockTimestamp: (_b = stateUpdate.blockTimestamp) !== null && _b !== void 0 ? _b : oldState.blockTimestamp\n      };\n    }\n  }]);\n\n  return BlockPolledLiquityStore;\n}(lib_base_1.LiquityStore);\n\nexports.BlockPolledLiquityStore = BlockPolledLiquityStore;","map":{"version":3,"sources":["../../src/BlockPolledLiquityStore.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAWA,IAAA,yBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAuCA,IAAM,gBAAgB,GAAG,SAAnB,gBAAmB,CAAI,MAAJ,EAAiB;AACxC,MAAM,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAb;AAEA,SAAO,OAAO,CAAC,GAAR,CAAY,MAAM,CAAC,MAAP,CAAc,MAAd,CAAZ,EAAmC,IAAnC,CAAwC,UAAA,MAAM;AAAA,WACnD,MAAM,CAAC,WAAP,CAAmB,MAAM,CAAC,GAAP,CAAW,UAAC,KAAD,EAAQ,CAAR;AAAA,aAAc,CAAC,IAAI,CAAC,CAAD,CAAL,EAAU,KAAV,CAAd;AAAA,KAAX,CAAnB,CADmD;AAAA,GAA9C,CAAP;AAGD,CAND;;AAQA,IAAM,UAAU,GAAG,SAAb,UAAa,CAAC,SAAD;AAAA,SAA0B,UAAA,CAAA,OAAA,CAAQ,mBAAR,CAA4B,SAAS,CAAC,WAAV,EAA5B,CAA1B;AAAA,CAAnB;AAEA;;;;;AAKG;;;IACU,uB;;;;;AAMX,mCAAY,QAAZ,EAA2C;AAAA;;AAAA;;AACzC;AAEA,UAAK,UAAL,GAAkB,QAAQ,CAAC,UAA3B;AACA,UAAK,SAAL,GAAiB,QAAjB;AACA,UAAK,SAAL,GAAiB,yBAAA,CAAA,YAAA,CAAa,QAAQ,CAAC,UAAtB,CAAjB;AALyC;AAM1C;;;;;4GAEO,iBACN,SADM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAGuB,KAAK,SAAL,CAAe,SAAf,CAC3B;AAAE,kBAAA,KAAK,EAAE,CAAT;AAAY,kBAAA,QAAQ,EAAE,0BAAtB;AAAkD,kBAAA,oBAAoB,EAAE;AAAxE,iBAD2B,EAE3B,SAF2B,CAHvB;;AAAA;AAGA,gBAAA,cAHA;;AAAA,sBAQF,cAAc,CAAC,MAAf,KAA0B,CARxB;AAAA;AAAA;AAAA;;AAAA,iDASG,IAAI,UAAA,CAAA,8BAAJ,CAAmC,WAAA,CAAA,WAAnC,EAAgD,aAAhD,CATH;;AAAA;AAAA,iDAYC,cAAc,CAAC,CAAD,CAZf;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;2EAeA,kBACN,QADM;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mCAG+B,KAAK,UAHpC,EAGE,WAHF,oBAGE,WAHF,EAGe,WAHf,oBAGe,WAHf;AAAA;AAAA,uBAUI,gBAAgB;AACxB,kBAAA,cAAc,EAAE,yBAAA,CAAA,kBAAA,CAAmB,KAAK,UAAxB,EAAoC,QAApC,CADQ;AAExB,kBAAA,UAAU,EAAE,KAAK,SAAL,CAAe,eAAf,CAA+B;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA/B,CAFY;AAGxB,kBAAA,sBAAsB,EAAE,KAAK,SAAL,CAAe,gDAAf,CAAgE;AACtF,oBAAA,QAAQ,EAAR;AADsF,mBAAhE,CAHA;AAOxB,kBAAA,KAAK,EAAE,KAAK,SAAL,CAAe,QAAf,CAAwB;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAxB,CAPiB;AAQxB,kBAAA,cAAc,EAAE,KAAK,SAAL,CAAe,iBAAf,CAAiC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAjC,CARQ;AASxB,kBAAA,kBAAkB,EAAE,KAAK,SAAL,CAAe,qBAAf,CAAqC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAArC,CATI;AAUxB,kBAAA,KAAK,EAAE,KAAK,SAAL,CAAe,QAAf,CAAwB;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAxB,CAViB;AAWxB,kBAAA,mBAAmB,EAAE,KAAK,SAAL,CAAe,sBAAf,CAAsC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAtC,CAXG;AAYxB,kBAAA,eAAe,EAAE,KAAK,SAAL,CAAe,kBAAf,CAAkC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAlC,CAZO;AAaxB,kBAAA,kCAAkC,EAAE,KAAK,qCAAL,CAA2C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA3C,CAbZ;AAcxB,kBAAA,oBAAoB,EAAE,KAAK,SAAL,CAAe,uBAAf,CAAuC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAvC,CAdE;AAexB,kBAAA,gCAAgC,EAAE,KAAK,SAAL,CAAe,mCAAf,CAAmD;AACnF,oBAAA,QAAQ,EAAR;AADmF,mBAAnD,CAfV;AAmBxB,kBAAA,QAAQ,EAAE,WAAW,GACjB,KAAK,SAAL,CAAe,iBAAf,CAAiC,WAAjC,EAA8C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA9C,CADiB,GAEjB;AAAE,oBAAA,MAAM,EAAE;AAAV;AArBoB,mBAuBpB,WAAW,GACX;AACE,kBAAA,cAAc,EAAE,KAAK,SAAL,CAAe,UAAf,CAA0B,WAA1B,EAAuC,QAAvC,EAAiD,IAAjD,CAAsD,UAAtD,CADlB;AAEE,kBAAA,WAAW,EAAE,KAAK,SAAL,CAAe,cAAf,CAA8B,WAA9B,EAA2C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA3C,CAFf;AAGE,kBAAA,WAAW,EAAE,KAAK,SAAL,CAAe,cAAf,CAA8B,WAA9B,EAA2C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA3C,CAHf;AAIE,kBAAA,eAAe,EAAE,KAAK,SAAL,CAAe,kBAAf,CAAkC,WAAlC,EAA+C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA/C,CAJnB;AAKE,kBAAA,iBAAiB,EAAE,KAAK,SAAL,CAAe,oBAAf,CAAoC,WAApC,EAAiD;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAjD,CALrB;AAME,kBAAA,oBAAoB,EAAE,KAAK,SAAL,CAAe,uBAAf,CAAuC,WAAvC,EAAoD;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAApD,CANxB;AAOE,kBAAA,yBAAyB,EAAE,KAAK,SAAL,CAAe,4BAAf,CAA4C,WAA5C,EAAyD;AAClF,oBAAA,QAAQ,EAAR;AADkF,mBAAzD,CAP7B;AAUE,kBAAA,wBAAwB,EAAE,KAAK,SAAL,CAAe,2BAAf,CAA2C,WAA3C,EAAwD;AAChF,oBAAA,QAAQ,EAAR;AADgF,mBAAxD,CAV5B;AAaE,kBAAA,yBAAyB,EAAE,KAAK,SAAL,CAAe,4BAAf,CAA4C,WAA5C,EAAyD;AAClF,oBAAA,QAAQ,EAAR;AADkF,mBAAzD,CAb7B;AAgBE,kBAAA,gBAAgB,EAAE,KAAK,SAAL,CAAe,mBAAf,CAAmC,WAAnC,EAAgD;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAhD,CAhBpB;AAiBE,kBAAA,SAAS,EAAE,KAAK,SAAL,CAAe,YAAf,CAA4B,WAA5B,EAAyC;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAAzC,CAjBb;AAkBE,kBAAA,WAAW,EAAE,KAAK,SAAL,CAAe,iBAAf,CAAiC,WAAjC,EAA8C;AAAE,oBAAA,QAAQ,EAAR;AAAF,mBAA9C;AAlBf,iBADW,GAqBX;AACE,kBAAA,cAAc,EAAE,UAAA,CAAA,OAAA,CAAQ,IAD1B;AAEE,kBAAA,WAAW,EAAE,UAAA,CAAA,OAAA,CAAQ,IAFvB;AAGE,kBAAA,WAAW,EAAE,UAAA,CAAA,OAAA,CAAQ,IAHvB;AAIE,kBAAA,eAAe,EAAE,UAAA,CAAA,OAAA,CAAQ,IAJ3B;AAKE,kBAAA,iBAAiB,EAAE,UAAA,CAAA,OAAA,CAAQ,IAL7B;AAME,kBAAA,oBAAoB,EAAE,UAAA,CAAA,OAAA,CAAQ,IANhC;AAOE,kBAAA,yBAAyB,EAAE,UAAA,CAAA,OAAA,CAAQ,IAPrC;AAQE,kBAAA,wBAAwB,EAAE,UAAA,CAAA,OAAA,CAAQ,IARpC;AASE,kBAAA,yBAAyB,EAAE,IAAI,UAAA,CAAA,8BAAJ,CACzB,WAAA,CAAA,WADyB,EAEzB,aAFyB,CAT7B;AAaE,kBAAA,gBAAgB,EAAE,IAAI,UAAA,CAAA,gBAAJ,CAChB,UAAA,CAAA,OAAA,CAAQ,IADQ,EAEhB,UAAA,CAAA,OAAA,CAAQ,IAFQ,EAGhB,UAAA,CAAA,OAAA,CAAQ,IAHQ,EAIhB,UAAA,CAAA,OAAA,CAAQ,IAJQ,EAKhB,WAAA,CAAA,WALgB,CAbpB;AAoBE,kBAAA,SAAS,EAAE,IAAI,UAAA,CAAA,SAAJ,EApBb;AAqBE,kBAAA,WAAW,EAAE;AAAE,oBAAA,MAAM,EAAE;AAAV;AArBf,iBA5CoB,EAVpB;;AAAA;AAAA;AAMJ,gBAAA,cANI,yBAMJ,cANI;AAOJ,gBAAA,UAPI,yBAOJ,UAPI;AAQJ,gBAAA,sBARI,yBAQJ,sBARI;AASD,gBAAA,SATC;AAAA,kDA+EC,iCAEA,SAFA;AAGH,kBAAA,iBAAiB,EAAE,UAAU,CAAC,cAAD,EAAiB,KAAjB,CAH1B;AAIH,kBAAA,kCAAkC,EAAE,sBAAsB,CAAC,cAAD;AAJvD,oBAML;AACE,kBAAA,QAAQ,EAAR,QADF;AAEE,kBAAA,cAAc,EAAd;AAFF,iBANK,CA/ED;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AA4FR;;;;WACU,oBAAQ;AAAA;;AAChB,WAAK,IAAL,GAAY,IAAZ,CAAiB,UAAA,KAAK,EAAG;AACvB,YAAI,CAAC,MAAI,CAAC,OAAV,EAAmB;AACjB,UAAA,MAAI,CAAC,KAAL,OAAA,MAAI,qBAAU,KAAV,EAAJ;AACD;AACF,OAJD;;AAMA,UAAM,aAAa;AAAA,4EAAG,kBAAO,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACA,MAAI,CAAC,IAAL,CAAU,QAAV,CADA;;AAAA;AACd,kBAAA,KADc;;AAGpB,sBAAI,MAAI,CAAC,OAAT,EAAkB;AAChB,oBAAA,MAAI,CAAC,OAAL,OAAA,MAAI,qBAAY,KAAZ,EAAJ;AACD,mBAFD,MAEO;AACL,oBAAA,MAAI,CAAC,KAAL,OAAA,MAAI,qBAAU,KAAV,EAAJ;AACD;;AAPmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAH;;AAAA,wBAAb,aAAa;AAAA;AAAA;AAAA,SAAnB;;AAUA,WAAK,SAAL,CAAe,EAAf,CAAkB,OAAlB,EAA2B,aAA3B;;AAEA,aAAO,YAAK;AACV,QAAA,MAAI,CAAC,SAAL,CAAe,GAAf,CAAmB,OAAnB,EAA4B,aAA5B;AACD,OAFD;AAGD;AAED;;;;WACU,sBACR,QADQ,EAER,WAFQ,EAE+C;;;AAEvD,aAAO;AACL,QAAA,QAAQ,EAAA,CAAA,EAAA,GAAE,WAAW,CAAC,QAAd,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,EAAtB,GAA0B,QAAQ,CAAC,QADtC;AAEL,QAAA,cAAc,EAAA,CAAA,EAAA,GAAE,WAAW,CAAC,cAAd,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,EAA5B,GAAgC,QAAQ,CAAC;AAFlD,OAAP;AAID;;;;EA3J0C,UAAA,CAAA,Y;;AAA7C,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockPolledLiquityStore = void 0;\nconst constants_1 = require(\"@ethersproject/constants\");\nconst lib_base_1 = require(\"@liquity/lib-base\");\nconst EthersLiquityConnection_1 = require(\"./EthersLiquityConnection\");\nconst promiseAllValues = (object) => {\n    const keys = Object.keys(object);\n    return Promise.all(Object.values(object)).then(values => Object.fromEntries(values.map((value, i) => [keys[i], value])));\n};\nconst decimalify = (bigNumber) => lib_base_1.Decimal.fromBigNumberString(bigNumber.toHexString());\n/**\n * Ethers-based {@link @liquity/lib-base#LiquityStore} that updates state whenever there's a new\n * block.\n *\n * @public\n */\nclass BlockPolledLiquityStore extends lib_base_1.LiquityStore {\n    constructor(readable) {\n        super();\n        this.connection = readable.connection;\n        this._readable = readable;\n        this._provider = EthersLiquityConnection_1._getProvider(readable.connection);\n    }\n    async _getRiskiestTroveBeforeRedistribution(overrides) {\n        const riskiestTroves = await this._readable.getTroves({ first: 1, sortedBy: \"ascendingCollateralRatio\", beforeRedistribution: true }, overrides);\n        if (riskiestTroves.length === 0) {\n            return new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\");\n        }\n        return riskiestTroves[0];\n    }\n    async _get(blockTag) {\n        const { userAddress, frontendTag } = this.connection;\n        const { blockTimestamp, createFees, calculateRemainingLQTY, ...baseState } = await promiseAllValues({\n            blockTimestamp: EthersLiquityConnection_1._getBlockTimestamp(this.connection, blockTag),\n            createFees: this._readable._getFeesFactory({ blockTag }),\n            calculateRemainingLQTY: this._readable._getRemainingLiquidityMiningLQTYRewardCalculator({\n                blockTag\n            }),\n            price: this._readable.getPrice({ blockTag }),\n            numberOfTroves: this._readable.getNumberOfTroves({ blockTag }),\n            totalRedistributed: this._readable.getTotalRedistributed({ blockTag }),\n            total: this._readable.getTotal({ blockTag }),\n            lusdInStabilityPool: this._readable.getLUSDInStabilityPool({ blockTag }),\n            totalStakedLQTY: this._readable.getTotalStakedLQTY({ blockTag }),\n            _riskiestTroveBeforeRedistribution: this._getRiskiestTroveBeforeRedistribution({ blockTag }),\n            totalStakedUniTokens: this._readable.getTotalStakedUniTokens({ blockTag }),\n            remainingStabilityPoolLQTYReward: this._readable.getRemainingStabilityPoolLQTYReward({\n                blockTag\n            }),\n            frontend: frontendTag\n                ? this._readable.getFrontendStatus(frontendTag, { blockTag })\n                : { status: \"unregistered\" },\n            ...(userAddress\n                ? {\n                    accountBalance: this._provider.getBalance(userAddress, blockTag).then(decimalify),\n                    lusdBalance: this._readable.getLUSDBalance(userAddress, { blockTag }),\n                    lqtyBalance: this._readable.getLQTYBalance(userAddress, { blockTag }),\n                    uniTokenBalance: this._readable.getUniTokenBalance(userAddress, { blockTag }),\n                    uniTokenAllowance: this._readable.getUniTokenAllowance(userAddress, { blockTag }),\n                    liquidityMiningStake: this._readable.getLiquidityMiningStake(userAddress, { blockTag }),\n                    liquidityMiningLQTYReward: this._readable.getLiquidityMiningLQTYReward(userAddress, {\n                        blockTag\n                    }),\n                    collateralSurplusBalance: this._readable.getCollateralSurplusBalance(userAddress, {\n                        blockTag\n                    }),\n                    troveBeforeRedistribution: this._readable.getTroveBeforeRedistribution(userAddress, {\n                        blockTag\n                    }),\n                    stabilityDeposit: this._readable.getStabilityDeposit(userAddress, { blockTag }),\n                    lqtyStake: this._readable.getLQTYStake(userAddress, { blockTag }),\n                    ownFrontend: this._readable.getFrontendStatus(userAddress, { blockTag })\n                }\n                : {\n                    accountBalance: lib_base_1.Decimal.ZERO,\n                    lusdBalance: lib_base_1.Decimal.ZERO,\n                    lqtyBalance: lib_base_1.Decimal.ZERO,\n                    uniTokenBalance: lib_base_1.Decimal.ZERO,\n                    uniTokenAllowance: lib_base_1.Decimal.ZERO,\n                    liquidityMiningStake: lib_base_1.Decimal.ZERO,\n                    liquidityMiningLQTYReward: lib_base_1.Decimal.ZERO,\n                    collateralSurplusBalance: lib_base_1.Decimal.ZERO,\n                    troveBeforeRedistribution: new lib_base_1.TroveWithPendingRedistribution(constants_1.AddressZero, \"nonExistent\"),\n                    stabilityDeposit: new lib_base_1.StabilityDeposit(lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, lib_base_1.Decimal.ZERO, constants_1.AddressZero),\n                    lqtyStake: new lib_base_1.LQTYStake(),\n                    ownFrontend: { status: \"unregistered\" }\n                })\n        });\n        return [\n            {\n                ...baseState,\n                _feesInNormalMode: createFees(blockTimestamp, false),\n                remainingLiquidityMiningLQTYReward: calculateRemainingLQTY(blockTimestamp)\n            },\n            {\n                blockTag,\n                blockTimestamp\n            }\n        ];\n    }\n    /** @internal @override */\n    _doStart() {\n        this._get().then(state => {\n            if (!this._loaded) {\n                this._load(...state);\n            }\n        });\n        const blockListener = async (blockTag) => {\n            const state = await this._get(blockTag);\n            if (this._loaded) {\n                this._update(...state);\n            }\n            else {\n                this._load(...state);\n            }\n        };\n        this._provider.on(\"block\", blockListener);\n        return () => {\n            this._provider.off(\"block\", blockListener);\n        };\n    }\n    /** @internal @override */\n    _reduceExtra(oldState, stateUpdate) {\n        var _a, _b;\n        return {\n            blockTag: (_a = stateUpdate.blockTag) !== null && _a !== void 0 ? _a : oldState.blockTag,\n            blockTimestamp: (_b = stateUpdate.blockTimestamp) !== null && _b !== void 0 ? _b : oldState.blockTimestamp\n        };\n    }\n}\nexports.BlockPolledLiquityStore = BlockPolledLiquityStore;\n//# sourceMappingURL=BlockPolledLiquityStore.js.map"]},"metadata":{},"sourceType":"script"}