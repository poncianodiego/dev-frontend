{"ast":null,"code":"import { hexlify } from \"@ethersproject/bytes\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport { Decimal } from \"@liquity/lib-base\";\nexport class DisposableWalletProvider {\n  constructor(url, funderPrivateKey, ethAmount = 100) {\n    this.url = void 0;\n    this.id = 0;\n    this.wallet = void 0;\n    this.funderWallet = void 0;\n    this.ethAmount = void 0;\n    this.haveFunded = false;\n    this.url = url;\n    this.wallet = Wallet.createRandom();\n    this.funderWallet = new Wallet(funderPrivateKey);\n    this.ethAmount = Decimal.from(ethAmount);\n  }\n\n  findWallet(address) {\n    const wallet = [this.wallet, this.funderWallet].find(wallet => wallet.address.toLowerCase() === address.toLowerCase());\n\n    if (!wallet) {\n      throw new Error(`Unknow account ${address}`);\n    }\n\n    return wallet;\n  }\n\n  async fund() {\n    return this.send(\"eth_sendTransaction\", [{\n      from: this.funderWallet.address,\n      to: this.wallet.address,\n      value: this.ethAmount.hex,\n      gas: hexlify(21000)\n    }]); // TODO maybe wait for tx to be mined (not a problem on devchains though)\n  }\n\n  async send(method, params) {\n    if (!this.haveFunded) {\n      this.haveFunded = true;\n      await this.fund();\n    }\n\n    switch (method) {\n      case \"eth_accounts\":\n      case \"eth_requestAccounts\":\n        return [this.wallet.address];\n\n      case \"eth_sendTransaction\":\n        return this.send(\"eth_sendRawTransaction\", await Promise.all(params.map(async ({\n          from,\n          nonce,\n          gas,\n          ...rest\n        }) => {\n          if (nonce === undefined) {\n            nonce = await this.send(\"eth_getTransactionCount\", [from]);\n          }\n\n          return this.findWallet(from).signTransaction({\n            from,\n            nonce,\n            ...(gas !== undefined ? {\n              gasLimit: gas\n            } : {}),\n            ...rest\n          });\n        })));\n    } //console.log({ method, params });\n\n\n    const response = await fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        method: method,\n        params: params,\n        id: this.id++,\n        jsonrpc: \"2.0\"\n      })\n    });\n    const json = await response.json(); //console.log(json);\n\n    if (json.error) {\n      const {\n        message,\n        ...rest\n      } = json.error;\n      const error = new Error(`${message} ${JSON.stringify(rest)}`);\n      throw Object.assign(error, rest);\n    }\n\n    return json.result;\n  }\n\n  request({\n    method,\n    params\n  }) {\n    return this.send(method, params);\n  }\n\n}","map":{"version":3,"sources":["/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/src/testUtils/DisposableWalletProvider.ts"],"names":["hexlify","Wallet","Decimal","DisposableWalletProvider","constructor","url","funderPrivateKey","ethAmount","id","wallet","funderWallet","haveFunded","createRandom","from","findWallet","address","find","toLowerCase","Error","fund","send","to","value","hex","gas","method","params","Promise","all","map","nonce","rest","undefined","signTransaction","gasLimit","response","fetch","headers","body","JSON","stringify","jsonrpc","json","error","message","Object","assign","result","request"],"mappings":"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","sourcesContent":["import { hexlify } from \"@ethersproject/bytes\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport { Decimal, Decimalish } from \"@liquity/lib-base\";\n\nexport class DisposableWalletProvider {\n  private readonly url: string;\n  private id: number = 0;\n\n  private readonly wallet: Wallet;\n  private readonly funderWallet: Wallet;\n\n  private readonly ethAmount: Decimal;\n  private haveFunded = false;\n\n  constructor(url: string, funderPrivateKey: string, ethAmount: Decimalish = 100) {\n    this.url = url;\n    this.wallet = Wallet.createRandom();\n    this.funderWallet = new Wallet(funderPrivateKey);\n    this.ethAmount = Decimal.from(ethAmount);\n  }\n\n  private findWallet(address: string) {\n    const wallet = [this.wallet, this.funderWallet].find(\n      wallet => wallet.address.toLowerCase() === address.toLowerCase()\n    );\n\n    if (!wallet) {\n      throw new Error(`Unknow account ${address}`);\n    }\n\n    return wallet;\n  }\n\n  private async fund() {\n    return this.send(\"eth_sendTransaction\", [\n      {\n        from: this.funderWallet.address,\n        to: this.wallet.address,\n        value: this.ethAmount.hex,\n        gas: hexlify(21000)\n      }\n    ]);\n\n    // TODO maybe wait for tx to be mined (not a problem on devchains though)\n  }\n\n  async send(method: string, params: any[]): Promise<any> {\n    if (!this.haveFunded) {\n      this.haveFunded = true;\n      await this.fund();\n    }\n\n    switch (method) {\n      case \"eth_accounts\":\n      case \"eth_requestAccounts\":\n        return [this.wallet.address];\n\n      case \"eth_sendTransaction\":\n        return this.send(\n          \"eth_sendRawTransaction\",\n          await Promise.all(\n            params.map(async ({ from, nonce, gas, ...rest }) => {\n              if (nonce === undefined) {\n                nonce = await this.send(\"eth_getTransactionCount\", [from]);\n              }\n\n              return this.findWallet(from).signTransaction({\n                from,\n                nonce,\n                ...(gas !== undefined ? { gasLimit: gas } : {}),\n                ...rest\n              });\n            })\n          )\n        );\n    }\n\n    //console.log({ method, params });\n\n    const response = await fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        method: method,\n        params: params,\n        id: this.id++,\n        jsonrpc: \"2.0\"\n      })\n    });\n\n    const json = await response.json();\n\n    //console.log(json);\n\n    if (json.error) {\n      const { message, ...rest } = json.error;\n      const error = new Error(`${message} ${JSON.stringify(rest)}`);\n      throw Object.assign(error, rest);\n    }\n\n    return json.result;\n  }\n\n  request({ method, params }: { method: string; params: any[] }) {\n    return this.send(method, params);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}