{"ast":null,"code":"import _regeneratorRuntime from\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from\"react\";import{useWeb3React}from\"@web3-react/core\";import{injectedConnector}from\"../connectors/injectedConnector\";/**\n * React hook that tries to activate the InjectedConnector if the app's already authorized in the\n * browser's wallet (in the case of dApp-enabled browsers) or its wallet extension (e.g. MetaMask).\n *\n * Example: user has a browser with the MetaMask extension. MetaMask injects an Ethereum provider\n * into the window object. We check via InjectedConnector if our app is already authorized to use\n * the wallet through this provider, and in that case we try to activate the connector.\n *\n * @returns true when finished trying to activate the InjectedConnector, false otherwise\n */export function useAuthorizedConnection(){var _useWeb3React=useWeb3React(),activate=_useWeb3React.activate,active=_useWeb3React.active;var _useState=useState(false),_useState2=_slicedToArray(_useState,2),tried=_useState2[0],setTried=_useState2[1];useEffect(function(){var tryToActivateIfAuthorized=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return injectedConnector.isAuthorized();case 3:if(!_context.sent){_context.next=8;break;}_context.next=6;return activate(injectedConnector,undefined,true);case 6:_context.next=9;break;case 8:throw new Error(\"Unauthorized\");case 9:_context.next=14;break;case 11:_context.prev=11;_context.t0=_context[\"catch\"](0);setTried(true);case 14:case\"end\":return _context.stop();}}},_callee,null,[[0,11]]);}));return function tryToActivateIfAuthorized(){return _ref.apply(this,arguments);};}();tryToActivateIfAuthorized();},[activate]);useEffect(function(){if(active){setTried(true);}},[active]);return tried;}","map":{"version":3,"sources":["/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/src/hooks/useAuthorizedConnection.ts"],"names":["useState","useEffect","useWeb3React","injectedConnector","useAuthorizedConnection","activate","active","tried","setTried","tryToActivateIfAuthorized","isAuthorized","undefined","Error"],"mappings":"0jBAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CACA,OAASC,YAAT,KAA6B,kBAA7B,CAEA,OAASC,iBAAT,KAAkC,iCAAlC,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAEA,MAAO,SAASC,CAAAA,uBAAT,EAA4C,mBACpBF,YAAY,EADQ,CACzCG,QADyC,eACzCA,QADyC,CAC/BC,MAD+B,eAC/BA,MAD+B,eAEvBN,QAAQ,CAAC,KAAD,CAFe,wCAE1CO,KAF0C,eAEnCC,QAFmC,eAIjDP,SAAS,CAAC,UAAM,CACd,GAAMQ,CAAAA,yBAAyB,0FAAG,yKAEpBN,CAAAA,iBAAiB,CAACO,YAAlB,EAFoB,wEAGtBL,CAAAA,QAAQ,CAACF,iBAAD,CAAoBQ,SAApB,CAA+B,IAA/B,CAHc,0CAKtB,IAAIC,CAAAA,KAAJ,CAAU,cAAV,CALsB,yFAQ9BJ,QAAQ,CAAC,IAAD,CAAR,CAR8B,qEAAH,kBAAzBC,CAAAA,yBAAyB,0CAA/B,CAWAA,yBAAyB,GAC1B,CAbQ,CAaN,CAACJ,QAAD,CAbM,CAAT,CAeAJ,SAAS,CAAC,UAAM,CACd,GAAIK,MAAJ,CAAY,CACVE,QAAQ,CAAC,IAAD,CAAR,CACD,CACF,CAJQ,CAIN,CAACF,MAAD,CAJM,CAAT,CAMA,MAAOC,CAAAA,KAAP,CACD","sourcesContent":["import { useState, useEffect } from \"react\";\nimport { useWeb3React } from \"@web3-react/core\";\n\nimport { injectedConnector } from \"../connectors/injectedConnector\";\n\n/**\n * React hook that tries to activate the InjectedConnector if the app's already authorized in the\n * browser's wallet (in the case of dApp-enabled browsers) or its wallet extension (e.g. MetaMask).\n *\n * Example: user has a browser with the MetaMask extension. MetaMask injects an Ethereum provider\n * into the window object. We check via InjectedConnector if our app is already authorized to use\n * the wallet through this provider, and in that case we try to activate the connector.\n *\n * @returns true when finished trying to activate the InjectedConnector, false otherwise\n */\n\nexport function useAuthorizedConnection(): boolean {\n  const { activate, active } = useWeb3React<unknown>();\n  const [tried, setTried] = useState(false);\n\n  useEffect(() => {\n    const tryToActivateIfAuthorized = async () => {\n      try {\n        if (await injectedConnector.isAuthorized()) {\n          await activate(injectedConnector, undefined, true);\n        } else {\n          throw new Error(\"Unauthorized\");\n        }\n      } catch {\n        setTried(true);\n      }\n    };\n    tryToActivateIfAuthorized();\n  }, [activate]);\n\n  useEffect(() => {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n\n  return tried;\n}\n"]},"metadata":{},"sourceType":"module"}