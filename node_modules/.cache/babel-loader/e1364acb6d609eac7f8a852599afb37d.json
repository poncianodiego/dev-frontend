{"ast":null,"code":"var _jsxFileName = \"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/src/hooks/LiquityContext.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { createContext, useContext, useEffect, useMemo, useState } from \"react\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport { isBatchedProvider, isWebSocketAugmentedProvider } from \"@liquity/providers\";\nimport { EthersLiquity, _connectByChainId } from \"@liquity/lib-ethers\";\nimport { getConfig } from \"../config\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LiquityContext = /*#__PURE__*/createContext(undefined);\n\nconst wsParams = (network, infuraApiKey) => [`wss://${network === \"homestead\" ? \"mainnet\" : network}.infura.io/ws/v3/${infuraApiKey}`, network];\n\nconst supportedNetworks = [\"homestead\", \"kovan\", \"rinkeby\", \"ropsten\", \"goerli\"];\nexport const LiquityProvider = ({\n  children,\n  loader,\n  unsupportedNetworkFallback,\n  unsupportedMainnetFallback\n}) => {\n  _s();\n\n  const {\n    library: provider,\n    account,\n    chainId\n  } = useWeb3React();\n  const [config, setConfig] = useState();\n  const connection = useMemo(() => {\n    if (config && provider && account && chainId) {\n      try {\n        return _connectByChainId(provider, provider.getSigner(account), chainId, {\n          userAddress: account,\n          frontendTag: config.frontendTag,\n          useStore: \"blockPolled\"\n        });\n      } catch {}\n    }\n  }, [config, provider, account, chainId]);\n  useEffect(() => {\n    getConfig().then(setConfig);\n  }, []);\n  useEffect(() => {\n    if (config && connection) {\n      const {\n        provider,\n        chainId\n      } = connection;\n\n      if (isBatchedProvider(provider) && provider.chainId !== chainId) {\n        provider.chainId = chainId;\n      }\n\n      if (isWebSocketAugmentedProvider(provider)) {\n        const network = getNetwork(chainId);\n\n        if (network.name && supportedNetworks.includes(network.name) && config.infuraApiKey) {\n          provider.openWebSocket(...wsParams(network.name, config.infuraApiKey));\n        } else if (connection._isDev) {\n          provider.openWebSocket(`ws://${window.location.hostname}:8546`, chainId);\n        }\n\n        return () => {\n          provider.closeWebSocket();\n        };\n      }\n    }\n  }, [config, connection]);\n\n  if (!config || !provider || !account || !chainId) {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: loader\n    }, void 0, false);\n  }\n\n  if (config.testnetOnly && chainId === 1) {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: unsupportedMainnetFallback\n    }, void 0, false);\n  }\n\n  if (!connection) {\n    return unsupportedNetworkFallback ? /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: unsupportedNetworkFallback(chainId)\n    }, void 0, false) : null;\n  }\n\n  const liquity = EthersLiquity._from(connection);\n\n  liquity.store.logging = true;\n  return /*#__PURE__*/_jsxDEV(LiquityContext.Provider, {\n    value: {\n      config,\n      account,\n      provider,\n      liquity\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 104,\n    columnNumber: 5\n  }, this);\n};\n\n_s(LiquityProvider, \"WuurErUsitnXP5cLJy/NUC2L3VE=\", false, function () {\n  return [useWeb3React];\n});\n\n_c = LiquityProvider;\nexport const useLiquity = () => {\n  _s2();\n\n  const liquityContext = useContext(LiquityContext);\n\n  if (!liquityContext) {\n    throw new Error(\"You must provide a LiquityContext via LiquityProvider\");\n  }\n\n  return liquityContext;\n};\n\n_s2(useLiquity, \"FRJ+YuzNYJyLcq5WyDZpKnKL0Bo=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"LiquityProvider\");","map":{"version":3,"sources":["/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/src/hooks/LiquityContext.tsx"],"names":["React","createContext","useContext","useEffect","useMemo","useState","getNetwork","useWeb3React","isBatchedProvider","isWebSocketAugmentedProvider","EthersLiquity","_connectByChainId","getConfig","LiquityContext","undefined","wsParams","network","infuraApiKey","supportedNetworks","LiquityProvider","children","loader","unsupportedNetworkFallback","unsupportedMainnetFallback","library","provider","account","chainId","config","setConfig","connection","getSigner","userAddress","frontendTag","useStore","then","name","includes","openWebSocket","_isDev","window","location","hostname","closeWebSocket","testnetOnly","liquity","_from","store","logging","useLiquity","liquityContext","Error"],"mappings":"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","sourcesContent":["import React, { createContext, useContext, useEffect, useMemo, useState } from \"react\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { useWeb3React } from \"@web3-react/core\";\n\nimport { isBatchedProvider, isWebSocketAugmentedProvider } from \"@liquity/providers\";\nimport {\n  BlockPolledLiquityStore,\n  EthersLiquity,\n  EthersLiquityWithStore,\n  _connectByChainId\n} from \"@liquity/lib-ethers\";\n\nimport { LiquityFrontendConfig, getConfig } from \"../config\";\n\ntype LiquityContextValue = {\n  config: LiquityFrontendConfig;\n  account: string;\n  provider: Provider;\n  liquity: EthersLiquityWithStore<BlockPolledLiquityStore>;\n};\n\nconst LiquityContext = createContext<LiquityContextValue | undefined>(undefined);\n\ntype LiquityProviderProps = {\n  loader?: React.ReactNode;\n  unsupportedNetworkFallback?: (chainId: number) => React.ReactNode;\n  unsupportedMainnetFallback?: React.ReactNode;\n};\n\nconst wsParams = (network: string, infuraApiKey: string): [string, string] => [\n  `wss://${network === \"homestead\" ? \"mainnet\" : network}.infura.io/ws/v3/${infuraApiKey}`,\n  network\n];\n\nconst supportedNetworks = [\"homestead\", \"kovan\", \"rinkeby\", \"ropsten\", \"goerli\"];\n\nexport const LiquityProvider: React.FC<LiquityProviderProps> = ({\n  children,\n  loader,\n  unsupportedNetworkFallback,\n  unsupportedMainnetFallback\n}) => {\n  const { library: provider, account, chainId } = useWeb3React<Web3Provider>();\n  const [config, setConfig] = useState<LiquityFrontendConfig>();\n\n  const connection = useMemo(() => {\n    if (config && provider && account && chainId) {\n      try {\n        return _connectByChainId(provider, provider.getSigner(account), chainId, {\n          userAddress: account,\n          frontendTag: config.frontendTag,\n          useStore: \"blockPolled\"\n        });\n      } catch {}\n    }\n  }, [config, provider, account, chainId]);\n\n  useEffect(() => {\n    getConfig().then(setConfig);\n  }, []);\n\n  useEffect(() => {\n    if (config && connection) {\n      const { provider, chainId } = connection;\n\n      if (isBatchedProvider(provider) && provider.chainId !== chainId) {\n        provider.chainId = chainId;\n      }\n\n      if (isWebSocketAugmentedProvider(provider)) {\n        const network = getNetwork(chainId);\n\n        if (network.name && supportedNetworks.includes(network.name) && config.infuraApiKey) {\n          provider.openWebSocket(...wsParams(network.name, config.infuraApiKey));\n        } else if (connection._isDev) {\n          provider.openWebSocket(`ws://${window.location.hostname}:8546`, chainId);\n        }\n\n        return () => {\n          provider.closeWebSocket();\n        };\n      }\n    }\n  }, [config, connection]);\n\n  if (!config || !provider || !account || !chainId) {\n    return <>{loader}</>;\n  }\n\n  if (config.testnetOnly && chainId === 1) {\n    return <>{unsupportedMainnetFallback}</>;\n  }\n\n  if (!connection) {\n    return unsupportedNetworkFallback ? <>{unsupportedNetworkFallback(chainId)}</> : null;\n  }\n\n  const liquity = EthersLiquity._from(connection);\n  liquity.store.logging = true;\n\n  return (\n    <LiquityContext.Provider value={{ config, account, provider, liquity }}>\n      {children}\n    </LiquityContext.Provider>\n  );\n};\n\nexport const useLiquity = () => {\n  const liquityContext = useContext(LiquityContext);\n\n  if (!liquityContext) {\n    throw new Error(\"You must provide a LiquityContext via LiquityProvider\");\n  }\n\n  return liquityContext;\n};\n"]},"metadata":{},"sourceType":"module"}