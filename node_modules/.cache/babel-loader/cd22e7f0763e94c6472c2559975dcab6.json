{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _objectSpread = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"/Users/diegoponciano/Desktop/ryan/liquity/frontend/packages/dev-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TroveWithPendingRedistribution = exports.UserTrove = exports._emptyTrove = exports.Trove = exports._normalizeTroveAdjustment = exports._normalizeTroveCreation = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar Decimal_1 = require(\"./Decimal\");\n\nvar constants_1 = require(\"./constants\");\n\nvar invalidTroveCreation = function invalidTroveCreation(invalidTrove, error) {\n  return {\n    type: \"invalidCreation\",\n    invalidTrove: invalidTrove,\n    error: error\n  };\n};\n\nvar troveCreation = function troveCreation(params) {\n  return {\n    type: \"creation\",\n    params: params\n  };\n};\n\nvar troveClosure = function troveClosure(params) {\n  return {\n    type: \"closure\",\n    params: params\n  };\n};\n\nvar troveAdjustment = function troveAdjustment(params, setToZero) {\n  return {\n    type: \"adjustment\",\n    params: params,\n    setToZero: setToZero\n  };\n};\n\nvar valueIsDefined = function valueIsDefined(entry) {\n  return entry[1] !== undefined;\n};\n\nvar allowedTroveCreationKeys = [\"depositCollateral\", \"borrowLUSD\"];\n\nfunction checkAllowedTroveCreationKeys(entries) {\n  var badKeys = entries.filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n        k = _ref2[0];\n\n    return !allowedTroveCreationKeys.includes(k);\n  }).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        k = _ref4[0];\n\n    return \"'\".concat(k, \"'\");\n  });\n\n  if (badKeys.length > 0) {\n    throw new Error(\"TroveCreationParams: property \".concat(badKeys.join(\", \"), \" not allowed\"));\n  }\n}\n\nvar troveCreationParamsFromEntries = function troveCreationParamsFromEntries(entries) {\n  var params = Object.fromEntries(entries);\n  var missingKeys = allowedTroveCreationKeys.filter(function (k) {\n    return !(k in params);\n  }).map(function (k) {\n    return \"'\".concat(k, \"'\");\n  });\n\n  if (missingKeys.length > 0) {\n    throw new Error(\"TroveCreationParams: property \".concat(missingKeys.join(\", \"), \" missing\"));\n  }\n\n  return params;\n};\n\nvar decimalize = function decimalize(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      k = _ref6[0],\n      v = _ref6[1];\n\n  return [k, Decimal_1.Decimal.from(v)];\n};\n\nvar nonZero = function nonZero(_ref7) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      v = _ref8[1];\n\n  return !v.isZero;\n};\n/** @internal */\n\n\nvar _normalizeTroveCreation = function _normalizeTroveCreation(params) {\n  var definedEntries = Object.entries(params).filter(valueIsDefined);\n  checkAllowedTroveCreationKeys(definedEntries);\n  var nonZeroEntries = definedEntries.map(decimalize);\n  return troveCreationParamsFromEntries(nonZeroEntries);\n};\n\nexports._normalizeTroveCreation = _normalizeTroveCreation;\nvar allowedTroveAdjustmentKeys = [\"depositCollateral\", \"withdrawCollateral\", \"borrowLUSD\", \"repayLUSD\"];\n\nfunction checkAllowedTroveAdjustmentKeys(entries) {\n  var badKeys = entries.filter(function (_ref9) {\n    var _ref10 = _slicedToArray(_ref9, 1),\n        k = _ref10[0];\n\n    return !allowedTroveAdjustmentKeys.includes(k);\n  }).map(function (_ref11) {\n    var _ref12 = _slicedToArray(_ref11, 1),\n        k = _ref12[0];\n\n    return \"'\".concat(k, \"'\");\n  });\n\n  if (badKeys.length > 0) {\n    throw new Error(\"TroveAdjustmentParams: property \".concat(badKeys.join(\", \"), \" not allowed\"));\n  }\n}\n\nvar collateralChangeFrom = function collateralChangeFrom(_ref13) {\n  var depositCollateral = _ref13.depositCollateral,\n      withdrawCollateral = _ref13.withdrawCollateral;\n\n  if (depositCollateral !== undefined && withdrawCollateral !== undefined) {\n    throw new Error(\"TroveAdjustmentParams: 'depositCollateral' and 'withdrawCollateral' \" + \"can't be present at the same time\");\n  }\n\n  if (depositCollateral !== undefined) {\n    return {\n      depositCollateral: depositCollateral\n    };\n  }\n\n  if (withdrawCollateral !== undefined) {\n    return {\n      withdrawCollateral: withdrawCollateral\n    };\n  }\n};\n\nvar debtChangeFrom = function debtChangeFrom(_ref14) {\n  var borrowLUSD = _ref14.borrowLUSD,\n      repayLUSD = _ref14.repayLUSD;\n\n  if (borrowLUSD !== undefined && repayLUSD !== undefined) {\n    throw new Error(\"TroveAdjustmentParams: 'borrowLUSD' and 'repayLUSD' can't be present at the same time\");\n  }\n\n  if (borrowLUSD !== undefined) {\n    return {\n      borrowLUSD: borrowLUSD\n    };\n  }\n\n  if (repayLUSD !== undefined) {\n    return {\n      repayLUSD: repayLUSD\n    };\n  }\n};\n\nvar troveAdjustmentParamsFromEntries = function troveAdjustmentParamsFromEntries(entries) {\n  var params = Object.fromEntries(entries);\n  var collateralChange = collateralChangeFrom(params);\n  var debtChange = debtChangeFrom(params);\n\n  if (collateralChange !== undefined && debtChange !== undefined) {\n    return _objectSpread(_objectSpread({}, collateralChange), debtChange);\n  }\n\n  if (collateralChange !== undefined) {\n    return collateralChange;\n  }\n\n  if (debtChange !== undefined) {\n    return debtChange;\n  }\n\n  throw new Error(\"TroveAdjustmentParams: must include at least one non-zero parameter\");\n};\n/** @internal */\n\n\nvar _normalizeTroveAdjustment = function _normalizeTroveAdjustment(params) {\n  var definedEntries = Object.entries(params).filter(valueIsDefined);\n  checkAllowedTroveAdjustmentKeys(definedEntries);\n  var nonZeroEntries = definedEntries.map(decimalize).filter(nonZero);\n  return troveAdjustmentParamsFromEntries(nonZeroEntries);\n};\n\nexports._normalizeTroveAdjustment = _normalizeTroveAdjustment;\n\nvar applyFee = function applyFee(borrowingRate, debtIncrease) {\n  return debtIncrease.mul(Decimal_1.Decimal.ONE.add(borrowingRate));\n};\n\nvar unapplyFee = function unapplyFee(borrowingRate, debtIncrease) {\n  return debtIncrease._divCeil(Decimal_1.Decimal.ONE.add(borrowingRate));\n};\n\nvar NOMINAL_COLLATERAL_RATIO_PRECISION = Decimal_1.Decimal.from(100);\n/**\n * A combination of collateral and debt.\n *\n * @public\n */\n\nvar Trove = /*#__PURE__*/function () {\n  /** @internal */\n  function Trove() {\n    var collateral = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Decimal_1.Decimal.ZERO;\n    var debt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Decimal_1.Decimal.ZERO;\n\n    _classCallCheck(this, Trove);\n\n    this.collateral = collateral;\n    this.debt = debt;\n  }\n\n  _createClass(Trove, [{\n    key: \"isEmpty\",\n    get: function get() {\n      return this.collateral.isZero && this.debt.isZero;\n    }\n    /**\n     * Amount of LUSD that must be repaid to close this Trove.\n     *\n     * @remarks\n     * This doesn't include the liquidation reserve, which is refunded in case of normal closure.\n     */\n\n  }, {\n    key: \"netDebt\",\n    get: function get() {\n      if (this.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n        throw new Error(\"netDebt should not be used when debt < \".concat(constants_1.LUSD_LIQUIDATION_RESERVE));\n      }\n\n      return this.debt.sub(constants_1.LUSD_LIQUIDATION_RESERVE);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_nominalCollateralRatio\",\n    get: function get() {\n      return this.collateral.mulDiv(NOMINAL_COLLATERAL_RATIO_PRECISION, this.debt);\n    }\n    /** Calculate the Trove's collateralization ratio at a given price. */\n\n  }, {\n    key: \"collateralRatio\",\n    value: function collateralRatio(price) {\n      return this.collateral.mulDiv(price, this.debt);\n    }\n    /**\n     * Whether the Trove is undercollateralized at a given price.\n     *\n     * @returns\n     * `true` if the Trove's collateralization ratio is less than the\n     * {@link MINIMUM_COLLATERAL_RATIO}.\n     */\n\n  }, {\n    key: \"collateralRatioIsBelowMinimum\",\n    value: function collateralRatioIsBelowMinimum(price) {\n      return this.collateralRatio(price).lt(constants_1.MINIMUM_COLLATERAL_RATIO);\n    }\n    /**\n     * Whether the collateralization ratio is less than the {@link CRITICAL_COLLATERAL_RATIO} at a\n     * given price.\n     *\n     * @example\n     * Can be used to check whether the Liquity protocol is in recovery mode by using it on the return\n     * value of {@link ReadableLiquity.getTotal | getTotal()}. For example:\n     *\n     * ```typescript\n     * const total = await liquity.getTotal();\n     * const price = await liquity.getPrice();\n     *\n     * if (total.collateralRatioIsBelowCritical(price)) {\n     *   // Recovery mode is active\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"collateralRatioIsBelowCritical\",\n    value: function collateralRatioIsBelowCritical(price) {\n      return this.collateralRatio(price).lt(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** Whether the Trove is sufficiently collateralized to be opened during recovery mode. */\n\n  }, {\n    key: \"isOpenableInRecoveryMode\",\n    value: function isOpenableInRecoveryMode(price) {\n      return this.collateralRatio(price).gte(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** @internal */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"{ collateral: \".concat(this.collateral, \", debt: \").concat(this.debt, \" }\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(that) {\n      return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);\n    }\n  }, {\n    key: \"add\",\n    value: function add(that) {\n      return new Trove(this.collateral.add(that.collateral), this.debt.add(that.debt));\n    }\n  }, {\n    key: \"addCollateral\",\n    value: function addCollateral(collateral) {\n      return new Trove(this.collateral.add(collateral), this.debt);\n    }\n  }, {\n    key: \"addDebt\",\n    value: function addDebt(debt) {\n      return new Trove(this.collateral, this.debt.add(debt));\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(that) {\n      var collateral = that.collateral,\n          debt = that.debt;\n      return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n  }, {\n    key: \"subtractCollateral\",\n    value: function subtractCollateral(collateral) {\n      return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt);\n    }\n  }, {\n    key: \"subtractDebt\",\n    value: function subtractDebt(debt) {\n      return new Trove(this.collateral, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(multiplier) {\n      return new Trove(this.collateral.mul(multiplier), this.debt.mul(multiplier));\n    }\n  }, {\n    key: \"setCollateral\",\n    value: function setCollateral(collateral) {\n      return new Trove(Decimal_1.Decimal.from(collateral), this.debt);\n    }\n  }, {\n    key: \"setDebt\",\n    value: function setDebt(debt) {\n      return new Trove(this.collateral, Decimal_1.Decimal.from(debt));\n    }\n  }, {\n    key: \"_debtChange\",\n    value: function _debtChange(_ref15, borrowingRate) {\n      var debt = _ref15.debt;\n      return debt.gt(this.debt) ? {\n        borrowLUSD: unapplyFee(borrowingRate, debt.sub(this.debt))\n      } : {\n        repayLUSD: this.debt.sub(debt)\n      };\n    }\n  }, {\n    key: \"_collateralChange\",\n    value: function _collateralChange(_ref16) {\n      var collateral = _ref16.collateral;\n      return collateral.gt(this.collateral) ? {\n        depositCollateral: collateral.sub(this.collateral)\n      } : {\n        withdrawCollateral: this.collateral.sub(collateral)\n      };\n    }\n    /**\n     * Calculate the difference between this Trove and another.\n     *\n     * @param that - The other Trove.\n     * @param borrowingRate - Borrowing rate to use when calculating a borrowed amount.\n     *\n     * @returns\n     * An object representing the change, or `undefined` if the Troves are equal.\n     */\n\n  }, {\n    key: \"whatChanged\",\n    value: function whatChanged(that) {\n      var borrowingRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.MINIMUM_BORROWING_RATE;\n\n      var _a;\n\n      if (this.collateral.eq(that.collateral) && this.debt.eq(that.debt)) {\n        return undefined;\n      }\n\n      if (this.isEmpty) {\n        if (that.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n          return invalidTroveCreation(that, \"missingLiquidationReserve\");\n        }\n\n        return troveCreation({\n          depositCollateral: that.collateral,\n          borrowLUSD: unapplyFee(borrowingRate, that.netDebt)\n        });\n      }\n\n      if (that.isEmpty) {\n        return troveClosure(this.netDebt.nonZero ? {\n          withdrawCollateral: this.collateral,\n          repayLUSD: this.netDebt\n        } : {\n          withdrawCollateral: this.collateral\n        });\n      }\n\n      return this.collateral.eq(that.collateral) ? troveAdjustment(this._debtChange(that, borrowingRate), that.debt.zero && \"debt\") : this.debt.eq(that.debt) ? troveAdjustment(this._collateralChange(that), that.collateral.zero && \"collateral\") : troveAdjustment(_objectSpread(_objectSpread({}, this._debtChange(that, borrowingRate)), this._collateralChange(that)), (_a = that.debt.zero && \"debt\") !== null && _a !== void 0 ? _a : that.collateral.zero && \"collateral\");\n    }\n    /**\n     * Make a new Trove by applying a {@link TroveChange} to this Trove.\n     *\n     * @param change - The change to apply.\n     * @param borrowingRate - Borrowing rate to use when adding a borrowed amount to the Trove's debt.\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(change) {\n      var borrowingRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.MINIMUM_BORROWING_RATE;\n\n      if (!change) {\n        return this;\n      }\n\n      switch (change.type) {\n        case \"invalidCreation\":\n          if (!this.isEmpty) {\n            throw new Error(\"Can't create onto existing Trove\");\n          }\n\n          return change.invalidTrove;\n\n        case \"creation\":\n          {\n            if (!this.isEmpty) {\n              throw new Error(\"Can't create onto existing Trove\");\n            }\n\n            var _change$params = change.params,\n                depositCollateral = _change$params.depositCollateral,\n                borrowLUSD = _change$params.borrowLUSD;\n            return new Trove(depositCollateral, constants_1.LUSD_LIQUIDATION_RESERVE.add(applyFee(borrowingRate, borrowLUSD)));\n          }\n\n        case \"closure\":\n          if (this.isEmpty) {\n            throw new Error(\"Can't close empty Trove\");\n          }\n\n          return exports._emptyTrove;\n\n        case \"adjustment\":\n          {\n            var setToZero = change.setToZero,\n                _change$params2 = change.params,\n                _depositCollateral = _change$params2.depositCollateral,\n                withdrawCollateral = _change$params2.withdrawCollateral,\n                _borrowLUSD = _change$params2.borrowLUSD,\n                repayLUSD = _change$params2.repayLUSD;\n            var collateralDecrease = withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : Decimal_1.Decimal.ZERO;\n            var collateralIncrease = _depositCollateral !== null && _depositCollateral !== void 0 ? _depositCollateral : Decimal_1.Decimal.ZERO;\n            var debtDecrease = repayLUSD !== null && repayLUSD !== void 0 ? repayLUSD : Decimal_1.Decimal.ZERO;\n            var debtIncrease = _borrowLUSD ? applyFee(borrowingRate, _borrowLUSD) : Decimal_1.Decimal.ZERO;\n            return setToZero === \"collateral\" ? this.setCollateral(Decimal_1.Decimal.ZERO).addDebt(debtIncrease).subtractDebt(debtDecrease) : setToZero === \"debt\" ? this.setDebt(Decimal_1.Decimal.ZERO).addCollateral(collateralIncrease).subtractCollateral(collateralDecrease) : this.add(new Trove(collateralIncrease, debtIncrease)).subtract(new Trove(collateralDecrease, debtDecrease));\n          }\n      }\n    }\n    /**\n     * Calculate the result of an {@link TransactableLiquity.openTrove | openTrove()} transaction.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when calculating the Trove's debt.\n     */\n\n  }, {\n    key: \"adjust\",\n    value:\n    /**\n     * Calculate the result of an {@link TransactableLiquity.adjustTrove | adjustTrove()} transaction\n     * on this Trove.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when adding to the Trove's debt.\n     */\n    function adjust(params, borrowingRate) {\n      return this.apply(troveAdjustment(exports._normalizeTroveAdjustment(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.adjustTrove | adjustTrove()}\n     * transaction that will change this Trove into the given Trove.\n     *\n     * @param that - The desired result of the transaction.\n     * @param borrowingRate - Current borrowing rate.\n     */\n\n  }, {\n    key: \"adjustTo\",\n    value: function adjustTo(that, borrowingRate) {\n      var change = this.whatChanged(that, borrowingRate);\n      assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"adjustment\");\n      return change.params;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(params, borrowingRate) {\n      return exports._emptyTrove.apply(troveCreation(exports._normalizeTroveCreation(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.openTrove | openTrove()} transaction\n     * that will result in the given Trove.\n     *\n     * @param that - The Trove to recreate.\n     * @param borrowingRate - Current borrowing rate.\n     */\n\n  }, {\n    key: \"recreate\",\n    value: function recreate(that, borrowingRate) {\n      var change = exports._emptyTrove.whatChanged(that, borrowingRate);\n\n      assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"creation\");\n      return change.params;\n    }\n  }]);\n\n  return Trove;\n}();\n\nexports.Trove = Trove;\n/** @internal */\n\nexports._emptyTrove = new Trove();\n/**\n * A Trove that is associated with a single owner.\n *\n * @remarks\n * The SDK uses the base {@link Trove} class as a generic container of collateral and debt, for\n * example to represent the {@link ReadableLiquity.getTotal | total collateral and debt} locked up\n * in the protocol.\n *\n * The `UserTrove` class extends `Trove` with extra information that's only available for Troves\n * that are associated with a single owner (such as the owner's address, or the Trove's status).\n *\n * @public\n */\n\nvar UserTrove = /*#__PURE__*/function (_Trove) {\n  _inherits(UserTrove, _Trove);\n\n  var _super = _createSuper(UserTrove);\n\n  /** @internal */\n  function UserTrove(ownerAddress, status, collateral, debt) {\n    var _this;\n\n    _classCallCheck(this, UserTrove);\n\n    _this = _super.call(this, collateral, debt);\n    _this.ownerAddress = ownerAddress;\n    _this.status = status;\n    return _this;\n  }\n\n  _createClass(UserTrove, [{\n    key: \"equals\",\n    value: function equals(that) {\n      return _get(_getPrototypeOf(UserTrove.prototype), \"equals\", this).call(this, that) && this.ownerAddress === that.ownerAddress && this.status === that.status;\n    }\n    /** @internal */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"{ ownerAddress: \\\"\".concat(this.ownerAddress, \"\\\"\") + \", collateral: \".concat(this.collateral) + \", debt: \".concat(this.debt) + \", status: \\\"\".concat(this.status, \"\\\" }\");\n    }\n  }]);\n\n  return UserTrove;\n}(Trove);\n\nexports.UserTrove = UserTrove;\n/**\n * A Trove in its state after the last direct modification.\n *\n * @remarks\n * The Trove may have received collateral and debt shares from liquidations since then.\n * Use {@link TroveWithPendingRedistribution.applyRedistribution | applyRedistribution()} to\n * calculate the Trove's most up-to-date state.\n *\n * @public\n */\n\nvar TroveWithPendingRedistribution = /*#__PURE__*/function (_UserTrove) {\n  _inherits(TroveWithPendingRedistribution, _UserTrove);\n\n  var _super2 = _createSuper(TroveWithPendingRedistribution);\n\n  /** @internal */\n  function TroveWithPendingRedistribution(ownerAddress, status, collateral, debt) {\n    var _this2;\n\n    var stake = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Decimal_1.Decimal.ZERO;\n    var snapshotOfTotalRedistributed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : exports._emptyTrove;\n\n    _classCallCheck(this, TroveWithPendingRedistribution);\n\n    _this2 = _super2.call(this, ownerAddress, status, collateral, debt);\n    _this2.stake = stake;\n    _this2.snapshotOfTotalRedistributed = snapshotOfTotalRedistributed;\n    return _this2;\n  }\n\n  _createClass(TroveWithPendingRedistribution, [{\n    key: \"applyRedistribution\",\n    value: function applyRedistribution(totalRedistributed) {\n      var afterRedistribution = this.add(totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake));\n      return new UserTrove(this.ownerAddress, this.status, afterRedistribution.collateral, afterRedistribution.debt);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(that) {\n      return _get(_getPrototypeOf(TroveWithPendingRedistribution.prototype), \"equals\", this).call(this, that) && this.stake.eq(that.stake) && this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed);\n    }\n  }]);\n\n  return TroveWithPendingRedistribution;\n}(UserTrove);\n\nexports.TroveWithPendingRedistribution = TroveWithPendingRedistribution;","map":{"version":3,"sources":["../../src/Trove.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TroveWithPendingRedistribution = exports.UserTrove = exports._emptyTrove = exports.Trove = exports._normalizeTroveAdjustment = exports._normalizeTroveCreation = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst Decimal_1 = require(\"./Decimal\");\nconst constants_1 = require(\"./constants\");\nconst invalidTroveCreation = (invalidTrove, error) => ({\n    type: \"invalidCreation\",\n    invalidTrove,\n    error\n});\nconst troveCreation = (params) => ({\n    type: \"creation\",\n    params\n});\nconst troveClosure = (params) => ({\n    type: \"closure\",\n    params\n});\nconst troveAdjustment = (params, setToZero) => ({\n    type: \"adjustment\",\n    params,\n    setToZero\n});\nconst valueIsDefined = (entry) => entry[1] !== undefined;\nconst allowedTroveCreationKeys = [\n    \"depositCollateral\",\n    \"borrowLUSD\"\n];\nfunction checkAllowedTroveCreationKeys(entries) {\n    const badKeys = entries\n        .filter(([k]) => !allowedTroveCreationKeys.includes(k))\n        .map(([k]) => `'${k}'`);\n    if (badKeys.length > 0) {\n        throw new Error(`TroveCreationParams: property ${badKeys.join(\", \")} not allowed`);\n    }\n}\nconst troveCreationParamsFromEntries = (entries) => {\n    const params = Object.fromEntries(entries);\n    const missingKeys = allowedTroveCreationKeys.filter(k => !(k in params)).map(k => `'${k}'`);\n    if (missingKeys.length > 0) {\n        throw new Error(`TroveCreationParams: property ${missingKeys.join(\", \")} missing`);\n    }\n    return params;\n};\nconst decimalize = ([k, v]) => [k, Decimal_1.Decimal.from(v)];\nconst nonZero = ([, v]) => !v.isZero;\n/** @internal */\nconst _normalizeTroveCreation = (params) => {\n    const definedEntries = Object.entries(params).filter(valueIsDefined);\n    checkAllowedTroveCreationKeys(definedEntries);\n    const nonZeroEntries = definedEntries.map(decimalize);\n    return troveCreationParamsFromEntries(nonZeroEntries);\n};\nexports._normalizeTroveCreation = _normalizeTroveCreation;\nconst allowedTroveAdjustmentKeys = [\n    \"depositCollateral\",\n    \"withdrawCollateral\",\n    \"borrowLUSD\",\n    \"repayLUSD\"\n];\nfunction checkAllowedTroveAdjustmentKeys(entries) {\n    const badKeys = entries\n        .filter(([k]) => !allowedTroveAdjustmentKeys.includes(k))\n        .map(([k]) => `'${k}'`);\n    if (badKeys.length > 0) {\n        throw new Error(`TroveAdjustmentParams: property ${badKeys.join(\", \")} not allowed`);\n    }\n}\nconst collateralChangeFrom = ({ depositCollateral, withdrawCollateral }) => {\n    if (depositCollateral !== undefined && withdrawCollateral !== undefined) {\n        throw new Error(\"TroveAdjustmentParams: 'depositCollateral' and 'withdrawCollateral' \" +\n            \"can't be present at the same time\");\n    }\n    if (depositCollateral !== undefined) {\n        return { depositCollateral };\n    }\n    if (withdrawCollateral !== undefined) {\n        return { withdrawCollateral };\n    }\n};\nconst debtChangeFrom = ({ borrowLUSD, repayLUSD }) => {\n    if (borrowLUSD !== undefined && repayLUSD !== undefined) {\n        throw new Error(\"TroveAdjustmentParams: 'borrowLUSD' and 'repayLUSD' can't be present at the same time\");\n    }\n    if (borrowLUSD !== undefined) {\n        return { borrowLUSD };\n    }\n    if (repayLUSD !== undefined) {\n        return { repayLUSD };\n    }\n};\nconst troveAdjustmentParamsFromEntries = (entries) => {\n    const params = Object.fromEntries(entries);\n    const collateralChange = collateralChangeFrom(params);\n    const debtChange = debtChangeFrom(params);\n    if (collateralChange !== undefined && debtChange !== undefined) {\n        return { ...collateralChange, ...debtChange };\n    }\n    if (collateralChange !== undefined) {\n        return collateralChange;\n    }\n    if (debtChange !== undefined) {\n        return debtChange;\n    }\n    throw new Error(\"TroveAdjustmentParams: must include at least one non-zero parameter\");\n};\n/** @internal */\nconst _normalizeTroveAdjustment = (params) => {\n    const definedEntries = Object.entries(params).filter(valueIsDefined);\n    checkAllowedTroveAdjustmentKeys(definedEntries);\n    const nonZeroEntries = definedEntries.map(decimalize).filter(nonZero);\n    return troveAdjustmentParamsFromEntries(nonZeroEntries);\n};\nexports._normalizeTroveAdjustment = _normalizeTroveAdjustment;\nconst applyFee = (borrowingRate, debtIncrease) => debtIncrease.mul(Decimal_1.Decimal.ONE.add(borrowingRate));\nconst unapplyFee = (borrowingRate, debtIncrease) => debtIncrease._divCeil(Decimal_1.Decimal.ONE.add(borrowingRate));\nconst NOMINAL_COLLATERAL_RATIO_PRECISION = Decimal_1.Decimal.from(100);\n/**\n * A combination of collateral and debt.\n *\n * @public\n */\nclass Trove {\n    /** @internal */\n    constructor(collateral = Decimal_1.Decimal.ZERO, debt = Decimal_1.Decimal.ZERO) {\n        this.collateral = collateral;\n        this.debt = debt;\n    }\n    get isEmpty() {\n        return this.collateral.isZero && this.debt.isZero;\n    }\n    /**\n     * Amount of LUSD that must be repaid to close this Trove.\n     *\n     * @remarks\n     * This doesn't include the liquidation reserve, which is refunded in case of normal closure.\n     */\n    get netDebt() {\n        if (this.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n            throw new Error(`netDebt should not be used when debt < ${constants_1.LUSD_LIQUIDATION_RESERVE}`);\n        }\n        return this.debt.sub(constants_1.LUSD_LIQUIDATION_RESERVE);\n    }\n    /** @internal */\n    get _nominalCollateralRatio() {\n        return this.collateral.mulDiv(NOMINAL_COLLATERAL_RATIO_PRECISION, this.debt);\n    }\n    /** Calculate the Trove's collateralization ratio at a given price. */\n    collateralRatio(price) {\n        return this.collateral.mulDiv(price, this.debt);\n    }\n    /**\n     * Whether the Trove is undercollateralized at a given price.\n     *\n     * @returns\n     * `true` if the Trove's collateralization ratio is less than the\n     * {@link MINIMUM_COLLATERAL_RATIO}.\n     */\n    collateralRatioIsBelowMinimum(price) {\n        return this.collateralRatio(price).lt(constants_1.MINIMUM_COLLATERAL_RATIO);\n    }\n    /**\n     * Whether the collateralization ratio is less than the {@link CRITICAL_COLLATERAL_RATIO} at a\n     * given price.\n     *\n     * @example\n     * Can be used to check whether the Liquity protocol is in recovery mode by using it on the return\n     * value of {@link ReadableLiquity.getTotal | getTotal()}. For example:\n     *\n     * ```typescript\n     * const total = await liquity.getTotal();\n     * const price = await liquity.getPrice();\n     *\n     * if (total.collateralRatioIsBelowCritical(price)) {\n     *   // Recovery mode is active\n     * }\n     * ```\n     */\n    collateralRatioIsBelowCritical(price) {\n        return this.collateralRatio(price).lt(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** Whether the Trove is sufficiently collateralized to be opened during recovery mode. */\n    isOpenableInRecoveryMode(price) {\n        return this.collateralRatio(price).gte(constants_1.CRITICAL_COLLATERAL_RATIO);\n    }\n    /** @internal */\n    toString() {\n        return `{ collateral: ${this.collateral}, debt: ${this.debt} }`;\n    }\n    equals(that) {\n        return this.collateral.eq(that.collateral) && this.debt.eq(that.debt);\n    }\n    add(that) {\n        return new Trove(this.collateral.add(that.collateral), this.debt.add(that.debt));\n    }\n    addCollateral(collateral) {\n        return new Trove(this.collateral.add(collateral), this.debt);\n    }\n    addDebt(debt) {\n        return new Trove(this.collateral, this.debt.add(debt));\n    }\n    subtract(that) {\n        const { collateral, debt } = that;\n        return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n    subtractCollateral(collateral) {\n        return new Trove(this.collateral.gt(collateral) ? this.collateral.sub(collateral) : Decimal_1.Decimal.ZERO, this.debt);\n    }\n    subtractDebt(debt) {\n        return new Trove(this.collateral, this.debt.gt(debt) ? this.debt.sub(debt) : Decimal_1.Decimal.ZERO);\n    }\n    multiply(multiplier) {\n        return new Trove(this.collateral.mul(multiplier), this.debt.mul(multiplier));\n    }\n    setCollateral(collateral) {\n        return new Trove(Decimal_1.Decimal.from(collateral), this.debt);\n    }\n    setDebt(debt) {\n        return new Trove(this.collateral, Decimal_1.Decimal.from(debt));\n    }\n    _debtChange({ debt }, borrowingRate) {\n        return debt.gt(this.debt)\n            ? { borrowLUSD: unapplyFee(borrowingRate, debt.sub(this.debt)) }\n            : { repayLUSD: this.debt.sub(debt) };\n    }\n    _collateralChange({ collateral }) {\n        return collateral.gt(this.collateral)\n            ? { depositCollateral: collateral.sub(this.collateral) }\n            : { withdrawCollateral: this.collateral.sub(collateral) };\n    }\n    /**\n     * Calculate the difference between this Trove and another.\n     *\n     * @param that - The other Trove.\n     * @param borrowingRate - Borrowing rate to use when calculating a borrowed amount.\n     *\n     * @returns\n     * An object representing the change, or `undefined` if the Troves are equal.\n     */\n    whatChanged(that, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n        var _a;\n        if (this.collateral.eq(that.collateral) && this.debt.eq(that.debt)) {\n            return undefined;\n        }\n        if (this.isEmpty) {\n            if (that.debt.lt(constants_1.LUSD_LIQUIDATION_RESERVE)) {\n                return invalidTroveCreation(that, \"missingLiquidationReserve\");\n            }\n            return troveCreation({\n                depositCollateral: that.collateral,\n                borrowLUSD: unapplyFee(borrowingRate, that.netDebt)\n            });\n        }\n        if (that.isEmpty) {\n            return troveClosure(this.netDebt.nonZero\n                ? { withdrawCollateral: this.collateral, repayLUSD: this.netDebt }\n                : { withdrawCollateral: this.collateral });\n        }\n        return this.collateral.eq(that.collateral)\n            ? troveAdjustment(this._debtChange(that, borrowingRate), that.debt.zero && \"debt\")\n            : this.debt.eq(that.debt)\n                ? troveAdjustment(this._collateralChange(that), that.collateral.zero && \"collateral\")\n                : troveAdjustment({\n                    ...this._debtChange(that, borrowingRate),\n                    ...this._collateralChange(that)\n                }, (_a = (that.debt.zero && \"debt\")) !== null && _a !== void 0 ? _a : (that.collateral.zero && \"collateral\"));\n    }\n    /**\n     * Make a new Trove by applying a {@link TroveChange} to this Trove.\n     *\n     * @param change - The change to apply.\n     * @param borrowingRate - Borrowing rate to use when adding a borrowed amount to the Trove's debt.\n     */\n    apply(change, borrowingRate = constants_1.MINIMUM_BORROWING_RATE) {\n        if (!change) {\n            return this;\n        }\n        switch (change.type) {\n            case \"invalidCreation\":\n                if (!this.isEmpty) {\n                    throw new Error(\"Can't create onto existing Trove\");\n                }\n                return change.invalidTrove;\n            case \"creation\": {\n                if (!this.isEmpty) {\n                    throw new Error(\"Can't create onto existing Trove\");\n                }\n                const { depositCollateral, borrowLUSD } = change.params;\n                return new Trove(depositCollateral, constants_1.LUSD_LIQUIDATION_RESERVE.add(applyFee(borrowingRate, borrowLUSD)));\n            }\n            case \"closure\":\n                if (this.isEmpty) {\n                    throw new Error(\"Can't close empty Trove\");\n                }\n                return exports._emptyTrove;\n            case \"adjustment\": {\n                const { setToZero, params: { depositCollateral, withdrawCollateral, borrowLUSD, repayLUSD } } = change;\n                const collateralDecrease = withdrawCollateral !== null && withdrawCollateral !== void 0 ? withdrawCollateral : Decimal_1.Decimal.ZERO;\n                const collateralIncrease = depositCollateral !== null && depositCollateral !== void 0 ? depositCollateral : Decimal_1.Decimal.ZERO;\n                const debtDecrease = repayLUSD !== null && repayLUSD !== void 0 ? repayLUSD : Decimal_1.Decimal.ZERO;\n                const debtIncrease = borrowLUSD ? applyFee(borrowingRate, borrowLUSD) : Decimal_1.Decimal.ZERO;\n                return setToZero === \"collateral\"\n                    ? this.setCollateral(Decimal_1.Decimal.ZERO).addDebt(debtIncrease).subtractDebt(debtDecrease)\n                    : setToZero === \"debt\"\n                        ? this.setDebt(Decimal_1.Decimal.ZERO)\n                            .addCollateral(collateralIncrease)\n                            .subtractCollateral(collateralDecrease)\n                        : this.add(new Trove(collateralIncrease, debtIncrease)).subtract(new Trove(collateralDecrease, debtDecrease));\n            }\n        }\n    }\n    /**\n     * Calculate the result of an {@link TransactableLiquity.openTrove | openTrove()} transaction.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when calculating the Trove's debt.\n     */\n    static create(params, borrowingRate) {\n        return exports._emptyTrove.apply(troveCreation(exports._normalizeTroveCreation(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.openTrove | openTrove()} transaction\n     * that will result in the given Trove.\n     *\n     * @param that - The Trove to recreate.\n     * @param borrowingRate - Current borrowing rate.\n     */\n    static recreate(that, borrowingRate) {\n        const change = exports._emptyTrove.whatChanged(that, borrowingRate);\n        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"creation\");\n        return change.params;\n    }\n    /**\n     * Calculate the result of an {@link TransactableLiquity.adjustTrove | adjustTrove()} transaction\n     * on this Trove.\n     *\n     * @param params - Parameters of the transaction.\n     * @param borrowingRate - Borrowing rate to use when adding to the Trove's debt.\n     */\n    adjust(params, borrowingRate) {\n        return this.apply(troveAdjustment(exports._normalizeTroveAdjustment(params)), borrowingRate);\n    }\n    /**\n     * Calculate the parameters of an {@link TransactableLiquity.adjustTrove | adjustTrove()}\n     * transaction that will change this Trove into the given Trove.\n     *\n     * @param that - The desired result of the transaction.\n     * @param borrowingRate - Current borrowing rate.\n     */\n    adjustTo(that, borrowingRate) {\n        const change = this.whatChanged(that, borrowingRate);\n        assert_1.default((change === null || change === void 0 ? void 0 : change.type) === \"adjustment\");\n        return change.params;\n    }\n}\nexports.Trove = Trove;\n/** @internal */\nexports._emptyTrove = new Trove();\n/**\n * A Trove that is associated with a single owner.\n *\n * @remarks\n * The SDK uses the base {@link Trove} class as a generic container of collateral and debt, for\n * example to represent the {@link ReadableLiquity.getTotal | total collateral and debt} locked up\n * in the protocol.\n *\n * The `UserTrove` class extends `Trove` with extra information that's only available for Troves\n * that are associated with a single owner (such as the owner's address, or the Trove's status).\n *\n * @public\n */\nclass UserTrove extends Trove {\n    /** @internal */\n    constructor(ownerAddress, status, collateral, debt) {\n        super(collateral, debt);\n        this.ownerAddress = ownerAddress;\n        this.status = status;\n    }\n    equals(that) {\n        return (super.equals(that) && this.ownerAddress === that.ownerAddress && this.status === that.status);\n    }\n    /** @internal */\n    toString() {\n        return (`{ ownerAddress: \"${this.ownerAddress}\"` +\n            `, collateral: ${this.collateral}` +\n            `, debt: ${this.debt}` +\n            `, status: \"${this.status}\" }`);\n    }\n}\nexports.UserTrove = UserTrove;\n/**\n * A Trove in its state after the last direct modification.\n *\n * @remarks\n * The Trove may have received collateral and debt shares from liquidations since then.\n * Use {@link TroveWithPendingRedistribution.applyRedistribution | applyRedistribution()} to\n * calculate the Trove's most up-to-date state.\n *\n * @public\n */\nclass TroveWithPendingRedistribution extends UserTrove {\n    /** @internal */\n    constructor(ownerAddress, status, collateral, debt, stake = Decimal_1.Decimal.ZERO, snapshotOfTotalRedistributed = exports._emptyTrove) {\n        super(ownerAddress, status, collateral, debt);\n        this.stake = stake;\n        this.snapshotOfTotalRedistributed = snapshotOfTotalRedistributed;\n    }\n    applyRedistribution(totalRedistributed) {\n        const afterRedistribution = this.add(totalRedistributed.subtract(this.snapshotOfTotalRedistributed).multiply(this.stake));\n        return new UserTrove(this.ownerAddress, this.status, afterRedistribution.collateral, afterRedistribution.debt);\n    }\n    equals(that) {\n        return (super.equals(that) &&\n            this.stake.eq(that.stake) &&\n            this.snapshotOfTotalRedistributed.equals(that.snapshotOfTotalRedistributed));\n    }\n}\nexports.TroveWithPendingRedistribution = TroveWithPendingRedistribution;\n//# sourceMappingURL=Trove.js.map"]},"metadata":{},"sourceType":"script"}